---
title: "ZLWB2"
author: "Tao Chen & Eva Brinkman"
date: '23 March 2018'
output:
  html_document: default
  pdf_document: default
---

```{r variables}

#which libraries are needed
library("plyr")
library(deSolve)
library(minpack.lm)
library(FME)
library("Biostrings")
library(truncnorm)
library(colorspace)

time_all <- c(0, 4, 8, 10, 12, 14, 16, 18, 21, 24, 33, 37, 38, 42,48,54, 60) #time point + shield

```

<h2>Declaration of simple fitting functions</h2>
<p>simpleDefault: for individual series comparing with ZLWB2fitDefault</p>
<p>simplePiledupOMMerge: for individual series comparing with ZLWB2PiledupOMMerge</p>

```{r simple ODE model}

##################################################################################
# simpleDefault: for individual series comparing with ZLWB2fitDefault
##################################################################################
simpleDefault = function(time,wt,indel){
  t= seq(0,max(time*10))/10;
  
  # fitting untransfected
  x=time
  y=wt/100
  z=indel/100
  
  index = which(is.finite(x+y+z));
  
  x = x[index];
  y = y[index];
  z = z[index];
  
  fitmodel <- nls(y~(1-a/(1 + exp(-b * (x-c)))), start=list(a=25,b=1,c=1))
  U = 1-coef(fitmodel)[1]
  untransf=U
  
  listkinetc=list(NULL);
  
  rxnrate=function(t,c,parms){
    
    # rate constant passed through a list called parms
    kc=parms[1]
    kp=parms[2]
    km=parms[3]
    
    # c is the concentration of species
    
    # derivatives dc/dt are computed below
    r=rep(0,length(c))
    r[1]=-kc*c["P"]+kp*c["B"] #dcA/dt
    r[2]=kc*c["P"]-(kp+km)*c["B"] #dcB/dt
    r[3]=km*c["B"] #dcC/dt
    
    # the computed derivatives are returned as a list
    # order of derivatives needs to be the same as the order of species in c
    return(list(r))
    
  }
  
  # function for fitting results
  rxnrate_fit = function(parms){
    
    tmax = max(time); 
    
    kc=log(2)/parms[1];
    kp=log(2)/parms[2];
    km=log(2)/parms[3];
    
    out=ode(y=c(P=as.numeric(1-U),B=0,M=0),times=t,func=rxnrate,parms=c(kc,kp,km))
    
    s=out[,2:4]; 
    
    P = s[(out[,1]) %in% x,1];
    M=  s[(out[,1]) %in% x,3];
    
    return(c((U+P)/(U+P+M)-df[,2]))
  }
  
  # function for repair results
  rxnrate_repair = function(parms,U){
    
    kc=log(2)/parms[1];
    kp=log(2)/parms[2];
    km=log(2)/parms[3];
    
    out=ode(y=c(P=as.numeric(1-U),B=0,M=0),times=t,func=rxnrate,parms=c(kc,kp,km))
    
    s=out[,2:4]; 
    
    P = s[(out[,1]) %in% x,1];
    M=  s[(out[,1]) %in% x,3]; 
    
    return(list(1-P-U-M,(P+U)/(P+U+M),M/(P+U+M)))
  }
  
  # fitting
  
  df= data.frame(time=x, wt=y*100, indel=z*100)
  
  df[,1]=df[,1]-df[1,1]
  
  df[,2:3]=df[,2:3]/100
  
  t= seq(0,max(df[,1])*10)/10
  
  parms=c(8,8,8)
  
  FL= try(modFit(f=rxnrate_fit,p=parms,lower=rep(0,length(parms))),silent=TRUE)
  
  if (length(FL)>1){
    residuals=resid (FL)
    
    listkinetc=list(perfectF = 1/FL$par[2],
                    hlc = round(FL$par[1],1),
                    hlm = round(FL$par[3],1),
                    intact=rxnrate_repair(FL$par,U)[[2]],
                    broken=rxnrate_repair(FL$par,U)[[1]],
                    maxBro = max(rxnrate_repair(FL$par,U)[[1]]),
                    peakBro =time[which.max(rxnrate_repair(FL$par,U)[[1]])],
                    mutant=rxnrate_repair(FL$par,U)[[3]],
                    residual_sq=sum(residuals^2));
  }
  
  
  
  
  return(listkinetc);
}
##################################################################################

##################################################################################
# simplePiledupOMMerge: for individual series comparing with ZLWB2PiledupOMMerge
##################################################################################
simplePiledupOMMerge = function(time,wt,indel){
  
  t= seq(0,max(time*10))/10;
  
  rxnrate=function(t,c,parms){
    
    # rate constant passed through a list called parms
    kc=parms[1]
    kp=parms[2]
    km=parms[3]
    
    # c is the concentration of species
    
    # derivatives dc/dt are computed below
    r=rep(0,length(c))
    r[1]=-kc*c["P"]+kp*c["B"] #dcA/dt
    r[2]=kc*c["P"]-(kp+km)*c["B"] #dcB/dt
    r[3]=km*c["B"]
    
    # the computed derivatives are returned as a list
    # order of derivatives needs to be the same as the order of species in c
    return(list(r))
    
  }
  
  # function for fitting results
  rxnrate_fit = function(parms){
    
    res = rep(list(NULL),ncol(wt));
    
    for (i in 1:length(res)){
      # fitting untransfected
      x=time
      y=wt[,i]/100
      z=indel[,i]/100
      
      index = which(is.finite(x+y+z));
      
      x = x[index];
      y = y[index];
      z = z[index];
      
      fitmodel <- nls(y~(1-a/(1 + exp(-b * (x-c)))), start=list(a=25,b=1,c=1))
      U = 1-coef(fitmodel)[1]
      untransf=U;
      
      
      
      tmax = max(time); 
      
      kc=log(2)/parms[1];
      kp=log(2)/parms[2]
      km=log(2)/parms[3];
      
      out=ode(y=c(P=as.numeric(1-U),B=0,M=0),times=t,func=rxnrate,parms=c(kc,kp,km))
      
      s=out[,2:4]; 
      
      P = s[(out[,1]) %in% x,1];
      M=  s[(out[,1]) %in% x,3];
      
      res[[i]] =c(M/(U+P+M)-z)
    }
    
    return(unlist(res))
    
  }
  
  parms=c(8,8,8)
  
  FL= try(modFit(f=rxnrate_fit,p=parms,lower=rep(0,length(parms))),silent=TRUE)
  
  return(FL);
}

```

<h2>Simulations</h2>

<p>Try out various set of rate constants to investigate the shape of the curve</p>

```{r Simulaties}

 t= seq(0,max(time_all*10))/10;

####simple model functions
rxnrate=function(t,c,parms){
  
  # rate constant passed through a list called parms
  kc=parms[1]
  kp=parms[2]
  km=parms[3]
  
  # c is the concentration of species
  
  # derivatives dc/dt are computed below
  r=rep(0,length(c))
  r[1]=-kc*c["P"]+kp*c["B"] #dcA/dt
  r[2]=kc*c["P"]-(kp+km)*c["B"] #dcB/dt
  r[3]=km*c["B"] #dcC/dt
  
  # the computed derivatives are returned as a list
  # order of derivatives needs to be the same as the order of species in c
  return(list(r))
  
}


# function for repair results
rxnrate_repair = function(parms,U){
  
  kc=parms[1];
  kp=parms[2];
  km=parms[3];
  
  out=ode(y=c(P=as.numeric(1-U),B=0,M=0),times=t,func=rxnrate,parms=c(kc,kp,km))
  
  s=out[,2:4]; 
  
  P = s[,1];
  M=  s[,3]; 
  
  return(list(1-P-U-M,(P+U)/(P+U+M),M/(P+U+M)))
}


###test various rate constants
parms1 <- c(0.1, 0.1, 0.1)
parms2 <- c(0.1, 0.01, 0.1)
parms3 <- c(0.1, 0.1, 0.01)
parms4 <- c(0.01, 0.1, 0.1)
parms5 <- c(0.5, 0.1, 0.1)
parms6 <- c(0.5, 0.1, 0.01)

# plot intact
plot(main=paste('simple'),cex.main=1.5, t,100* rxnrate_repair(parms1,0)[[2]],lwd=2,lty=1, pch=16,cex=1.5,col=2,cex.lab=1.5,cex.axis=1.5,xlab='time (h)',ylab='intact (%)', ylim=c(0,100), type="l")
lines(t,100* rxnrate_repair(parms2,0)[[2]],lwd=2,lty=2, col=2, type="l")
lines(t,100* rxnrate_repair(parms3,0)[[2]],lwd=2,lty=3, col=2, type="l")
lines(t,100* rxnrate_repair(parms4,0)[[2]],lwd=2,lty=4, col=2, type="l")
lines(t,100* rxnrate_repair(parms5,0)[[2]],lwd=2,lty=6, col=2, type="l")
lines(t,100* rxnrate_repair(parms6,0)[[2]],lwd=2,lty=5, col=2, type="l")

# plot mutated
plot(main=paste('simple'),cex.main=1.5, t,100*rxnrate_repair(parms1,0)[[3]],lwd=2,lty=1, pch=16,cex=1.5,col=3,cex.lab=1.5,cex.axis=1.5, xlab='time (h)',ylab='indel (%)', ylim=c(0,100), type="l")
lines(t,100* rxnrate_repair(parms2,0)[[3]],lwd=2,lty=2, col=3, type="l")
lines(t,100* rxnrate_repair(parms3,0)[[3]],lwd=2,lty=3, col=3, type="l")
lines(t,100* rxnrate_repair(parms4,0)[[3]],lwd=2,lty=4, col=3, type="l")
lines(t,100* rxnrate_repair(parms5,0)[[3]],lwd=2,lty=6, col=3, type="l")
lines(t,100* rxnrate_repair(parms6,0)[[3]],lwd=2,lty=5, col=3, type="l")

# plot broken fractions
plot(main=paste('simple'),cex.main=1.5,cex.lab=1.5,cex.axis=1.5, lwd=2,lty=1, t,c(rxnrate_repair(parms1,0)[[1]]*100),pch=16,type='l',cex=1.5,col=4,xlab='time (h)',ylab='broken (%)', ylim=c(0,100))
lines(t,100* rxnrate_repair(parms2,0)[[1]],lwd=2,lty=2, col=4, type="l")
lines(t,100* rxnrate_repair(parms3,0)[[1]],lwd=2,lty=3, col=4, type="l")
lines(t,100* rxnrate_repair(parms4,0)[[1]],lwd=2,lty=4, col=4, type="l")
lines(t,100* rxnrate_repair(parms5,0)[[1]],lwd=2,lty=6, col=4, type="l")
lines(t,100* rxnrate_repair(parms6,0)[[1]],lwd=2,lty=5, col=4, type="l")

rates <- data.frame(rates <- c('kc', 'kp', 'km'),
                p1 <- round(parms1,2), 
                p2 <- round(parms2,2),
                p3 <- round(parms3,2),
                p4 <- round(parms4,2),
                p5 <- round(parms5,2),
                p6 <- round(parms6,2))

legend('topright',ncol=3, cex=1.0,bty='n', lty=c(NA, 1,2,3,4,6,5), t(rates))


```


<h2>Western blot based ODE model</h2>
<p>1: Cas9 has zero activities (extremey large decay rate) without Shield-1</p>
<p>2: Cas9 is activated to certain stable form that has nuclease activity by adding Shield-1</p>
<p>3: Cas9 activity is proportional to Cas9 abundance quantified by western blot after introduction of Shield-1</p>
<p>4: Untransfected fraction (U) is estimated by sigmoid fitting</p>
<p>5: M(i)/(U+P+M) is the target of fitting, with M(i) being individual mutation or total mutation</p>
<p>6: Sweeping kp/km and apply F-statistic to estimate the upperbound of perfect repair versus mutagentic repair ratio</p>


<h2>Cas9 kinetics</h2>
<p> fitting to western blot data of Cas9 activation</p>

```{r Cas9}

library(FME);

# Cas9 protein kinetics

#average intensity of western blot (n=3)
tWB = c(60,42,33,24,21,18,16,14,12,10,8,4,0)
  
Cas9I = c(1.035116259,0.93119759,1.134895008,0.980514232,0.989879665,0.903886513, 1.211372653,0.575621105,0.782199246,0.686693037,0.608119422,0.325573414,0.142920737)
  
#individual intensities of separate experiments
tWB1 = c(60, 60, 60, 42, 42,42,33,33,33,24,24,24,21,21,21,18,18,18,16,16,16,14,14,14,12,12,12,10,10,10,8,8,8,4,4,4,0,0,0)

Cas9I1 = c(0.874859076, 0.928020566, 1.302469136, 0.722660654, 1.107969152, 0.962962963, 0.91319053, 1.03470437,  1.456790123, 0.735062007, 1.101542416,  1.104938272,   1.041713641, 0.61311054, 1.314814815, 0.862457723, 0.651670951, 1.197530864, 1.240135287, 0.597686375, 1.796296296, 0.426155581, 0.424164524, 0.87654321, 0.314543405, 0.686375321, 1.345679012, 0.562570462, 0.343187661, 1.154320988, 0.400225479,0.485861183, 0.938271605, 0.162344983,0.254498715, 0.559876543,   0.06833713, 0.262210797,0.098214286)
  
#Cas9 activity fitting
Cas9WIfit=function(parms){
    
  b=parms[1]
  D=Inf
  Dp=parms[2]

  Cas9=Cas9I;
    
  coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
  return(c(coI)-c(Cas9))
  }
  
  Cas9WISim=function(parms){
    
  b=parms[1]
  D=Inf
  Dp=parms[2]

  Cas9=Cas9I;
    
  coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
  return(list(coI))
  }

 parms = c(1,0.1);
 FL= modFit(f= Cas9WIfit,p=parms,lower=rep(0,length(parms)))
 becy = FL$par;

 b=becy[1];
 Dp=becy[2];

#overlay constant cas9 kinetics with WB data 
plot(tWB1, Cas9I1/(becy[1]/becy[2])*100,pch=16, ylim=c(0,100),ylab='Cas9 activity (%)', xlab = 'time (h)',cex=1.5)
abline(h=100,lwd=3,col=4)
legend('bottomright',c('n = 3', ''),bty='n')

#overlay constant cas9 kinetics with fitting 
plot(tWB1, Cas9I1/(becy[1]/becy[2])*100,pch=16, ylim=c(0,100),ylab='Cas9 activity (%)', xlab = 'time (h)',cex=1.5)
lines(seq(0,60,0.01), (b/Dp+(-b/Dp)*exp(-Dp*seq(0,60,0.01)))/(becy[1]/becy[2])*100,lwd=3)
legend('bottomright',c('n = 3', paste('+shield =',round(log(2)/becy[2],1),'h'),''),bty='n')

#overlay cas9 fitting with average WB data
plot(tWB, Cas9I/(becy[1]/becy[2])*100,pch=16, ylim=c(0,max(Cas9I/(becy[1]/becy[2])*100)),ylab='Cas9 activity (%)', xlab = 'time (h)',cex=1.5)
lines(seq(0,60,0.01), (b/Dp+(-b/Dp)*exp(-Dp*seq(0,60,0.01)))/(becy[1]/becy[2])*100,lwd=3)
legend('bottomright',c('n = 3', paste('+shield =',round(log(2)/becy[2],1),'h'),''),bty='n')

```

<h2>Declaration of modeling functions</h2>

<h3>Individual Series</h3>
<p>ZLWB2fit: fitting to total indels, sweeping 2^21 fold, with predictions from each sweeping all stored and returned</p>
<p>ZLWB2fitPoverF: fitting to total indels, specifiying a perticular p/m factor that is log2 transformed, with all predictions stored and returned</p>
<p>ZLWB2fitDefault: fitting to total indels, a complete model for optimal values of kc kp and km, with all predictions stored and returned</p>
<p>ZLWB2fit_Mutants: fitting to individual indels, sweeping 2^21 fold, with predictions from each sweeping all stored and returned</p>
<p>ZLWB2fitPoverF_Mutants: fitting to individual indels, specifiying a perticular p/m factor that is log2 transformed, with all predictions stored and returned</p>
<p>ZLWB2fit_MutantsDefault: fitting to individual indels, a complete model for optimal values of kc kp and km, kplus1 and kminus7, with all predictions stored and returned</p>

<h3>Piled-up for upperbound determination</h3>
<p>ZLWB2PiledupOM: fitting to individual indels pipled up with all specified data serieses, a complete model for optimal values of kc km and kp, kplus1 and kminus7, with modelling results returned</p>
<p>ZLWB2PiledupSweep: fitting to individual indels pipled up with all specified data serieses, specifiying a perticular p/m factor, with modelling results returned</p>
<p>ZLWB2PiledupOMMerge: fitting to total indels pipled up with all specified data serieses, a complete model for optimal values of kc kp and km, with modelling results returned, including peakBro</p>
<p>ZLWB2PiledupSweepMerge: fitting to total indels pipled up with all specified data serieses, specifiying a perticular p/m factor, with modelling results returned, including peakBro</p>
<p>UntransfectedFitting: fitting sigmod curve to obtain the untransfected fraction, returning sigmoid factors</p>

```{r ODE model}

##################################################################################
# ZLWB2fit: fitting to total indels, sweeping 2^21 fold, with predictions from each sweeping all stored and returned
##################################################################################

ZLWB2fit = function(time,wt,indel,PoverF=1, U=NA){
  t= seq(0,max(time*10))/10;
  
  ### cas9 fitting
  # Cas9 protein kinetics
  tWB = c(60,42,33,24,21,18,16,14,12,10,8,4,0)
  
  Cas9I = c(1.035116259,0.93119759,1.134895008,0.980514232,0.989879665,0.903886513,1.211372653,0.575621105,0.782199246,0.686693037,0.608119422,0.325573414,0.142920737)

  
  Cas9WIfit=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]

    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
    return(c(coI)-c(Cas9))
  }
  
  Cas9WISim=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]

    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
    return(list(coI))
  }
  
  parms = c(1,0.1);
  FL= modFit(f= Cas9WIfit,p=parms,lower=rep(0,length(parms)))
  becy = FL$par;

  
  # fitting untransfected
  x=time
  y=wt/100
  z=indel/100
  
  index = which(is.finite(x+y+z));
  
  x = x[index];
  y = y[index];
  z = z[index];
  
  fitmodel <- nls(y~(1-a/(1 + exp(-b * (x-c)))), start=list(a=25,b=1,c=1))
  U<-ifelse(is.na(U), 1-coef(fitmodel)[1], U)
  untransf=U
  
  listkinetc=rep(list(NULL),21);
  
  for (i in 1:21){
    
    perfect=2^11/2^i*PoverF;
    
    WB1rxnrate=function(t,c,parms){
      
      # rate constant passed through a list called parms
      kc=parms[1]
      kp=parms[2]*perfect
      km=parms[2]
      
      b=becy[1];
      D=Inf;
      Dp=becy[2];
      
      # c is the concentration of species
      
      # derivatives dc/dt are computed below
      r=rep(0,length(c))
      r[1]=-kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp+kp*c["B"] #dcA/dt
      r[2]=kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp-(kp+km)*c["B"] #dcB/dt
      r[3]=km*c["B"] #dcC/dt
      
      # the computed derivatives are returned as a list
      # order of derivatives needs to be the same as the order of species in c
      return(list(r))
      
    }
    
    
    # function for fitting results
    WB1rxnrate_fit = function(parms){
      
      tmax = max(time); 
      
      kc=log(2)/parms[1];
      kp=log(2)/parms[2]/perfect;
      km=log(2)/parms[2];
      
      b=becy[1];
      D=Inf;
      Dp=becy[2];
      
      out=ode(y=c(P=as.numeric(1-U),B=0,M=0),times=t,func=WB1rxnrate,parms=c(kc,km))
      
      s=out[,2:4]; 
      
      P = s[(out[,1]) %in% x,1];
      M=  s[(out[,1]) %in% x,3];
      
      return(c((U+P)/(U+P+M)-y))
    }
    
    # function for repair results
    rxnrate_repair = function(parms,U){
      
      tmax = max(time); 
      
      kc=log(2)/parms[1];
      kp=log(2)/parms[2]/perfect;
      km=log(2)/parms[2];
      
      b = becy[1];
      D=Inf;
      Dp=becy[2];
      
      out=ode(y=c(P=as.numeric(1-U),B=0,M=0),times=t,func=WB1rxnrate,parms=c(kc,km))
      
      s=out[,2:4]; 
      
      P = s[(out[,1]) %in% x,1];
      M=  s[(out[,1]) %in% x,3];
      
      return(list(s[,2],(P+U)/(P+U+M),M/(P+U+M)))
    }
    
   
    #input data points
    df= data.frame(time=x, wt=y*100, indel=z*100)
    
    df[,1]=df[,1]-df[1,1]
    
    df[,2:3]=df[,2:3]/100
    
    t= seq(0,max(df[,1])*10)/10
    
    parms=c(8,8)
    
    FL = try(modFit(f=WB1rxnrate_fit,p=parms,lower=rep(0,length(parms))), silent = TRUE)
    
    if(length(FL)>1){
      residuals=resid (FL)
      
      
      listkinetc[[i]]=list(perfectF = perfect,
                           hlc = FL$par[1],
                           hlm = FL$par[2],
                           intact= rxnrate_repair(FL$par,U)[[2]],
                           broken= rxnrate_repair(FL$par,U)[[1]],
                           maxBro = max( rxnrate_repair(FL$par,U)[[1]]),
                           peakBro = seq(0,max(time),0.1)[which.max(rxnrate_repair(FL$par,U)[[1]])],
                           mutant= rxnrate_repair(FL$par,U)[[3]],
                           residual_sq=sum(residuals^2),
                           washintact=rxnrate_repairWash(FL$par,U)[[2]],
                           washmutant=rxnrate_repairWash(FL$par,U)[[3]]
      );
      
    }
  }
  
  listkinetc = listkinetc[!is.null(listkinetc)];
  
  return(listkinetc);
}
##################################################################################

##################################################################################
# ZLWB2fitPoverF: fitting to total indels, specifiying a perticular p/m factor that is log2 transformed, with all predictions stored and returned
##################################################################################

ZLWB2fitPoverF = function(time,wt,indel,PoverF, U=NA){

  t= seq(0,max(time*10))/10;
  
  ### cas9 fitting
  # Cas9 protein kinetics
  tWB = c(60,42,33,24,21,18,16,14,12,10,8,4,0)
  
  Cas9I = c(1.035116259,0.93119759,1.134895008,0.980514232,0.989879665,0.903886513,1.211372653,0.575621105,0.782199246,0.686693037,0.608119422,0.325573414,0.142920737)
  
  Cas9WIfit=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]

    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
    return(c(coI)-c(Cas9))
  }
  
  Cas9WISim=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]

    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
    return(list(coI))
  }
  
  parms = c(1,0.1);
  FL= modFit(f= Cas9WIfit,p=parms,lower=rep(0,length(parms)))
  becy = FL$par;
  #####
  
  
  # fitting untransfected
  x=time
  y=wt/100
  z=indel/100
  
  index = which(is.finite(x+y+z));
  
  x = x[index];
  y = y[index];
  z = z[index];
  
  fitmodel <- nls(y~(1-a/(1 + exp(-b * (x-c)))), start=list(a=25,b=1,c=1))
  U<-ifelse(is.na(U), 1-coef(fitmodel)[1], U)
  untransf=U
  
  listkinetc=list(NULL);
  
  perfect=2^PoverF;
  WB1rxnrate=function(t,c,parms){
    
    # rate constant passed through a list called parms
    kc=parms[1]
    kp=parms[2]*perfect
    km=parms[2]
    
    b=becy[1];
    D=Inf;
    Dp=becy[2];
    
    # c is the concentration of species
    
    # derivatives dc/dt are computed below
    r=rep(0,length(c))
    r[1]=-kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp+kp*c["B"] #dcA/dt
    r[2]=kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp-(kp+km)*c["B"] #dcB/dt
    r[3]=km*c["B"] #dcC/dt
    
    # the computed derivatives are returned as a list
    # order of derivatives needs to be the same as the order of species in c
    return(list(r))
    
  }
  
  
  # function for fitting results
  WB1rxnrate_fit = function(parms){
    
    tmax = max(time); 
    
    kc=log(2)/parms[1];
    kp=log(2)/parms[2]/perfect;
    km=log(2)/parms[2];
    
    b = becy[1];
    D=Inf;
    Dp=becy[2];
    
    out=ode(y=c(P=as.numeric(1-U),B=0,M=0),times=t,func=WB1rxnrate,parms=c(kc,km))
    
    s=out[,2:4]; 
    
    P = s[(out[,1]) %in% x,1];
    M=  s[(out[,1]) %in% x,3];
    
    return(c((U+P)/(U+P+M)-y))
  }
  
  # function for repair results
  rxnrate_repair = function(parms,U){
    
    tmax = max(time); 
    
    kc=log(2)/parms[1];
    kp=log(2)/parms[2]/perfect;
    km=log(2)/parms[2];
    
    b = becy[1];
    D=Inf;
    Dp=becy[2];
    
    out=ode(y=c(P=as.numeric(1-U),B=0,M=0),times=t,func=WB1rxnrate,parms=c(kc,km))
    
    s=out[,2:4]; 
    
    P = s[(out[,1]) %in% x,1];
    M=  s[(out[,1]) %in% x,3];
    
    return(list(s[,2],(P+U)/(P+U+M),M/(P+U+M)))
  }
  
 
  # fitting
  df= data.frame(time=x, wt=y*100, indel=z*100)
  
  df[,1]=df[,1]-df[1,1]
  
  df[,2:3]=df[,2:3]/100
  
  t= seq(0,max(df[,1])*10)/10
  
  parms=c(8,8)
  
  FL= try(modFit(f=WB1rxnrate_fit,p=parms,lower=rep(0,length(parms))),silent=TRUE)
  
  if (length(FL)>1){
    residuals=resid (FL)
    
    listkinetc=list(perfectF = perfect,
                    hlc = FL$par[1],
                    hlm = FL$par[2],
                    intact=rxnrate_repair(FL$par,U)[[2]],
                    broken=rxnrate_repair(FL$par,U)[[1]],
                    maxBro = max(rxnrate_repair(FL$par,U)[[1]]),
                    peakBro =seq(0,max(time),0.1)[which.max(rxnrate_repair(FL$par,U)[[1]])],
                    mutant=rxnrate_repair(FL$par,U)[[3]],
                    residual_sq=sum(residuals^2));
  }
  
  
  
  
  return(listkinetc);
}
##################################################################################

##################################################################################
# ZLWB2fitDefault: fitting to total indels, a complete model for optimal values of kc kp and km, with all predictions stored and returned
##################################################################################

ZLWB2fitDefault = function(time,wt,indel, U=NA){
  
  t= seq(0,max(time*10))/10;
  
  ### cas9 fitting
  # Cas9 protein kinetics
  tWB = c(60,42,33,24,21,18,16,14,12,10,8,4,0)
  
  Cas9I = c(1.035116259,0.93119759,1.134895008,0.980514232,0.989879665,0.903886513,1.211372653,0.575621105,0.782199246,0.686693037,0.608119422,0.325573414,0.142920737)
  
 
  
  Cas9WIfit=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]

    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
    return(c(coI)-c(Cas9))
  }
  
  Cas9WISim=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]

    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
    return(list(coI))
  }
  
  parms = c(1,0.1);
  FL= modFit(f= Cas9WIfit,p=parms,lower=rep(0,length(parms)))
  becy = FL$par;

  
  # fitting untransfected
  x=time
  y=wt/100
  z=indel/100
  
  index = which(is.finite(x+y+z));
  
  x = x[index];
  y = y[index];
  z = z[index];
  
  fitmodel <- nls(y~(1-a/(1 + exp(-b * (x-c)))), start=list(a=25,b=1,c=1))
  U<-ifelse(is.na(U), 1-coef(fitmodel)[1], U)
  untransf=U
  
  listkinetc=list(NULL);
  
  WB1rxnrate=function(t,c,parms){
    
    # rate constant passed through a list called parms
    kc=parms[1]
    kp=parms[2]
    km=parms[3]
    
    b=becy[1];
    D=Inf;
    Dp=becy[2];
    
    # c is the concentration of species
    
    # derivatives dc/dt are computed below
    r=rep(0,length(c))
    r[1]=-kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp+kp*c["B"] #dcA/dt
    r[2]=kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp-(kp+km)*c["B"] #dcB/dt
    r[3]=km*c["B"] #dcC/dt
    
    # the computed derivatives are returned as a list
    # order of derivatives needs to be the same as the order of species in c
    return(list(r))
    
  }
  
  
  # function for fitting results
  WB1rxnrate_fit = function(parms){
    
    tmax = max(time); 
    
    kc=log(2)/parms[1];
    kp=log(2)/parms[2];
    km=log(2)/parms[3];
    
    b = becy[1];
    D=Inf;
    Dp=becy[2];
    
    out=ode(y=c(P=as.numeric(1-U),B=0,M=0),times=t,func=WB1rxnrate,parms=c(kc,kp,km))
    
    s=out[,2:4]; 
    
    P = s[(out[,1]) %in% x,1];
    M=  s[(out[,1]) %in% x,3];
    
    return(c((U+P)/(U+P+M)-y))
  }
  
  # function for repair results
  rxnrate_repair = function(parms,U){
    
    tmax = max(time); 
    
    kc=log(2)/parms[1];
    kp=log(2)/parms[2];
    km=log(2)/parms[3];
    
    b = becy[1];
    D=Inf;
    Dp=becy[2];
    
    out=ode(y=c(P=as.numeric(1-U),B=0,M=0),times=t,func=WB1rxnrate,parms=c(kc,kp,km))
    
    s=out[,2:4]; 
    
    P = s[(out[,1]) %in% x,1];
    M=  s[(out[,1]) %in% x,3];

    return(list(s[,2],(P+U)/(P+U+M),M/(P+U+M)))
  }
  
  
  # fitting
  
  df= data.frame(time=x, wt=y*100, indel=z*100)
  
  df[,1]=df[,1]-df[1,1]
  
  df[,2:3]=df[,2:3]/100
  
  t= seq(0,max(df[,1])*10)/10
  
  parms=c(8,8,8)
  
  FL= try(modFit(f=WB1rxnrate_fit,p=parms,lower=rep(0,length(parms))),silent=TRUE)
  
  if (length(FL)>1){
    residuals=resid (FL)
    
    listkinetc=list(perfectF = FL$par[3]/FL$par[2],
                    hlc = FL$par[1],
                    hlm = FL$par[3],
                    intact=rxnrate_repair(FL$par,U)[[2]],
                    broken=rxnrate_repair(FL$par,U)[[1]],
                    maxBro = max(rxnrate_repair(FL$par,U)[[1]]),
                    peakBro =seq(0,max(time),0.1)[which.max(rxnrate_repair(FL$par,U)[[1]])],
                    mutant=rxnrate_repair(FL$par,U)[[3]],
                    residual_sq=sum(residuals^2));
  }
  
  
  
  
  return(listkinetc);
}
##################################################################################

##################################################################################
# ZLWB2fit_Mutants: fitting to individual indels, sweeping 2^21 fold, with predictions from each sweeping all stored and returned
##################################################################################

ZLWB2fit_Mutants = function(time,wt,indel,PoverF=1,plus1,minus7, U=NA){
  
  # fitting untransfected
  x=time
  y=wt/100
  z=indel/100
  
  is1 = plus1/100;
  mn7 = minus7/100;
  
  index = which(is.finite(x+y+z));
  
  x = x[index];
  y = y[index];
  z = z[index];
  is1 =   is1[index];
  mn7=    mn7[index];
  
  fitmodel <- nls(y~(1-a/(1 + exp(-b * (x-c)))), start=list(a=25,b=1,c=1))
  U<-ifelse(is.na(U), 1-coef(fitmodel)[1], U)
  untransf=U
  
  t= seq(0,max(time*10))/10;
  
  ### cas9 fitting
  # Cas9 protein kinetics
  tWB = c(60,42,33,24,21,18,16,14,12,10,8,4,0)
  
  Cas9I = c(1.035116259,0.93119759,1.134895008,0.980514232,0.989879665,0.903886513,1.211372653,0.575621105,0.782199246,0.686693037,0.608119422,0.325573414,0.142920737)
  
 
  Cas9WIfit=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]

    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
     return(c(coI)-c(Cas9))
  }
  
  Cas9WISim=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]

    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
    return(list(coI))
  }
  
  parms = c(1,0.1);
  FL= modFit(f= Cas9WIfit,p=parms,lower=rep(0,length(parms)))
  becy = FL$par;
 
  
  listkinetc=rep(list(NULL),21);
  
  for (i in 1:21){
    perfect=2^11/2^i*PoverF;
    
    WB1rxnrate=function(t,c,parms){
      
      # rate constant passed through a list called parms
      kc=parms[1]
      kp=parms[2]*perfect
      km=parms[2]
      kplus1 = parms[3]
      kminus7 = parms[4]
      
      b=becy[1];
      D=Inf;
      Dp=becy[2];
      
      # c is the concentration of species
      
      # derivatives dc/dt are computed below
      r=rep(0,length(c))
      r[1]=-kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp+kp*c["B"] #dcA/dt
      r[2]=kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp-(kp+km)*c["B"] #dcB/dt
      r[3]=km*c["B"] #dcC/dt
      r[4]=kplus1*c["B"]#dcC/dt
      r[5]=kminus7*c["B"]
      
      # the computed derivatives are returned as a list
      # order of derivatives needs to be the same as the order of species in c
      return(list(r))
      
    }
    
    
    # function for fitting results
    WB1rxnrate_fit = function(parms){
      
      tmax = max(time); 
      
      kc=log(2)/parms[1];
      kp=log(2)/parms[2]/perfect;
      km=log(2)/parms[2];
      kplus1 = log(2)/parms[3]
      kminus7 = log(2)/parms[4]
      
      b = becy[1];
      D=Inf;
      Dp=becy[2];
      
      out=ode(y=c(P=as.numeric(1-U),B=0,M=0, PL1=0,  MN7=0),times=t,func=WB1rxnrate,parms=c(kc,km,kplus1,kminus7))
      
      s=out[,2:6]; 
      
      P = s[(out[,1]) %in% x,1];
      M=  s[(out[,1]) %in% x,3];
      PL1=  s[(out[,1]) %in% x,4];
      MN7=  s[(out[,1]) %in% x,5];
      
      return(c(M/(U+P+M)-df[,3],PL1/(U+P+M)-df[,4],MN7/(U+P+M)-df[,5]))
    }
    
    
    # function for repair results
    rxnrate_repair = function(parms,U){
      
      kc=log(2)/parms[1];
      kp=log(2)/parms[2]/perfect;
      km=log(2)/parms[2];
      kplus1 = log(2)/parms[3]
      kminus7 = log(2)/parms[4]
      
      out=ode(y=c(P=as.numeric(1-U),B=0,M=0, PL1=0,  MN7=0),times=t,func=WB1rxnrate,parms=c(kc,km,kplus1,kminus7))
      
      s=out[,2:6]; 
      
      P = s[(out[,1]) %in% x,1];
      M=  s[(out[,1]) %in% x,3];
      PL1=  s[(out[,1]) %in% x,4];
      MN7=  s[(out[,1]) %in% x,5];
      
      return(list(s[,2],(P+U)/(P+U+M),M/(P+U+M),PL1/(U+P+M),MN7/(U+P+M)))
    }
    
    # fitting
    
    df= data.frame(time=x, wt=y*100, indel=z*100, plus1=  is1*100, minus7=mn7*100)
    
    df[,1]=df[,1]-df[1,1]
    
    df[,2:5]=df[,2:5]/100
    
    t= seq(0,max(df[,1])*10)/10
    
    parms=c(8,8,8,8)
    
    FL= try(modFit(f=WB1rxnrate_fit,p=parms,lower=rep(0,length(parms))),silent=TRUE)
    
    if (length(FL)>1){
      residuals=resid (FL)
      
      listkinetc[[i]]=list(perfectF = perfect,
                           hlc = FL$par[1],
                           hlm = FL$par[2],
                           hlpl1 = FL$par[3],
                           hlmn7 = FL$par[4],
                           intact=rxnrate_repair(FL$par,U)[[2]],
                           broken=rxnrate_repair(FL$par,U)[[1]],
                           maxBro = max(rxnrate_repair(FL$par,U)[[1]]),
                           peakBro =seq(0,max(time),0.1)[which.max(rxnrate_repair(FL$par,U)[[1]])],
                           mutant=rxnrate_repair(FL$par,U)[[3]],
                           plus1=rxnrate_repair(FL$par,U)[[4]],
                           minus7=rxnrate_repair(FL$par,U)[[5]],
                           residual_sq=sum(residuals^2));
    }
    
  }
  
  listkinetc = listkinetc[!is.null(listkinetc)];
  
  return(listkinetc);
}
##################################################################################

##################################################################################
# ZLWB2fitPoverF_Mutants: fitting to individual indels, specifiying a perticular p/m factor that is log2 transformed, with all predictions stored and returned
##################################################################################

ZLWB2fitPoverF_Mutants = function(time,wt,indel,PoverF=1,plus1,minus7, U=NA){

  # fitting untransfected
  x=time
  y=wt/100
  z=indel/100
  
  is1 = plus1/100;
  mn7 = minus7/100;
  
  index = which(is.finite(x+y+z));
  
  x = x[index];
  y = y[index];
  z = z[index];
  is1 =   is1[index];
  mn7=    mn7[index];
  
  fitmodel <- nls(y~(1-a/(1 + exp(-b * (x-c)))), start=list(a=25,b=1,c=1))
  U<-ifelse(is.na(U), 1-coef(fitmodel)[1], U)
  untransf=U
  
  
  t= seq(0,max(time*10))/10;
  
  ### cas9 fitting
  # Cas9 protein kinetics
  tWB = c(60,42,33,24,21,18,16,14,12,10,8,4,0)
  
  Cas9I = c(1.035116259,0.93119759,1.134895008,0.980514232,0.989879665,0.903886513,1.211372653,0.575621105,0.782199246,0.686693037,0.608119422,0.325573414,0.142920737)
  
 
  
  Cas9WIfit=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]

    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
    return(c(coI)-c(Cas9))
  }
  
  Cas9WISim=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]

    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
    return(list(coI))
  }
  
  parms = c(1,0.1);
  FL= modFit(f= Cas9WIfit,p=parms,lower=rep(0,length(parms)))
  becy = FL$par;
  
  
  listkinetc=list(NULL);
  
  perfect=2^PoverF;
  
  WB1rxnrate=function(t,c,parms){
    
    # rate constant passed through a list called parms
    kc=parms[1]
    kp=parms[2]*perfect
    km=parms[2]
    kplus1 = parms[3]
    kminus7 = parms[4]
    
    b = becy[1];
    D=Inf;
    Dp=becy[2];
    
    # c is the concentration of species
    
    # derivatives dc/dt are computed below
    r=rep(0,length(c))
    r[1]=-kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp+kp*c["B"] #dcA/dt
    r[2]=kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp-(kp+km)*c["B"] #dcB/dt
    r[3]=km*c["B"] #dcC/dt
    r[4]=kplus1*c["B"]#dcC/dt
    r[5]=kminus7*c["B"]
    
    # the computed derivatives are returned as a list
    # order of derivatives needs to be the same as the order of species in c
    return(list(r))
    
  }

  
  # function for fitting results
  WB1rxnrate_fit = function(parms){
    
    tmax = max(time); 
    
    kc=log(2)/parms[1];
    kp=log(2)/parms[2]/perfect;
    km=log(2)/parms[2];
    kplus1 = log(2)/parms[3]
    kminus7 = log(2)/parms[4]
    
    b = becy[1];
    D=Inf;
    Dp=becy[2];
    
    out=ode(y=c(P=as.numeric(1-U),B=0,M=0, PL1=0,  MN7=0),times=t,func=WB1rxnrate,parms=c(kc,km,kplus1,kminus7))
    
    s=out[,2:6]; 
    
    P = s[(out[,1]) %in% x,1];
    M=  s[(out[,1]) %in% x,3];
    PL1=  s[(out[,1]) %in% x,4];
    MN7=  s[(out[,1]) %in% x,5];
    
    return(c(M/(U+P+M)-df[,3],PL1/(U+P+M)-df[,4],MN7/(U+P+M)-df[,5]))
  }
  
  
  # function for repair results
  rxnrate_repair = function(parms,U){
    
    kc=log(2)/parms[1];
    kp=log(2)/parms[2]/perfect;
    km=log(2)/parms[2];
    kplus1 = log(2)/parms[3]
    kminus7 = log(2)/parms[4]
    
    out=ode(y=c(P=as.numeric(1-U),B=0,M=0, PL1=0,  MN7=0),times=t,func=WB1rxnrate,parms=c(kc,km,kplus1,kminus7))
    
    s=out[,2:6]; 
    
    P = s[(out[,1]) %in% x,1];
    M=  s[(out[,1]) %in% x,3];
    PL1=  s[(out[,1]) %in% x,4];
    MN7=  s[(out[,1]) %in% x,5];
    
    return(list(s[,2],(P+U)/(P+U+M),M/(P+U+M),PL1/(U+P+M),MN7/(U+P+M)))
  }
  
  # fitting
  
  df= data.frame(time=x, wt=y*100, indel=z*100, plus1=  is1*100, minus7=mn7*100)
  
  df[,1]=df[,1]-df[1,1]
  
  df[,2:5]=df[,2:5]/100
  
  t= seq(0,max(df[,1])*10)/10
  
  parms=c(8,8,8,8)
  
  FL= try(modFit(f=WB1rxnrate_fit,p=parms,lower=rep(0,length(parms))),silent=TRUE)
  
  if (length(FL)>1){
    residuals=resid (FL)
    
    listkinetc=list(perfectF = perfect,
                    hlc = FL$par[1],
                    hlm = FL$par[2],
                    hlpl1 = FL$par[3],
                    hlmn7 = FL$par[4],
                    intact=rxnrate_repair(FL$par,U)[[2]],
                    broken=rxnrate_repair(FL$par,U)[[1]],
                    maxBro = max(rxnrate_repair(FL$par,U)[[1]]),
                    peakBro =seq(0,max(time),0.1)[which.max(rxnrate_repair(FL$par,U)[[1]])],
                    mutant=rxnrate_repair(FL$par,U)[[3]],
                    plus1=rxnrate_repair(FL$par,U)[[4]],
                    minus7=rxnrate_repair(FL$par,U)[[5]],
                    residual_sq=sum(residuals^2));
  }
  
  
  
  
  return(listkinetc);
}
##################################################################################

##################################################################################
# ZLWB2fit_MutantsDefault: fitting to individual indels, a complete model for optimal values of kc kp and km, kplus1 and kminus7, with all predictions stored and returned
##################################################################################

ZLWB2fit_MutantsDefault = function(time,wt,indel,plus1,minus7, U=NA){
  
  # fitting untransfected
  x=time
  y=wt/100
  z=indel/100
  
  is1 = plus1/100;
  mn7 = minus7/100;
  
  index = which(is.finite(x+y+z));
  
  x = x[index];
  y = y[index];
  z = z[index];
  is1 =   is1[index];
  mn7=    mn7[index];
  
  fitmodel <- nls(y~(1-a/(1 + exp(-b * (x-c)))), start=list(a=25,b=1,c=1))
  U<-ifelse(is.na(U), 1-coef(fitmodel)[1], U)
  untransf=U
  
  
  t= seq(0,max(time*10))/10;
  
  ### cas9 fitting
  # Cas9 protein kinetics
  tWB = c(60,42,33,24,21,18,16,14,12,10,8,4,0)
  
  Cas9I = c(1.035116259,0.93119759,1.134895008,0.980514232,0.989879665,0.903886513,1.211372653,0.575621105,0.782199246,0.686693037,0.608119422,0.325573414,0.142920737)
  
 
  Cas9WIfit=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]

    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
     return(c(coI)-c(Cas9))
  }
  
  Cas9WISim=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]

    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
    return(list(coI))
  }
  
  parms = c(1,0.1);
  FL= modFit(f= Cas9WIfit,p=parms,lower=rep(0,length(parms)))
  becy = FL$par;
  
  listkinetc=list(NULL);

  
  WB1rxnrate=function(t,c,parms){
    
    # rate constant passed through a list called parms
    kc=parms[1]
    kp=parms[5]
    km=parms[2]
    kplus1 = parms[3]
    kminus7 = parms[4]
    
    b=becy[1];
    D=Inf;
    Dp=becy[2];
    
    # c is the concentration of species
    
    # derivatives dc/dt are computed below
    r=rep(0,length(c))
    r[1]=-kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp+kp*c["B"] #dcA/dt
    r[2]=kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp-(kp+km)*c["B"] #dcB/dt
    r[3]=km*c["B"] #dcC/dt
    r[4]=kplus1*c["B"]#dcC/dt
    r[5]=kminus7*c["B"]
    
    # the computed derivatives are returned as a list
    # order of derivatives needs to be the same as the order of species in c
    return(list(r))
    
  }
  
  
  # function for fitting results
  WB1rxnrate_fit = function(parms){
    
    tmax = max(time); 
    
    kc=log(2)/parms[1];
    kp=log(2)/parms[5];
    km=log(2)/parms[2];
    kplus1 = log(2)/parms[3]
    kminus7 = log(2)/parms[4]
    
    b = becy[1];
    D=Inf;
    Dp=becy[2];
    
    out=ode(y=c(P=as.numeric(1-U),B=0,M=0, PL1=0,  MN7=0),times=t,func=WB1rxnrate,parms=c(kc,km,kplus1,kminus7,kp))
    
    s=out[,2:6]; 
    
    P = s[(out[,1]) %in% x,1];
    M=  s[(out[,1]) %in% x,3];
    PL1=  s[(out[,1]) %in% x,4];
    MN7=  s[(out[,1]) %in% x,5];
    
    return(c(M/(U+P+M)-df[,3],PL1/(U+P+M)-df[,4],MN7/(U+P+M)-df[,5]))
  }
  
  
  # function for repair results
  rxnrate_repair = function(parms,U){
    
    kc=log(2)/parms[1];
    kp=log(2)/parms[5];
    km=log(2)/parms[2];
    kplus1 = log(2)/parms[3]
    kminus7 = log(2)/parms[4]
    
    out=ode(y=c(P=as.numeric(1-U),B=0,M=0, PL1=0,  MN7=0),times=t,func=WB1rxnrate,parms=c(kc,km,kplus1,kminus7,kp))
    
    s=out[,2:6]; 
    
    P = s[(out[,1]) %in% x,1];
    M=  s[(out[,1]) %in% x,3];
    PL1=  s[(out[,1]) %in% x,4];
    MN7=  s[(out[,1]) %in% x,5];
    
    return(list(s[,2],(P+U)/(P+U+M),M/(P+U+M),PL1/(U+P+M),MN7/(U+P+M)))
  }
  
  
  # fitting
  
  df= data.frame(time=x, wt=y*100, indel=z*100, plus1=  is1*100, minus7=mn7*100)
  
  df[,1]=df[,1]-df[1,1]
  
  df[,2:5]=df[,2:5]/100
  
  t= seq(0,max(df[,1])*10)/10
  
  parms=c(8,8,8,8,8)
  
  FL= try(modFit(f=  WB1rxnrate_fit,p=parms,lower=rep(0,length(parms))),silent=TRUE)
  
  if (length(FL)>1){
    residuals=resid (FL)
    
    listkinetc=list(  perfectF = FL$par[2]/FL$par[5],
                      hlc = FL$par[1],
                      hlm = FL$par[2],
                      hlpl1 = FL$par[3],
                      hlmn7 = FL$par[4],
                      intact=rxnrate_repair(FL$par,U)[[2]],
                      broken=rxnrate_repair(FL$par,U)[[1]],
                      maxBro = max(rxnrate_repair(FL$par,U)[[1]]),
                      peakBro =seq(0,max(time),0.1)[which.max(rxnrate_repair(FL$par,U)[[1]])],
                      mutant=rxnrate_repair(FL$par,U)[[3]],
                      plus1=rxnrate_repair(FL$par,U)[[4]],
                      minus7=rxnrate_repair(FL$par,U)[[5]],
                      residual_sq=sum(residuals^2));
  }
  
  
  return(listkinetc);
}
##################################################################################

##################################################################################
# ZLWB2PiledupOM: fitting to individual indels pipled up with all specified data serieses, a complete model for optimal values of kc km and kp, kplus1 and kminus7, with modelling results returned
##################################################################################

ZLWB2PiledupOM = function(time,wt,indel,plus1,minus7, U=NA){
    
  t= seq(0,max(time*10))/10;
  
  ### cas9 fitting
  # Cas9 protein kinetics
  tWB = c(60,42,33,24,21,18,16,14,12,10,8,4,0)
  
  Cas9I = c(1.035116259,0.93119759,1.134895008,0.980514232,0.989879665,0.903886513,1.211372653,0.575621105,0.782199246,0.686693037,0.608119422,0.325573414,0.142920737)
  
 
  Cas9WIfit=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]

        Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
    return(c(coI)-c(Cas9))
  }
  
  Cas9WISim=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]

    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
     return(list(coI))
  }
  
  parms = c(1,0.1);
  FL= modFit(f= Cas9WIfit,p=parms,lower=rep(0,length(parms)))
  becy = FL$par;
 
  
  t= seq(0,max(time*10))/10;
  
  
  WB1rxnrate=function(t,c,parms){
    
    # rate constant passed through a list called parms
    kc=parms[1]
    kp=parms[5]
    km=parms[2]
    kplus1 = parms[3]
    kminus7 = parms[4]
    
    b=becy[1];
    D=Inf;
    Dp=becy[2];
    
    # c is the concentration of species
    
    # derivatives dc/dt are computed below
    r=rep(0,length(c))
    r[1]=-kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp+kp*c["B"] #dcA/dt
    r[2]=kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp-(kp+km)*c["B"] #dcB/dt
    r[3]=km*c["B"] #dcC/dt
    r[4]=kplus1*c["B"]#dcC/dt
    r[5]=kminus7*c["B"]
    
    # the computed derivatives are returned as a list
    # order of derivatives needs to be the same as the order of species in c
    return(list(r))
    
  }
  
  # function for fitting results
  WB1rxnrate_fit = function(parms){
    
    res = rep(list(NULL),ncol(wt));
    
    for (i in 1:length(res)){
      # fitting untransfected
      x=time
      y=wt[,i]/100
      z=indel[,i]/100
      
      is1 = plus1[,i]/100;
      mn7 = minus7[,i]/100;
      
      index = which(is.finite(x+y+z));
      
      x = x[index];
      y = y[index];
      z = z[index];
      is1 =   is1[index];
      mn7=    mn7[index];
      
      fitmodel <- nls(y~(1-a/(1 + exp(-b * (x-c)))), start=list(a=25,b=1,c=1))
      U<-ifelse(is.na(U), 1-coef(fitmodel)[1], U)
      untransf=U;

      
      tmax = max(time); 
      
      kc=log(2)/parms[1];
      kp=log(2)/parms[5]
      km=log(2)/parms[2];
      kplus1 = log(2)/parms[3]
      kminus7 = log(2)/parms[4]
      
      out=ode(y=c(P=as.numeric(1-U),B=0,M=0, PL1=0,  MN7=0),times=t,func=  WB1rxnrate
              ,parms=c(kc,km,kplus1,kminus7,kp))
      
      s=out[,2:6]; 
      
      P = s[(out[,1]) %in% x,1];
      M=  s[(out[,1]) %in% x,3];
      PL1=  s[(out[,1]) %in% x,4];
      MN7=  s[(out[,1]) %in% x,5];
      
      res[[i]] =c(M/(U+P+M)-z,PL1/(U+P+M)-is1,MN7/(U+P+M)-mn7)
    }
    
    return(unlist(res))
    
  }
  
  parms=c(8,8,8,8,8)
  
  FL= try(modFit(f= WB1rxnrate_fit,p=parms,lower=rep(0,length(parms))),silent=TRUE)
  
  
  
  
  return(FL);
}
##################################################################################

##################################################################################
# ZLWB2PiledupSweep: fitting to individual indels pipled up with all specified data serieses, specifiying a perticular p/m factor, with modelling results returned
##################################################################################

ZLWB2PiledupSweep = function(time,wt,indel,plus1,minus7, U=NA){
  
  t= seq(0,max(time*10))/10;
  
  ### cas9 fitting
  # Cas9 protein kinetics
  tWB = c(60,42,33,24,21,18,16,14,12,10,8,4,0)
  
  Cas9I = c(1.035116259,0.93119759,1.134895008,0.980514232,0.989879665,0.903886513,1.211372653,0.575621105,0.782199246,0.686693037,0.608119422,0.325573414,0.142920737)
  
  Cas9WIfit=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]

    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
     return(c(coI)-c(Cas9))
  }
  
  Cas9WISim=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]

    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
    return(list(coI))
  }
  
  parms = c(1,0.1);
  FL= modFit(f= Cas9WIfit,p=parms,lower=rep(0,length(parms)))
  becy = FL$par;
 
  
  t= seq(0,max(time*10))/10;
  
  
  WB1rxnrate=function(t,c,parms){
    
    # rate constant passed through a list called parms
    kc=parms[1]
    kp=parms[2]*sweep
    km=parms[2]
    kplus1 = parms[3]
    kminus7 = parms[4]
    
    b=becy[1];
    D=Inf;
    Dp=becy[2];
    
    # c is the concentration of species
    
    # derivatives dc/dt are computed below
    r=rep(0,length(c))
    r[1]=-kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp+kp*c["B"] #dcA/dt
    r[2]=kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp-(kp+km)*c["B"] #dcB/dt
    r[3]=km*c["B"] #dcC/dt
    r[4]=kplus1*c["B"]#dcC/dt
    r[5]=kminus7*c["B"]
    
    # the computed derivatives are returned as a list
    # order of derivatives needs to be the same as the order of species in c
    return(list(r))
    
  }
  
  # function for fitting results
  WB1rxnrate_fit = function(parms){
    
    res = rep(list(NULL),ncol(wt));
    
    for (i in 1:length(res)){
      # fitting untransfected
      x=time
      y=wt[,i]/100
      z=indel[,i]/100
      
      is1 = plus1[,i]/100;
      mn7 = minus7[,i]/100;
      
      index = which(is.finite(x+y+z));
      
      x = x[index];
      y = y[index];
      z = z[index];
      is1 =   is1[index];
      mn7=    mn7[index];
      
      fitmodel <- nls(y~(1-a/(1 + exp(-b * (x-c)))), start=list(a=25,b=1,c=1))
      U<-ifelse(is.na(U), 1-coef(fitmodel)[1], U)
      untransf=U;

      
      tmax = max(time); 
      
      
      kc=log(2)/(parms[1])
      kp=log(2)/(parms[2]*sweep)
      km=log(2)/(parms[2])
      kplus1 = log(2)/(parms[3])
      kminus7 = log(2)/(parms[4])
      
      
      out=ode(y=c(P=as.numeric(1-U),B=0,M=0, PL1=0,  MN7=0),times=t,func=  WB1rxnrate
              ,parms=c(kc,km,kplus1,kminus7,kp))
      
      s=out[,2:6]; 
      
      P = s[(out[,1]) %in% x,1];
      M=  s[(out[,1]) %in% x,3];
      PL1=  s[(out[,1]) %in% x,4];
      MN7=  s[(out[,1]) %in% x,5];
      
 
      res[[i]] =c(M/(U+P+M)-z,PL1/(U+P+M)-is1,MN7/(U+P+M)-mn7)
    }
    
    return(unlist(res))
    
  }
  
  
  parms=c(8,8,8,8)
  
  FL= try(modFit(f=WB1rxnrate_fit,p=parms,lower=rep(0,length(parms))),silent=TRUE);
  
  return(list(perfectF = sweep,
              hlc = round(FL$par[1],1),
              hlm = round(FL$par[2],1),
              hlpl1 = round(FL$par[3],1),
              hlmn7 = round(FL$par[4],1),
              residual_sq=sum(resid(FL)^2)));
  
}


#######################################################################
# ZLWB2PiledupOMMerge: fitting to total mutations pipled up with all specified data serieses, a complete model for optimal values of kc kp and km, with modelling results returned, including peakBro
#######################################################################

ZLWB2PiledupOMMerge = function(time,wt,indel){
  
  t= seq(0,max(time*10))/10;
  
  ### cas9 fitting
  # Cas9 protein kinetics
  tWB = c(60,42,33,24,21,18,16,14,12,10,8,4,0)
  
  Cas9I = c(1.035116259,0.93119759,1.134895008,0.980514232,0.989879665,0.903886513, 1.211372653,0.575621105,0.782199246,0.686693037,0.608119422,0.325573414,0.142920737)
  
  Cas9WIfit=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]

    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
    return(c(coI)-c(Cas9))
  }
  
  Cas9WISim=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]
    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
     return(list(coI))
  }
  
  parms = c(1,0.1);
  FL= modFit(f= Cas9WIfit,p=parms,lower=rep(0,length(parms)))
  becy = FL$par;
  #####
  

  WB1rxnrate=function(t,c,parms){
    
    # rate constant passed through a list called parms
    kc=parms[1]
    kp=parms[2]
    km=parms[3]

    
    b = becy[1];
    D=Inf;
    Dp=becy[2];
    
    # c is the concentration of species
    
    # derivatives dc/dt are computed below
    r=rep(0,length(c))
    r[1]=-kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp+kp*c["B"] #dcA/dt
    r[2]=kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp-(kp+km)*c["B"] #dcB/dt
    r[3]=km*c["B"] #dcC/dt
    # the computed derivatives are returned as a list
    # order of derivatives needs to be the same as the order of species in c
    return(list(r))
    
  }
  
  
  # function for fitting results
  WB1rxnrate_fit = function(parms){
    
    res = rep(list(NULL),ncol(wt));
    
    for (i in 1:length(res)){
      # fitting untransfected
      x=time
      y=wt[,i]/100
      z=indel[,i]/100
      
      index = which(is.finite(x+y+z));
      
      x = x[index];
      y = y[index];
      z = z[index];
      
      fitmodel <- nls(y~(1-a/(1 + exp(-b * (x-c)))), start=list(a=25,b=1,c=1))
      U = 1-coef(fitmodel)[1]
      untransf=U;
      
      
      
      tmax = max(time); 
      
      kc=log(2)/parms[1];
      kp=log(2)/parms[2]
      km=log(2)/parms[3];
      
      out=ode(y=c(P=as.numeric(1-U),B=0,M=0),times=t,func=  WB1rxnrate,parms=c(kc,kp,km))
      
      s=out[,2:4]; 
      
      P = s[(out[,1]) %in% x,1];
      M=  s[(out[,1]) %in% x,3];
      
      res[[i]] =c(M/(U+P+M)-z)
    }
    
    return(unlist(res))
    
  }
  
  parms=c(8,8,8)
  
  FL= try(modFit(f=  WB1rxnrate_fit,p=parms,lower=rep(0,length(parms))),silent=TRUE)
  out=ode(y=c(P=1,B=0,M=0),times=t,func=  WB1rxnrate,parms=log(2)/FL$par)
  
  return(list(FL,peakBro=out[which.max(out[,3]),1]));
}

######################################################################## 
#ZLWB2PiledupSweepMerge: fitting to total mutations pipled up with all specified data serieses, specifiying a perticular p/m factor, with modelling results returned,including peakBro
#######################################################################

ZLWB2PiledupSweepMerge = function(time,wt,indel){
  
  t= seq(0,max(time*10))/10;
  
  ### cas9 fitting
  # Cas9 protein kinetics
  tWB = c(60,42,33,24,21,18,16,14,12,10,8,4,0)
  
  Cas9I = c(1.035116259,0.93119759,1.134895008,0.980514232,0.989879665,0.903886513, 1.211372653,0.575621105,0.782199246,0.686693037,0.608119422,0.325573414,0.142920737)
  
   Cas9WIfit=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]
      Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
     return(c(coI)-c(Cas9))
  }
  
  Cas9WISim=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]
       Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
      return(list(coI))
  }
  
  parms = c(1,0.1);
  FL= modFit(f= Cas9WIfit,p=parms,lower=rep(0,length(parms)))
  becy = FL$par;
  #####
  
  
  WB1rxnrate=function(t,c,parms){
    
    # rate constant passed through a list called parms
    kc=parms[1]
    kp=parms[2]*sweep
    km=parms[2]
    
    
    b = becy[1];
    D=Inf;
    Dp=becy[2];
    
    # c is the concentration of species
    
    # derivatives dc/dt are computed below
    r=rep(0,length(c))
    r[1]=-kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp+kp*c["B"] #dcA/dt
    r[2]=kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp-(kp+km)*c["B"] #dcB/dt
    r[3]=km*c["B"] #dcC/dt
    # the computed derivatives are returned as a list
    # order of derivatives needs to be the same as the order of species in c
    return(list(r))
    
  }
  
  # function for fitting results
  WB1rxnrate_fit = function(parms){
    
    res = rep(list(NULL),ncol(wt));
    
    for (i in 1:length(res)){
      # fitting untransfected
      x=time
      y=wt[,i]/100
      z=indel[,i]/100
      
      index = which(is.finite(x+y+z));
      
      x = x[index];
      y = y[index];
      z = z[index];
      
      fitmodel <- nls(y~(1-a/(1 + exp(-b * (x-c)))), start=list(a=25,b=1,c=1))
      U = 1-coef(fitmodel)[1]
      untransf=U;
      
      
      
      tmax = max(time); 
      
      kc=log(2)/parms[1];
      kp=log(2)/(parms[2]*sweep)
      km=log(2)/parms[2];
      
      out=ode(y=c(P=as.numeric(1-U),B=0,M=0),times=t,func=  WB1rxnrate,parms=c(kc,km))
      
      s=out[,2:4]; 
      
      P = s[(out[,1]) %in% x,1];
      M=  s[(out[,1]) %in% x,3];
      
      res[[i]] =c(M/(U+P+M)-z)
    }
    
    return(unlist(res))
    
  }
  
  t= seq(0,max(time)*10)/10
  
  parms=c(8,8)
  
  FL= try(modFit(f=WB1rxnrate_fit,p=parms,lower=rep(0,length(parms))),silent=TRUE);
  out=ode(y=c(P=1,B=0,M=0),times=t,func=  WB1rxnrate,parms= c(log(2)/FL$par));

  
  return(list(perfectF = sweep,
              hlc = FL$par[1],
              hlm = FL$par[2],
              residual_sq=sum(resid(FL)^2),
              peakBro=out[which.max(out[,3]),1],
              maxBro=max(out[,3]),
              stdErr = summary(FL)[[11]][,2])
         );
  
}

##################################################################################
#ZLWB2hlcPiledupSweepMerge
##################################################################################

ZLWB2hlcPiledupSweepMerge = function(time,wt,indel){
  
  t= seq(0,max(time*10))/10;
  
  ### cas9 fitting
  # Cas9 protein kinetics
  tWB = c(60,42,33,24,21,18,16,14,12,10,8,4,0)
  
  Cas9I = c(1.035116259,0.93119759,1.134895008,0.980514232,0.989879665,0.903886513, 1.211372653,0.575621105,0.782199246,0.686693037,0.608119422,0.325573414,0.142920737)
  
   Cas9WIfit=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]
    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
    return(c(coI)-c(Cas9))
  }
  
  Cas9WISim=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]
    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
     return(list(coI))
  }
  
  parms = c(1,0.1);
  FL= modFit(f= Cas9WIfit,p=parms,lower=rep(0,length(parms)))
  becy = FL$par;
  #####
  
  
  WB1rxnrate=function(t,c,parms){
    
    # rate constant passed through a list called parms
    kc=log(2)/sweep
    kp=parms[1]
    km=parms[2]
    
    
    b = becy[1];
    D=Inf;
    Dp=becy[2];
    
    # c is the concentration of species
    
    # derivatives dc/dt are computed below
    r=rep(0,length(c))
    r[1]=-kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp+kp*c["B"] #dcA/dt
    r[2]=kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp-(kp+km)*c["B"] #dcB/dt
    r[3]=km*c["B"] #dcC/dt
    # the computed derivatives are returned as a list
    # order of derivatives needs to be the same as the order of species in c
    return(list(r))
    
  }
  
  # function for fitting results
  WB1rxnrate_fit = function(parms){
    
    res = rep(list(NULL),ncol(wt));
    
    for (i in 1:length(res)){
      # fitting untransfected
      x=time
      y=wt[,i]/100
      z=indel[,i]/100
      
      index = which(is.finite(x+y+z));
      
      x = x[index];
      y = y[index];
      z = z[index];
      
      fitmodel <- nls(y~(1-a/(1 + exp(-b * (x-c)))), start=list(a=25,b=1,c=1))
      U = 1-coef(fitmodel)[1]
      untransf=U;
      
      
      
      tmax = max(time); 
      
      kc=log(2)/sweep;
      kp=log(2)/parms[1]
      km=log(2)/parms[2];
      
      out=ode(y=c(P=as.numeric(1-U),B=0,M=0),times=t,func=  WB1rxnrate,parms=c(kp,km))
      
      s=out[,2:4]; 
      
      P = s[(out[,1]) %in% x,1];
      M=  s[(out[,1]) %in% x,3];
      
      res[[i]] =c(M/(U+P+M)-z)
    }
    
    return(unlist(res))
    
  }
  
  t= seq(0,max(time)*10)/10
  
  parms=c(8,8)
  
  FL= try(modFit(f=WB1rxnrate_fit,p=parms,lower=rep(0,length(parms))),silent=TRUE);
  out=ode(y=c(P=1,B=0,M=0),times=t,func=  WB1rxnrate,parms= c(log(2)/FL$par));
  
  
  return(list(hlc = log(2)/sweep,
              hlp= round(FL$par[1],1),
              hlm = round(FL$par[2],1),
              residual_sq=sum(resid(FL)^2),
              peakBro=out[which.max(out[,3]),1],
              maxBro = max(out[,3]))
  );
  
}


##################################################################################
# function all-time-point fitting
##################################################################################

ZLWB2fitDefaultAllTP = function(DF, U=NA){
  
  time = DF$time;
  wt = DF$wt;
  indel = DF$mut;
  
  t= seq(0,max(time*10))/10;
  
  ### cas9 fitting
  # Cas9 protein kinetics
  tWB = c(60,42,33,24,21,18,16,14,12,10,8,4,0)
  
  Cas9I = c(1.035116259,0.93119759,1.134895008,0.980514232,0.989879665,0.903886513,1.211372653,0.575621105,0.782199246,0.686693037,0.608119422,0.325573414,0.142920737)
  
  
  
  Cas9WIfit=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]
    
    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
    return(c(coI)-c(Cas9))
  }
  
  Cas9WISim=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]
    
    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
    return(list(coI))
  }
  
  parms = c(1,0.1);
  FL= modFit(f= Cas9WIfit,p=parms,lower=rep(0,length(parms)))
  becy = FL$par;
  
  
  # fitting untransfected
  x=time
  y=wt/100
  z=indel/100
  
  index = which(is.finite(x+y+z));
  
  x = x[index];
  y = y[index];
  z = z[index];
  
  untransf=U
  
  listkinetc=list(NULL);
  
  WB1rxnrate=function(t,c,parms){
    
    # rate constant passed through a list called parms
    kc=parms[1]
    kp=parms[2]
    km=parms[3]
    
    b=becy[1];
    D=Inf;
    Dp=becy[2];
    
    # c is the concentration of species
    
    # derivatives dc/dt are computed below
    r=rep(0,length(c))
    r[1]=-kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp+kp*c["B"] #dcA/dt
    r[2]=kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp-(kp+km)*c["B"] #dcB/dt
    r[3]=km*c["B"] #dcC/dt
    
    # the computed derivatives are returned as a list
    # order of derivatives needs to be the same as the order of species in c
    return(list(r))
    
  }
  
  
  # function for fitting results
  WB1rxnrate_fit = function(parms){
    
    tmax = max(time); 
    
    kc=log(2)/parms[1];
    kp=log(2)/parms[2];
    km=log(2)/parms[3];
    
    b = becy[1];
    D=Inf;
    Dp=becy[2];
    
    out=ode(y=c(P=as.numeric(1-U),B=0,M=0),times=t,func=WB1rxnrate,parms=c(kc,kp,km))
    
    s=out[,2:4]; 
    
    P = s[(out[,1]) %in% x,1];
    M=  s[(out[,1]) %in% x,3];
    
    P = P[DF[,4]];
    M = M[DF[,4]];
    
    return(c((U+P)/(U+P+M)-df[,2]))
  }
  
  # function for repair results
  rxnrate_repair = function(parms,U){
    
    tmax = max(time); 
    
    kc=log(2)/parms[1];
    kp=log(2)/parms[2];
    km=log(2)/parms[3];
    
    b = becy[1];
    D=Inf;
    Dp=becy[2];
    
    out=ode(y=c(P=as.numeric(1-U),B=0,M=0),times=t,func=WB1rxnrate,parms=c(kc,kp,km))
    
    s=out[,2:4]; 
    
    P = s[,1];
    M=  s[,3];
    
    return(list(s[,2],(P+U)/(P+U+M),M/(P+U+M)))
  }
  
  
  # fitting
  
  df= data.frame(time=x, wt=y*100, indel=z*100)
 
  df[,2:3]=df[,2:3]/100
  
  t= seq(0,max(df[,1])*10)/10
  
  parms=c(8,8,8)
  
  FL= try(modFit(f=WB1rxnrate_fit,p=parms,lower=rep(0,length(parms))),silent=TRUE)
  
  if (length(FL)>1){
    residuals=resid (FL)
    
    listkinetc=list(perfectF = FL$par[3]/FL$par[2],
                    time = DF[,1],
                    hlc = FL$par[1],
                    hlm = FL$par[3],
                    intact=rxnrate_repair(FL$par,U)[[2]],
                    broken=rxnrate_repair(FL$par,U)[[1]],
                    maxBro = max(rxnrate_repair(FL$par,U)[[1]]),
                    peakBro =seq(0,max(time),0.1)[which.max(rxnrate_repair(FL$par,U)[[1]])],
                    mutant=rxnrate_repair(FL$par,U)[[3]],
                    residual_sq=sum(residuals^2),
                    Untf=U);
  }
  
  
  
  
  return(listkinetc);
}


##################################################################################
# UntransfectedFitting: fitting sigmod curve to obtain the untransfected fraction, returning sigmoid factors
##################################################################################

UntransfectedFitting = function(time,wt,indel){
 # fitting untransfected
      x=time
      y=wt/100
      z=indel/100
      
      index = which(is.finite(x+y+z));
      
      x = x[index];
      y = y[index];
      z = z[index];
      
      fitmodel <- nls(y~(1-a/(1 + exp(-b * (x-c)))), start=list(a=25,b=1,c=1))
      
      return(coef(fitmodel))
}
##################################################################################

```

<h2>Import data of timeseries</h2>

```{r loading data}

# loading data
wildtype_tot_LBR2 <- read.delim("wildtype_tot_LBR2.txt", stringsAsFactors=FALSE);
mutations_tot_LBR2 <- read.delim("mutations_tot_LBR2.txt", stringsAsFactors=FALSE)
wildtype_tot_LBR2 = wildtype_tot_LBR2[-nrow(wildtype_tot_LBR2),];
mutations_tot_LBR2 = mutations_tot_LBR2[-nrow(mutations_tot_LBR2),];

wildtype_tot_LBR8 <- read.delim("wildtype_tot_LBR8.txt", stringsAsFactors=FALSE);
mutations_tot_LBR8 <- read.delim("mutations_tot_LBR8.txt", stringsAsFactors=FALSE)
wildtype_tot_LBR8 = wildtype_tot_LBR8[-nrow(wildtype_tot_LBR8),];
mutations_tot_LBR8 = mutations_tot_LBR8[-nrow(mutations_tot_LBR8),];

wildtype_tot_AAVS1 <- read.delim("wildtype_tot_AAVS1.txt", stringsAsFactors=FALSE);
mutations_tot_AAVS1 <- read.delim("mutations_tot_AAVS1.txt", stringsAsFactors=FALSE)
wildtype_tot_AAVS1 = wildtype_tot_AAVS1[-nrow(wildtype_tot_AAVS1),];
mutations_tot_AAVS1 = mutations_tot_AAVS1[-nrow(mutations_tot_AAVS1),];

wildtype_tot_chr11 <- read.delim("wildtype_tot_chr11.txt", stringsAsFactors=FALSE);
mutations_tot_chr11 <- read.delim("mutations_tot_chr11.txt", stringsAsFactors=FALSE)
wildtype_tot_chr11 = wildtype_tot_chr11[-nrow(wildtype_tot_chr11),];
mutations_tot_chr11 = mutations_tot_chr11[-nrow(mutations_tot_chr11),];

#without inhibitor
wt_1=wildtype_tot_LBR2[,-c(4,6,8,10,12)]
indel_1=mutations_tot_LBR2[,-c(4,6,8,10,12)]
wt_LBR8=wildtype_tot_LBR8
indel_LBR8=mutations_tot_LBR8
wt_AAVS1=wildtype_tot_AAVS1
indel_AAVS1=mutations_tot_AAVS1
wt_chr11=wildtype_tot_chr11
indel_chr11=mutations_tot_chr11

#with inhibitor
wt_2=wildtype_tot_LBR2[,c(4,6,8,10)]
indel_2=mutations_tot_LBR2[,c(4,6,8,10)]

# extract time point information
time = as.numeric(row.names(wildtype_tot_LBR2));

```

<h2>Modeling individual series for total indels</h2>
<p>Apply function ZLWB2fitDefault to individual series, spliting into without and with NU7441 inhibitor</p>

```{r ODE model fit}

# fitting for noinhibitor

U =NA
R_sq=NA

kcmax=kp=km=NA

noinhibitor_total_individual_series = rep(list(NULL),ncol(wt_1));
for (i in 1:ncol(wt_1)){
  noinhibitor_total_individual_series[[i]]=ZLWB2fitDefault(time,wt_1[,i],indel_1[,i])#, U=FACS_m);
  AA = UntransfectedFitting(time,wt_1[,i],indel_1[,i]);
  U[i]= 1-AA[1]
  
  # data
  plot(time,wt_1[,i],main=paste(colnames(wt_1)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='intact/(intact+mutated) (%)',xlab='time (h)');
  
  # untransfected
  plot(time,wt_1[,i],main=paste('w/o NU7441:',colnames(wt_1)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='intact/(intact+mutated) (%)',xlab='time (h)');
  lines(seq(0,60,0.01),(1-AA[1]/(1 + exp(-AA[2] * (seq(0,60,0.01)-AA[3]))))*100,lwd=3);
  legend('topright',paste('U =',round(100-AA[1]*100),'%'),bty='n')  
  
  # fitting intact
  plot(time,wt_1[,i],main=paste('w/o NU7441:',colnames(wt_1)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='intact/(intact+mutated) (%)',xlab='time (h)',col=2);
  lines(time[which(is.finite(wt_1[,i]))],noinhibitor_total_individual_series[[i]]$intact*100,lwd=3,col=2)
  
  R_sq[i]=cor(noinhibitor_total_individual_series[[i]]$intact,wt_1[which(is.finite(wt_1[,i])),i])^2;
  kcmax[i]= log(2)/noinhibitor_total_individual_series[[i]]$hlc;
  kp[i]= log(2)/(noinhibitor_total_individual_series[[i]]$hlm/noinhibitor_total_individual_series[[i]]$perfectF);
  km[i]=log(2)/noinhibitor_total_individual_series[[i]]$hlm;
  
  legend('bottomleft',legend=bquote(R^2 == .(round(R_sq[i],2))), bty='n')
  
  # plotting mutants
  plot(time,indel_1[,i],main=paste('w/o NU7441:',colnames(wt_1)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='mutated/(intact+mutated) (%)',xlab='time (h)',col=3);
  lines(time[which(is.finite(wt_1[,i]))],noinhibitor_total_individual_series[[i]]$mutant*100,lwd=3,col=3)
  
  R_sq[i]=cor(noinhibitor_total_individual_series[[i]]$intact,wt_1[which(is.finite(wt_1[,i])),i])^2;

  legend('bottomleft',legend=bquote(R^2 == .(round(R_sq[i],2))), bty='n')
  
  
  # plotting broken
  plot(seq(0,max(time),0.1),main=paste('w/o NU7441:',colnames(wt_1)[i]),noinhibitor_total_individual_series[[i]]$broken*100,lwd=3,col=4,type='l',ylab='broken (%)',xlab='time (h)')
  abline(v=noinhibitor_total_individual_series[[i]]$peakBro,col=4,lwd=3,lty=2)
  abline(h=0,col=4,lwd=3,lty=2)
  
  legend('topright',legend=bquote(tau == .(noinhibitor_total_individual_series[[i]]$peakBro)~' h '), bty='n')
  
  #plot rates
  bplt=barplot(main=paste('w/o NU7441:',colnames(wt_1)[i]),c(kcmax[i],kp[i],km[i]),col=c(4,1,2),names.arg=c(expression('k'['c']*'max'), expression('k'['p']), expression('k'['m'])),horiz=TRUE,las=2,xlab=expression('h'^-1));
  
  rg=range(c(kcmax[i],kp[i],km[i]));
  
  text(mean(rg),bplt[1,1],bquote(.(round(kcmax[i]/10^floor(log10(kcmax[i])),1)) *'x 10' ^ .(floor(log10(kcmax[i])))),col=3,cex=2)
  
  text(mean(rg),bplt[2,1],bquote(.(round(kp[i]/10^floor(log10(kp[i])),1)) *'x 10' ^ .(floor(log10(kp[i])))),col=3,cex=2)
  
  
  text(mean(rg),bplt[3,1],bquote(.(round(km[i]/10^floor(log10(km[i])),1)) *'x 10' ^ .(floor(log10(km[i])))),col=3,cex=2)
  
}

print(R_sq)
print(mean(R_sq))
print(sd(R_sq))

#################################################################
# fitting for with inhibitor
#################################################################

R_sq_i=NA
kcmax_i=kp_i=km_i=NA

withinhibitor_total_individual_series = rep(list(NULL),ncol(wt_2));
for (i in 1:ncol(wt_2)){
  withinhibitor_total_individual_series[[i]]=ZLWB2fitDefault(time,wt_2[,i],indel_2[,i]);
  AA = UntransfectedFitting(time,wt_2[,i],indel_2[,i]);
  
  # data
  plot(time,wt_2[,i],main=paste(colnames(wt_2)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='intact/(intact+mutated) (%)',xlab='time (h)');
  
  # untransfected
  plot(time,wt_2[,i],main=paste('with NU7441:',colnames(wt_2)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='intact/(intact+mutated) (%)',xlab='time (h)');
  lines(seq(0,60,0.01),(1-AA[1]/(1 + exp(-AA[2] * (seq(0,60,0.01)-AA[3]))))*100,lwd=3);
  legend('topright',paste('U =',round(100-AA[1]*100),'%'),bty='n')  
  
  # fitting intact
  plot(time,wt_2[,i],main=paste('with NU7441:',colnames(wt_2)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='intact/(intact+mutated) (%)',xlab='time (h)',col=2);
  lines(time[which(is.finite(wt_2[,i]))],withinhibitor_total_individual_series[[i]]$intact*100,lwd=3,col=2)
  
  R_sq_i[i]=cor(withinhibitor_total_individual_series[[i]]$intact,wt_2[which(is.finite(wt_2[,i])),i])^2;
  kcmax_i= log(2)/withinhibitor_total_individual_series[[i]]$hlc;
  kp_i= log(2)/(withinhibitor_total_individual_series[[i]]$hlm/withinhibitor_total_individual_series[[i]]$perfectF);
  km_i=log(2)/withinhibitor_total_individual_series[[i]]$hlm;
  
  legend('bottomleft',legend=bquote(R^2 == .(round(R_sq[i],2))), bty='n')
  
  # plotting mutants
  plot(time,indel_2[,i],main=paste('with NU7441:',colnames(wt_2)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='mutated/(intact+mutated) (%)',xlab='time (h)',col=3);
  lines(time[which(is.finite(wt_2[,i]))],withinhibitor_total_individual_series[[i]]$mutant*100,lwd=3,col=3)
  
   R_sq_i[i]=cor(withinhibitor_total_individual_series[[i]]$intact,wt_2[which(is.finite(wt_2[,i])),i])^2;

  legend('bottomleft',legend=bquote(R^2 == .(round(R_sq[i],2))), bty='n')
  
  
  # plotting broken
  plot(seq(0,max(time),0.1),main=paste('with NU7441:',colnames(wt_2)[i]),withinhibitor_total_individual_series[[i]]$broken*100,lwd=3,col=4,type='l',ylab='broken (%)',xlab='time (h)')
  abline(v=withinhibitor_total_individual_series[[i]]$peakBro,col=4,lwd=3,lty=2)
  abline(h=0,col=4,lwd=3,lty=2)
  
  legend('topright',legend=bquote(tau == .(withinhibitor_total_individual_series[[i]]$peakBro)~' h '), bty='n')
  
  #plot rates
  bplt=barplot(main=paste('with NU7441:',colnames(wt_1)[i]),c(kcmax_i,kp_i,km_i),col=c(4,1,2),names.arg=c(expression('k'['c']*'max'), expression('k'['p']), expression('k'['m'])),horiz=TRUE,las=2,xlab=expression('h'^-1));
  
  rg=range(c(kcmax_i,kp_i,km_i));
  
  text(mean(rg),bplt[1,1],bquote(.(round(kcmax_i/10^floor(log10(kcmax_i)),1)) *'x 10' ^ .(floor(log10(kcmax_i)))),col=3,cex=2)
  
  text(mean(rg),bplt[2,1],bquote(.(round(kp_i/10^floor(log10(kp_i)),1)) *'x 10' ^ .(floor(log10(kp_i)))),col=3,cex=2)
  
  
  text(mean(rg),bplt[3,1],bquote(.(round(km_i/10^floor(log10(km_i)),1)) *'x 10' ^ .(floor(log10(km_i)))),col=3,cex=2)
  
}

print(R_sq_i)
print(mean(R_sq_i))
print(sd(R_sq_i))

```

<h2>Collect individual data series and represent parameters</h2>
<p>split into without and with NU7441</p>

```{r rate constants}

library(beeswarm);

# hlc
beeswarm(list(log(2)/sapply(noinhibitor_total_individual_series,function(x){x$hlc}),log(2)/sapply(withinhibitor_total_individual_series,function(x){x$hlc})),pch=16,cex=1.5,col=c(4,2),labels = c("w/o NU7441", "with NU7441"),ylab=expression('k'['c']*'max'*' (h'^-1*')'))

lgd = legend('topright',c(paste(round(mean(sapply(noinhibitor_total_individual_series,function(x){x$hlc})),1),'',round(sd(sapply(noinhibitor_total_individual_series,function(x){x$hlc})),1)),paste(round(mean(sapply(withinhibitor_total_individual_series,function(x){x$hlc})),1),'+/-',round(sd(sapply(withinhibitor_total_individual_series,function(x){x$hlc})),1))),text.col=c(0,0),bty='n');

d1 = log(2)/sapply(noinhibitor_total_individual_series,function(x){x$hlc});
d2 = log(2)/sapply(withinhibitor_total_individual_series,function(x){x$hlc});

text(lgd$text$x[1],lgd$text$y[1],bquote('('*.(round(mean(d1)/10^(floor(log10(mean(d1)))),1)) *''* .(round(sd(d1)/10^(floor(log10(mean(d1)))),1))*') x 10' ^ .(floor(log10(mean(d1))))),col=4)

text(lgd$text$x[2],lgd$text$y[2],bquote('('*.(round(mean(d2)/10^(floor(log10(mean(d2)))),1)) *''* .(round(sd(d2)/10^(floor(log10(mean(d2)))),1))*') x 10' ^ .(floor(log10(mean(d2))))),col=2)


# hlp
beeswarm(list(log(2)/(sapply(noinhibitor_total_individual_series,function(x){x$hlm})/sapply(noinhibitor_total_individual_series,function(x){x$perfectF})),log(2)/(sapply(withinhibitor_total_individual_series,function(x){x$hlm})/sapply(withinhibitor_total_individual_series,function(x){x$perfectF}))),pch=16,cex=1.5,col=c(4,2),labels = c("w/o NU7441", "with NU7441"),ylab=expression('k'['p']*' (h'^-1*')'));

lgd = legend('bottomright',c(paste(round(mean(log(2)/(sapply(noinhibitor_total_individual_series,function(x){x$hlm})/sapply(noinhibitor_total_individual_series,function(x){x$perfectF}))),2),'+/-',round(sd(log(2)/(sapply(noinhibitor_total_individual_series,function(x){x$hlm})/sapply(noinhibitor_total_individual_series,function(x){x$perfectF}))),2)),paste(round(mean(log(2)/(sapply(withinhibitor_total_individual_series,function(x){x$hlm})/sapply(withinhibitor_total_individual_series,function(x){x$perfectF}))),2),'+/-',round(sd(log(2)/(sapply(withinhibitor_total_individual_series,function(x){x$hlm})/sapply(withinhibitor_total_individual_series,function(x){x$perfectF}))),2))),text.col=c(0,0),bty='n')

d1 = (log(2)/(sapply(noinhibitor_total_individual_series,function(x){x$hlm})/sapply(noinhibitor_total_individual_series,function(x){x$perfectF})));
d2 = (log(2)/(sapply(withinhibitor_total_individual_series,function(x){x$hlm})/sapply(withinhibitor_total_individual_series,function(x){x$perfectF})));

text(lgd$text$x[1],lgd$text$y[1],bquote('('*.(round(mean(d1)/10^(floor(log10(mean(d1)))),1)) *''* .(round(sd(d1)/10^(floor(log10(mean(d1)))),1))*') x 10' ^ .(floor(log10(mean(d1))))),col=4)

text(lgd$text$x[2],lgd$text$y[2],bquote('('*.(round(mean(d2)/10^(floor(log10(mean(d2)))),1)) *''* .(round(sd(d2)/10^(floor(log10(mean(d2)))),1))*') x 10' ^ .(floor(log10(mean(d2))))),col=2)


# hlm
beeswarm(list(log(2)/sapply(noinhibitor_total_individual_series,function(x){x$hlm}),log(2)/sapply(withinhibitor_total_individual_series,function(x){x$hlm})),pch=16,cex=1.5,col=c(4,2),labels = c("w/o NU7441", "with NU7441"),ylab=expression('k'['m']*' (h'^-1*')'))

lgd = legend('topright',c(paste(round(mean(sapply(noinhibitor_total_individual_series,function(x){x$hlm})),1),'',round(sd(sapply(noinhibitor_total_individual_series,function(x){x$hlm})),1)),paste(round(mean(sapply(withinhibitor_total_individual_series,function(x){x$hlm})),1),'+/-',round(sd(sapply(withinhibitor_total_individual_series,function(x){x$hlm})),1))),text.col=c(0,0),bty='n');

d1 = log(2)/sapply(noinhibitor_total_individual_series,function(x){x$hlm});
d2 = log(2)/sapply(withinhibitor_total_individual_series,function(x){x$hlm});

text(lgd$text$x[1],lgd$text$y[1],bquote('('*.(round(mean(d1)/10^(floor(log10(mean(d1)))),1)) *''* .(round(sd(d1)/10^(floor(log10(mean(d1)))),1))*') x 10' ^ .(floor(log10(mean(d1))))),col=4)

text(lgd$text$x[2],lgd$text$y[2],bquote('('*.(round(mean(d2)/10^(floor(log10(mean(d2)))),1)) *''* .(round(sd(d2)/10^(floor(log10(mean(d2)))),1))*') x 10' ^ .(floor(log10(mean(d2))))),col=2)


# peakBro
beeswarm(list(sapply(noinhibitor_total_individual_series,function(x){x$peakBro}),sapply(withinhibitor_total_individual_series,function(x){x$peakBro})),pch=16,cex=1.5,col=c(4,2),labels = c("w/o NU7441", "with NU7441"),ylab=bquote(tau * ' (h)' ))

legend('bottomright',c(paste(round(mean(sapply(noinhibitor_total_individual_series,function(x){x$peakBro})),1),'+/-',round(sd(sapply(noinhibitor_total_individual_series,function(x){x$peakBro})),1)),paste(round(mean(sapply(withinhibitor_total_individual_series,function(x){x$peakBro})),1),'+/-',round(sd(sapply(withinhibitor_total_individual_series,function(x){x$peakBro})),1))),text.col=c(4,2),bty='n')

```


<h2>Compare the ZLWB2 model with the simple model</h2>
<p>for comparison with ZLWB2 by F-statistic</p>
<p>1: invididual series</p>
<p>2: piled-up</p>

```{r simple model vs ZLWB2}

# extract time point information
time = as.numeric(row.names(wildtype_tot_LBR2));

#### no inhibitor
###individual series
noinhibitor_simplemodel_series = rep(list(NULL),ncol(wt_1));
for (i in 1:ncol(wt_1)){
  noinhibitor_simplemodel_series[[i]]=simpleDefault(time,wt_1[,i],indel_1[,i]);
}

df2 = min(apply(wt_1,2,function(x){sum(as.numeric(!is.na(x)))-3}));
rg = range(c(log2(sapply(noinhibitor_simplemodel_series,function(x){x$residual_sq})),log2(sapply(noinhibitor_total_individual_series,function(x){x$residual_sq}))));

plot(main='w/o NU7441: individual series',log2(sapply(noinhibitor_simplemodel_series,function(x){x$residual_sq})),log2(sapply(noinhibitor_total_individual_series,function(x){x$residual_sq})),xlim=rg,ylim=rg,pch=16,col=4,cex=2,xlab=bquote('log'[2]*'(sum of resid'^2*'): linear ODE'),ylab=bquote('log'[2]*'(sum of resid'^2*'): non-linear ODE'));

abline(-log2(qf(0.95,df2,df2)),1,lwd=2,lty=2,col=3)

abline(-log2(qf(0.5,df2,df2)),1,lwd=2,lty=2)
abline(log2(qf(0.95,df2,df2)),1,lwd=2,lty=2,col=6)

text(mean(rg)+log2(qf(0.95,df2,df2))/2,mean(rg)-log2(qf(0.95,df2,df2))/2,'p=0.05',pos=4,col=3)
text(mean(rg)-log2(qf(0.95,df2,df2))/2,mean(rg)+log2(qf(0.95,df2,df2))/2,'p=0.05',pos=2,col=6)
text(mean(rg),log2(qf(0.5,df2,df2))+mean(rg),'p=0.5')

legend('topleft','linear ODE is better',bty='n',text.col=6)
legend('bottomright','non-linear ODE is better',bty='n',text.col=3)


### optimal fitting for piled up
ZLWB2optimalParaR = ZLWB2PiledupOMMerge(time,wt_1,indel_1)[[1]]$residuals;
simpleoptimalParaR = simplePiledupOMMerge(time,wt_1,indel_1)$residuals;

rg=range(rg,log2(sum(simpleoptimalParaR^2)),log2(sum(ZLWB2optimalParaR^2)));
plot(main='w/o NU7441: piled-up',log2(sapply(noinhibitor_simplemodel_series,function(x){x$residual_sq})),log2(sapply(noinhibitor_total_individual_series,function(x){x$residual_sq})),xlim=rg,ylim=rg,pch=16,col=4,cex=2,xlab=bquote('log'[2]*'(sum of resid'^2*'): linear ODE'),ylab=bquote('log'[2]*'(sum of resid'^2*'): non-linear ODE'),type='n');

df2 = sum(!is.na(wt_1))-3;
abline(-log2(qf(0.95,df2,df2)),1,lwd=2,lty=2,col=3)

abline(-log2(qf(0.5,df2,df2)),1,lwd=2,lty=2)
abline(log2(qf(0.95,df2,df2)),1,lwd=2,lty=2,col=6)

points(log2(sum(simpleoptimalParaR^2)),log2(sum(ZLWB2optimalParaR^2)),pch='*',cex=3,col=4)
text(mean(rg)+log2(qf(0.95,df2,df2))/2,mean(rg)-log2(qf(0.95,df2,df2))/2,'p=0.05',pos=4,col=4)
text(mean(rg)+log2(qf(0.95,df2,df2))/2,mean(rg)-log2(qf(0.95,df2,df2))/2,'p=0.05',pos=4,col=3)
text(mean(rg)-log2(qf(0.95,df2,df2))/2,mean(rg)+log2(qf(0.95,df2,df2))/2,'p=0.05',pos=2,col=6)
text(mean(rg),log2(qf(0.5,df2,df2))+mean(rg),'p=0.5')

legend('topleft','linear ODE is better',bty='n',text.col=6)
legend('bottomright','non-linear ODE is better',bty='n',text.col=3)


#### with inhibitor
###individual series
withinhibitor_simplemodel_sereis = rep(list(NULL),ncol(wt_2));
for (i in 1:ncol(wt_2)){
  withinhibitor_simplemodel_sereis[[i]]=simpleDefault(time,wt_2[,i],indel_2[,i]);
}

df2 = min(apply(wt_2,2,function(x){sum(as.numeric(!is.na(x)))-3}));
rg = range(c(log2(sapply(withinhibitor_simplemodel_sereis,function(x){x$residual_sq})),log2(sapply(withinhibitor_total_individual_series,function(x){x$residual_sq}))));

plot(main='with NU7441: individual series',log2(sapply(withinhibitor_simplemodel_sereis,function(x){x$residual_sq})),log2(sapply(withinhibitor_total_individual_series,function(x){x$residual_sq})),xlim=rg,ylim=rg,pch=16,col=2,cex=2,xlab=bquote('log'[2]*'(sum of resid'^2*'): linear ODE'),ylab=bquote('log'[2]*'(sum of resid'^2*'): non-linear ODE'));

abline(-log2(qf(0.95,df2,df2)),1,lwd=2,lty=2,col=3)

abline(-log2(qf(0.5,df2,df2)),1,lwd=2,lty=2)
abline(log2(qf(0.95,df2,df2)),1,lwd=2,lty=2,col=6)

text(mean(rg)+log2(qf(0.95,df2,df2))/2,mean(rg)-log2(qf(0.95,df2,df2))/2,'p=0.05',pos=4,col=3)
text(mean(rg)-log2(qf(0.95,df2,df2))/2,mean(rg)+log2(qf(0.95,df2,df2))/2,'p=0.05',pos=2,col=6)
text(mean(rg),log2(qf(0.5,df2,df2))+mean(rg),'p=0.5')

legend('topleft','linear ODE is better',bty='n',text.col=6)
legend('bottomright','non-linear ODE is better',bty='n',text.col=3)


### optimal fitting for piled up
ZLWB2optimalParaR = ZLWB2PiledupOMMerge(time,wt_2,indel_2)[[1]]$residuals;
simpleoptimalParaR = simplePiledupOMMerge(time,wt_2,indel_2)$residuals;

rg=range(rg,log2(sum(simpleoptimalParaR^2)),log2(sum(ZLWB2optimalParaR^2)));
plot(main='with NU7441: piled-up',log2(sapply(withinhibitor_simplemodel_sereis,function(x){x$residual_sq})),log2(sapply(withinhibitor_total_individual_series,function(x){x$residual_sq})),xlim=rg,ylim=rg,pch=16,col=2,cex=2,xlab=bquote('log'[2]*'(sum of resid'^2*'): linear ODE'),ylab=bquote('log'[2]*'(sum of resid'^2*'): non-linear ODE'),type='n');

df2 = sum(!is.na(wt_2))-3;
abline(-log2(qf(0.95,df2,df2)),1,lwd=2,lty=2,col=3)

abline(-log2(qf(0.5,df2,df2)),1,lwd=2,lty=2)
abline(log2(qf(0.95,df2,df2)),1,lwd=2,lty=2,col=6)

points(log2(sum(simpleoptimalParaR^2)),log2(sum(ZLWB2optimalParaR^2)),pch='*',cex=3,col=2)
text(mean(rg)+log2(qf(0.95,df2,df2))/2,mean(rg)-log2(qf(0.95,df2,df2))/2,'p=0.05',pos=4,col=3)
text(mean(rg)-log2(qf(0.95,df2,df2))/2,mean(rg)+log2(qf(0.95,df2,df2))/2,'p=0.05',pos=2,col=6)
text(mean(rg),log2(qf(0.5,df2,df2))+mean(rg),'p=0.5')

legend('topleft','linear ODE is better',bty='n',text.col=6)
legend('bottomright','non-linear ODE is better',bty='n',text.col=3)

```

<h2>Fit on all data points for 4 loci</h2>

```{r fit on all data points}

time = seq(0,60,0.1);
t = time;
t2 = which(time%in%time_all)
res_LBR2 <- NA
res_LBR8 <- NA
res_AAVS1 <- NA
res_fLAD <- NA
UO<- NA

kc_LBR2 <- kc_LBR8 <-kc_AAVS1 <-kc_chr11 <-NA
kp_LBR2 <- kp_LBR8 <-kp_AAVS1 <-kp_chr11 <-NA
km_LBR2 <- km_LBR8 <-km_AAVS1 <-km_chr11 <-NA

for(i in 0:30){
print(i)
UO[i+1]=(60+i)  

#LBR2
XXX = wt_1;
DF= data.frame(time = as.numeric(rownames(XXX)),wt = as.numeric(unlist(XXX)),mut = as.numeric(unlist(100-XXX)),pos=rep(seq(1,nrow(XXX)),ncol(XXX)))
DF = DF[!is.na(rowSums(DF)),];
DF[,4]=as.numeric(sapply(DF[,1],function(x){which(sort(unique(DF[,1]))==x)}));
lll = ZLWB2fitDefaultAllTP(DF, U=(100-mean(UO[i+1]))/100)

kc_LBR2[i+1] = log(2)/lll$hlc
kp_LBR2[i+1] = log(2)/(lll$hlm/lll$perfectF)
km_LBR2[i+1] = log(2)/lll$hlm

LBR2_av <- rowMeans(wt_1)
R_sq=(cor(lll$intact[t2][which(is.finite(LBR2_av))],LBR2_av[which(is.finite(LBR2_av))])^2);
res_LBR2[i+1] <- lll$residual_sq

print(c(kc_LBR2[i+1], kp_LBR2[i+1], km_LBR2[i+1]))

#plot(DF[,1],DF[,2],ylim=c(0,100),main='LBR2 fitting', pch=20, col=1, cex=0.5, ylab="intact/total", xlab="time (h)")
#lines(time_all, rowMeans(wt_1), type="p", pch=20, cex=1.5, col=2)
#lines(time,lll$intact*100,lwd=2,col=2)

#text(x=55, y=90, labels=paste("kc = ", formatC(kc_LBR2[i+1], digits = 2),"\n", "kp =", formatC(kp_LBR2[i+1], digits=2), "\n", "km =", formatC(km_LBR2[i+1],digits=2), "\n", "R^2 =", formatC(R_sq,digits=2)))

#plot(time,lll$broken*100,main='LBR2 broken', lwd=2,lty=1, pch=16,cex=1.5,col=4,cex.lab=1.5,cex.axis=1.5,xlab='time (h)',ylab='broken (%)', type="l")

#LBR8

XXX = wt_LBR8;
DF= data.frame(time = as.numeric(rownames(XXX)),wt = as.numeric(unlist(XXX)),mut = as.numeric(unlist(100-XXX)),pos=rep(seq(1,nrow(XXX)),ncol(XXX)))
DF = DF[!is.na(rowSums(DF)),];
DF[,4]=as.numeric(sapply(DF[,1],function(x){which(sort(unique(DF[,1]))==x)}));
lll = ZLWB2fitDefaultAllTP(DF, U=(100-mean(UO[i+1]))/100)

kc_LBR8[i+1] = log(2)/lll$hlc
kp_LBR8[i+1] = log(2)/(lll$hlm/lll$perfectF)
km_LBR8[i+1] = log(2)/lll$hlm

LBR8_av <- rowMeans(wt_LBR8)
R_sq=(cor(lll$intact[t2][which(is.finite(LBR8_av))],LBR8_av[which(is.finite(LBR8_av))])^2);
res_LBR8[i+1] <- lll$residual_sq

print(c(kc_LBR8[i+1], kp_LBR8[i+1], km_LBR8[i+1]))


#plot(DF[,1],DF[,2],ylim=c(0,100),main='LBR8 fitting', pch=20, col=1, cex=0.5, ylab="intact/total", xlab="time (h)")
#lines(time_all, rowMeans(wt_LBR8), type="p", pch=20, cex=1.5, col=2)
#lines(time,lll$intact*100,lwd=2,col=2)

#text(x=55, y=90, labels=paste("kc = ", formatC(kc_LBR8[i+1], digits = 2),"\n", "kp =", formatC(kp_LBR8[i+1], digits=2), "\n", "km =", formatC(km_LBR8[i+1],digits=2), "\n", "R^2 =", formatC(R_sq,digits=2)))

#plot(time,lll$broken*100,main='LBR8 broken', lwd=2,lty=1, pch=16,cex=1.5,col=4,cex.lab=1.5,cex.axis=1.5,xlab='time (h)',ylab='broken (%)', type="l")


#AAVS1
XXX = wt_AAVS1;
DF= data.frame(time = as.numeric(rownames(XXX)),wt = as.numeric(unlist(XXX)),mut = as.numeric(unlist(100-XXX)),pos=rep(seq(1,nrow(XXX)),ncol(XXX)))
DF = DF[!is.na(rowSums(DF)),];
DF[,4]=as.numeric(sapply(DF[,1],function(x){which(sort(unique(DF[,1]))==x)}));
lll = ZLWB2fitDefaultAllTP(DF, U=(100-mean(UO[i+1]))/100)

kc_AAVS1[i+1] = log(2)/lll$hlc
kp_AAVS1[i+1] = log(2)/(lll$hlm/lll$perfectF)
km_AAVS1[i+1] = log(2)/lll$hlm

AAVS1_av <- rowMeans(wt_AAVS1)
R_sq=(cor(lll$intact[t2][which(is.finite(AAVS1_av))],AAVS1_av[which(is.finite(AAVS1_av))])^2);
res_AAVS1[i+1] <- lll$residual_sq

print(c(kc_AAVS1[i+1], kp_AAVS1[i+1], km_AAVS1[i+1]))

#plot(DF[,1],DF[,2],ylim=c(0,100),main='AAVS1 fitting', pch=20, col=1, cex=0.5, ylab="intact/total", xlab="time (h)")
#lines(time_all, rowMeans(wt_AAVS1), type="p", pch=20, cex=1.5, col=2)
#lines(time,lll$intact*100,lwd=2,col=2)

#text(x=55, y=90, labels=paste("kc = ", formatC(kc_AAVS1[i+1], digits = 2),"\n", "kp =", formatC(kp_AAVS1[i+1], digits=2), "\n", "km =", formatC(km_AAVS1[i+1],digits=2), "\n", "R^2 =", formatC(R_sq,digits=2)))

#plot(time,lll$broken*100,main='AAVS1 broken', lwd=2,lty=1, pch=16,cex=1.5,col=4,cex.lab=1.5,cex.axis=1.5,xlab='time (h)',ylab='broken (%)', type="l")


#chr11
XXX = wt_chr11;
DF= data.frame(time = as.numeric(rownames(XXX)),wt = as.numeric(unlist(XXX)),mut = as.numeric(unlist(100-XXX)),pos=rep(seq(1,nrow(XXX)),ncol(XXX)))
DF = DF[!is.na(rowSums(DF)),];
DF[,4]=as.numeric(sapply(DF[,1],function(x){which(sort(unique(DF[,1]))==x)}));
lll = ZLWB2fitDefaultAllTP(DF, U=(100-mean(UO[i+1]))/100)

chr11_av <- rowMeans(wt_chr11)
R_sq=(cor(lll$intact[t2][which(is.finite(chr11_av))],chr11_av[which(is.finite(chr11_av))])^2);
res_fLAD[i+1] <- lll$residual_sq

kc_chr11[i+1] = log(2)/lll$hlc
kp_chr11[i+1] = log(2)/(lll$hlm/lll$perfectF)
km_chr11[i+1] = log(2)/lll$hlm

print(c(kc_chr11[i+1], kp_chr11[i+1], km_chr11[i+1]))

#plot(DF[,1],DF[,2],ylim=c(0,100),main='chr11 fitting',pch=20, col=1, cex=0.5, ylab="intact/total", xlab="time (h)")
#lines(time_all, rowMeans(wt_chr11), type="p", pch=20, cex=1.5, col=2)
#lines(time,lll$intact*100,lwd=2,col=2)

#text(x=55, y=90, labels=paste("kc = ", formatC(kc_chr11[i+1], digits = 2),"\n", "kp =", formatC(kp_chr11[i+1], digits=2), "\n", "km =", formatC(km_chr11[i+1],digits=2), "\n", "R^2 =", formatC(R_sq,digits=2)))

#plot(time,lll$broken*100,main='chr11 broken', lwd=2,lty=1, pch=16,cex=1.5,col=4,cex.lab=1.5,cex.axis=1.5,xlab='time (h)',ylab='broken (%)', type="l")
}

plot(UO, res_LBR2)
UO[which(res_LBR2==min(res_LBR2))]
LBR2_res_max <- max(res_LBR2)

plot(UO, res_LBR8)
UO[which(res_LBR8==min(res_LBR8))]
LBR8_res_max <- max(res_LBR8)

plot(UO, res_AAVS1)
UO[which(res_AAVS1==min(res_AAVS1))]
AAVS1_res_max <- max(res_AAVS1)

plot(UO, res_fLAD)
UO[which(res_fLAD==min(res_fLAD))]
fLAD_res_max <- max(res_fLAD)

sum_res <- (res_LBR2/LBR2_res_max)+(res_LBR8/LBR8_res_max)+(res_AAVS1/AAVS1_res_max)+(res_fLAD/fLAD_res_max)
plot(UO, sum_res)
UO[which(sum_res==min(sum_res))]

dkc_LBR2 <- density(kc_LBR2)
dkc_LBR8 <- density(kc_LBR8)
dkc_AAVS1 <- density(kc_AAVS1)
dkc_chr11 <- density(kc_chr11)
dkp_LBR2 <- density(kp_LBR2)
dkp_LBR8 <- density(kp_LBR8)
dkp_AAVS1 <- density(kp_AAVS1)
dkp_chr11 <- density(kp_chr11)
dkm_LBR2 <-  density(km_LBR2)
dkm_LBR8 <- density(km_LBR8)
dkm_AAVS1 <- density(km_AAVS1)
dkm_chr11 <- density(km_chr11)

plot(dkc_LBR2); plot(dkc_LBR8); plot(dkc_AAVS1); plot(dkc_chr11)
plot(dkp_LBR2); plot(dkp_LBR8); plot(dkp_AAVS1); plot(dkp_chr11)
plot(dkm_LBR2); plot(dkm_LBR8); plot(dkm_AAVS1); plot(dkm_chr11)


###########


time = seq(0,60,0.1);
t = time;
t2 = which(time%in%time_all)

COL=heat_hcl(7)

#LBR2
U_LBR2 <-UO[which(res_LBR2==min(res_LBR2))]
print(U_LBR2)

XXX = wt_1;
DF= data.frame(time = as.numeric(rownames(XXX)),wt = as.numeric(unlist(XXX)),mut = as.numeric(unlist(100-XXX)),pos=rep(seq(1,nrow(XXX)),ncol(XXX)))
DF = DF[!is.na(rowSums(DF)),];
DF[,4]=as.numeric(sapply(DF[,1],function(x){which(sort(unique(DF[,1]))==x)}));
lll = ZLWB2fitDefaultAllTP(DF, U=(100-mean(U_LBR2))/100)

kc_LBR2 = log(2)/lll$hlc
kp_LBR2 = log(2)/(lll$hlm/lll$perfectF)
km_LBR2 = log(2)/lll$hlm


R_sq=(cor(lll$intact[t2][which(is.finite(LBR2_av))],LBR2_av[which(is.finite(LBR2_av))])^2);

print(c(kc_LBR2, kp_LBR2, km_LBR2))
print(log(2)/(kp_LBR2+km_LBR2))

print(kp_LBR2/(kp_LBR2+km_LBR2))

#plot(DF[,1],DF[,2],ylim=c(0,100),main='LBR2 fitting', pch=20, col=1, cex=0.5, ylab="intact/total", xlab="time (h)")

plot(rownames(wt_1), wt_1[,1],ylim=c(0,100),main='LBR2 fitting', pch=20, col=COL[1], cex=0.5, ylab="intact/total", xlab="time (h)")
lines(rownames(wt_1), wt_1[,2], type="p", col=COL[2],pch=20,cex=0.5)
lines(rownames(wt_1), wt_1[,3], type="p", col=COL[3],pch=20,cex=0.5)
lines(rownames(wt_1), wt_1[,4], type="p", col=COL[4],pch=20,cex=0.5)
lines(rownames(wt_1), wt_1[,5], type="p", col=COL[5],pch=20,cex=0.5)
lines(rownames(wt_1), wt_1[,6], type="p", col=COL[6],pch=20,cex=0.5)
lines(rownames(wt_1), wt_1[,7], type="p", col=COL[7],pch=20,cex=0.5)
lines(time_all, rowMeans(wt_1), type="p", pch=20, cex=1.5, col=2)
lines(time,lll$intact*100,lwd=2,col=2)

text(x=55, y=90, labels=paste("kc = ", formatC(kc_LBR2, digits = 2),"\n", "kp =", formatC(kp_LBR2, digits=2), "\n", "km =", formatC(km_LBR2,digits=2), "\n", "R^2 =", R_sq))

plot(time,lll$broken*100,main='LBR2 broken', lwd=2,lty=1, pch=16,cex=1.5,col=4,cex.lab=1.5,cex.axis=1.5,xlab='time (h)',ylab='broken (%)', type="l")


#LBR8
U_LBR8 <- UO[which(res_LBR8==min(res_LBR8))]
print(U_LBR8)

XXX = wt_LBR8;
DF= data.frame(time = as.numeric(rownames(XXX)),wt = as.numeric(unlist(XXX)),mut = as.numeric(unlist(100-XXX)),pos=rep(seq(1,nrow(XXX)),ncol(XXX)))
DF = DF[!is.na(rowSums(DF)),];
DF[,4]=as.numeric(sapply(DF[,1],function(x){which(sort(unique(DF[,1]))==x)}));
lll = ZLWB2fitDefaultAllTP(DF, U=(100-mean(U_LBR8))/100)

kc_LBR8 = log(2)/lll$hlc
kp_LBR8 = log(2)/(lll$hlm/lll$perfectF)
km_LBR8 = log(2)/lll$hlm

LBR8_av <- rowMeans(wt_LBR8)
R_sq=(cor(lll$intact[t2][which(is.finite(LBR8_av))],LBR8_av[which(is.finite(LBR8_av))])^2);

print(c(kc_LBR8, kp_LBR8, km_LBR8))
print(log(2)/(kp_LBR8+km_LBR8))
print(kp_LBR8/(kp_LBR8+km_LBR8))


#plot(DF[,1],DF[,2],ylim=c(0,100),main='LBR8 fitting', pch=20, col=1, cex=0.5, ylab="intact/total", xlab="time (h)")

plot(rownames(wt_LBR8), wt_LBR8[,1],ylim=c(0,100),main='LBR8 fitting', pch=20, col=COL[1], cex=0.5, ylab="intact/total", xlab="time (h)")
lines(rownames(wt_LBR8), wt_LBR8[,2], type="p", col=COL[2],pch=20,cex=0.5)
lines(rownames(wt_LBR8), wt_LBR8[,3], type="p", col=COL[3],pch=20,cex=0.5)
lines(rownames(wt_LBR8), wt_LBR8[,4], type="p", col=COL[4],pch=20,cex=0.5)
lines(rownames(wt_LBR8), wt_LBR8[,5], type="p", col=COL[5],pch=20,cex=0.5)
lines(rownames(wt_LBR8), wt_LBR8[,6], type="p", col=COL[6],pch=20,cex=0.5)
lines(time_all, rowMeans(wt_LBR8), type="p", pch=20, cex=1.5, col=2)
lines(time,lll$intact*100,lwd=2,col=2)

text(x=55, y=90, labels=paste("kc = ", formatC(kc_LBR8, digits = 2),"\n", "kp =", formatC(kp_LBR8, digits=2), "\n", "km =", formatC(km_LBR8,digits=2), "\n", "R^2 =", R_sq))

plot(time,lll$broken*100,main='LBR8 broken', lwd=2,lty=1, pch=16,cex=1.5,col=4,cex.lab=1.5,cex.axis=1.5,xlab='time (h)',ylab='broken (%)', type="l")


#AAVS1
U_AAVS1 <- UO[which(res_AAVS1==min(res_AAVS1))]
print(U_AAVS1)

XXX = wt_AAVS1;
DF= data.frame(time = as.numeric(rownames(XXX)),wt = as.numeric(unlist(XXX)),mut = as.numeric(unlist(100-XXX)),pos=rep(seq(1,nrow(XXX)),ncol(XXX)))
DF = DF[!is.na(rowSums(DF)),];
DF[,4]=as.numeric(sapply(DF[,1],function(x){which(sort(unique(DF[,1]))==x)}));
lll = ZLWB2fitDefaultAllTP(DF, U=(100-mean(U_AAVS1))/100)

kc_AAVS1 = log(2)/lll$hlc
kp_AAVS1 = log(2)/(lll$hlm/lll$perfectF)
km_AAVS1 = log(2)/lll$hlm

R_sq=(cor(lll$intact[t2][which(is.finite(AAVS1_av))],AAVS1_av[which(is.finite(AAVS1_av))])^2);


print(c(kc_AAVS1, kp_AAVS1, km_AAVS1))
print(log(2)/(kp_AAVS1+km_AAVS1))
print(kp_AAVS1/(kp_AAVS1+km_AAVS1))

#plot(DF[,1],DF[,2],ylim=c(0,100),main='AAVS1 fitting', pch=20, col=1, cex=0.5, ylab="intact/total", xlab="time (h)")

plot(rownames(wt_AAVS1), wt_AAVS1[,1],ylim=c(0,100),main='AAVS1 fitting', pch=20, col=COL[1], cex=0.5, ylab="intact/total", xlab="time (h)")
lines(rownames(wt_AAVS1), wt_AAVS1[,2], type="p", col=COL[2],pch=20,cex=0.5)
lines(rownames(wt_AAVS1), wt_AAVS1[,3], type="p", col=COL[3],pch=20,cex=0.5)
lines(rownames(wt_AAVS1), wt_AAVS1[,4], type="p", col=COL[4],pch=20,cex=0.5)
lines(rownames(wt_AAVS1), wt_AAVS1[,5], type="p", col=COL[5],pch=20,cex=0.5)
lines(rownames(wt_AAVS1), wt_AAVS1[,6], type="p", col=COL[6],pch=20,cex=0.5)
lines(time_all, rowMeans(wt_AAVS1), type="p", pch=20, cex=1.5, col=2)
lines(time,lll$intact*100,lwd=2,col=2)

text(x=55, y=90, labels=paste("kc = ", formatC(kc_AAVS1, digits = 2),"\n", "kp =", formatC(kp_AAVS1, digits=2), "\n", "km =", formatC(km_AAVS1,digits=2), "\n", "R^2 =", R_sq))

plot(time,lll$broken*100,main='AAVS1 broken', lwd=2,lty=1, pch=16,cex=1.5,col=4,cex.lab=1.5,cex.axis=1.5,xlab='time (h)',ylab='broken (%)', type="l")


#chr11
U_fLAD <- UO[which(res_fLAD==min(res_fLAD))]
print(U_fLAD)

XXX = wt_chr11;
DF= data.frame(time = as.numeric(rownames(XXX)),wt = as.numeric(unlist(XXX)),mut = as.numeric(unlist(100-XXX)),pos=rep(seq(1,nrow(XXX)),ncol(XXX)))
DF = DF[!is.na(rowSums(DF)),];
DF[,4]=as.numeric(sapply(DF[,1],function(x){which(sort(unique(DF[,1]))==x)}));
lll = ZLWB2fitDefaultAllTP(DF, U=(100-mean(U_fLAD))/100)

R_sq=(cor(lll$intact[t2][which(is.finite(chr11_av))],chr11_av[which(is.finite(chr11_av))])^2);

kc_chr11 = log(2)/lll$hlc
kp_chr11 = log(2)/(lll$hlm/lll$perfectF)
km_chr11 = log(2)/lll$hlm

print(c(kc_chr11, kp_chr11, km_chr11))
print(log(2)/(kp_chr11+km_chr11))
print(kp_chr11/(kp_chr11+km_chr11))

#plot(DF[,1],DF[,2],ylim=c(0,100),main='chr11 fitting',pch=20, col=1, cex=0.5, ylab="intact/total", xlab="time (h)")

plot(rownames(wt_chr11), wt_chr11[,1],ylim=c(0,100),main='chr11 fitting', pch=20, col=COL[1], cex=0.5, ylab="intact/total", xlab="time (h)")
lines(rownames(wt_chr11), wt_chr11[,2], type="p", col=COL[2],pch=20,cex=0.5)
lines(rownames(wt_chr11), wt_chr11[,3], type="p", col=COL[3],pch=20,cex=0.5)
lines(rownames(wt_chr11), wt_chr11[,4], type="p", col=COL[4],pch=20,cex=0.5)
lines(rownames(wt_AAVS1), wt_chr11[,5], type="p", col=COL[5],pch=20,cex=0.5)
lines(time_all, rowMeans(wt_chr11), type="p", pch=20, cex=1.5, col=2)
lines(time,lll$intact*100,lwd=2,col=2)

text(x=55, y=90, labels=paste("kc = ", formatC(kc_chr11, digits = 2),"\n", "kp =", formatC(kp_chr11, digits=2), "\n", "km =", formatC(km_chr11,digits=2), "\n", "R^2 =", R_sq))

plot(time,lll$broken*100,main='chr11 broken', lwd=2,lty=1, pch=16,cex=1.5,col=4,cex.lab=1.5,cex.axis=1.5,xlab='time (h)',ylab='broken (%)', type="l")

#AAVS1
U_AAVS1 <- mean(c(U_LBR2, U_LBR8, U_fLAD))
print(U_AAVS1)

XXX = wt_AAVS1;
DF= data.frame(time = as.numeric(rownames(XXX)),wt = as.numeric(unlist(XXX)),mut = as.numeric(unlist(100-XXX)),pos=rep(seq(1,nrow(XXX)),ncol(XXX)))
DF = DF[!is.na(rowSums(DF)),];
DF[,4]=as.numeric(sapply(DF[,1],function(x){which(sort(unique(DF[,1]))==x)}));
lll = ZLWB2fitDefaultAllTP(DF, U=(100-mean(U_AAVS1))/100)

kc_AAVS1 = log(2)/lll$hlc
kp_AAVS1 = log(2)/(lll$hlm/lll$perfectF)
km_AAVS1 = log(2)/lll$hlm

R_sq=(cor(lll$intact[t2][which(is.finite(AAVS1_av))],AAVS1_av[which(is.finite(AAVS1_av))])^2);

print(c(kc_AAVS1, kp_AAVS1, km_AAVS1))
print(log(2)/(kp_AAVS1+km_AAVS1))
print(kp_AAVS1/(kp_AAVS1+km_AAVS1))

#plot(DF[,1],DF[,2],ylim=c(0,100),main='AAVS1 fitting', pch=20, col=1, cex=0.5, ylab="intact/total", xlab="time (h)")

plot(rownames(wt_AAVS1), wt_AAVS1[,1],ylim=c(0,100),main='AAVS1 fitting', pch=20, col=COL[1], cex=0.5, ylab="intact/total", xlab="time (h)")
lines(rownames(wt_AAVS1), wt_AAVS1[,2], type="p", col=COL[2],pch=20,cex=0.5)
lines(rownames(wt_AAVS1), wt_AAVS1[,3], type="p", col=COL[3],pch=20,cex=0.5)
lines(rownames(wt_AAVS1), wt_AAVS1[,4], type="p", col=COL[4],pch=20,cex=0.5)
lines(rownames(wt_AAVS1), wt_AAVS1[,5], type="p", col=COL[5],pch=20,cex=0.5)
lines(rownames(wt_AAVS1), wt_AAVS1[,6], type="p", col=COL[6],pch=20,cex=0.5)
lines(time_all, rowMeans(wt_AAVS1), type="p", pch=20, cex=1.5, col=2)
lines(time,lll$intact*100,lwd=2,col=2)

text(x=55, y=90, labels=paste("kc = ", formatC(kc_AAVS1, digits = 2),"\n", "kp =", formatC(kp_AAVS1, digits=2), "\n", "km =", formatC(km_AAVS1,digits=2), "\n", "R^2 =", R_sq))

plot(time,lll$broken*100,main='AAVS1 broken', lwd=2,lty=1, pch=16,cex=1.5,col=4,cex.lab=1.5,cex.axis=1.5,xlab='time (h)',ylab='broken (%)', type="l")



```

<h2>bootstrapping</h2>

```{r bootstrapping, eval=FALSE}

# bootstrap for 1000 times
nt = 1000;
lstfitting = rep(rep(list(NULL),nt),4);
names(lstfitting)=c('LBR2','LBR8','AAVS1','chr11');

#Determined untransfection rate LBR2: 72%, LBR8:  69% and chr11: 75%, AAVS1: 72%.

for (i in 1:nt){
  # LBR2
  XXX = wt_1;
  DF= data.frame(time = as.numeric(rownames(XXX)),wt = as.numeric(unlist(XXX)),mut = as.numeric(unlist(100-XXX)),pos=rep(seq(1,nrow(XXX)),ncol(XXX)))
  DF = DF[!is.na(rowSums(DF)),];
  DF = DF[sample(1:nrow(DF),size=nrow(DF),replace = TRUE),]
  DF[,4]=as.numeric(sapply(DF[,1],function(x){which(sort(unique(DF[,1]))==x)}));
  lstfitting[['LBR2']][[i]] = list(all = ZLWB2fitDefaultAllTP(DF,U=1-0.72))
  
  # LBR8
  XXX = wt_LBR8;
  DF= data.frame(time = as.numeric(rownames(XXX)),wt = as.numeric(unlist(XXX)),mut = as.numeric(unlist(100-XXX)),pos=rep(seq(1,nrow(XXX)),ncol(XXX)))
  DF = DF[!is.na(rowSums(DF)),];
  DF = DF[sample(1:nrow(DF),size=nrow(DF),replace = TRUE),]
  DF[,4]=as.numeric(sapply(DF[,1],function(x){which(sort(unique(DF[,1]))==x)}));
  lstfitting[['LBR8']][[i]] = list(all = ZLWB2fitDefaultAllTP(DF, U=1-0.69))
  
  # AAVS1
  XXX = wt_AAVS1;
  DF= data.frame(time = as.numeric(rownames(XXX)),wt = as.numeric(unlist(XXX)),mut = as.numeric(unlist(100-XXX)),pos=rep(seq(1,nrow(XXX)),ncol(XXX)))
  DF = DF[!is.na(rowSums(DF)),];
  DF = DF[sample(1:nrow(DF),size=nrow(DF),replace = TRUE),]
  DF[,4]=as.numeric(sapply(DF[,1],function(x){which(sort(unique(DF[,1]))==x)}));
  lstfitting[['AAVS1']][[i]] = list(all = ZLWB2fitDefaultAllTP(DF, U=1-0.72))
  
  # chr11
  XXX = wt_chr11;
  DF= data.frame(time = as.numeric(rownames(XXX)),wt = as.numeric(unlist(XXX)),mut = as.numeric(unlist(100-XXX)),pos=rep(seq(1,nrow(XXX)),ncol(XXX)))
  DF = DF[!is.na(rowSums(DF)),];
  DF = DF[sample(1:nrow(DF),size=nrow(DF),replace = TRUE),]
  DF[,4]=as.numeric(sapply(DF[,1],function(x){which(sort(unique(DF[,1]))==x)}));
  lstfitting[['chr11']][[i]] = list(all = ZLWB2fitDefaultAllTP(DF, U=1-0.75))
  
  cat(i/nt,'\r')
}

##
time = seq(0,max(time),0.1)

#LBR2 outlier fittered
boxplot(outline=F,log(2)/unlist(sapply(lstfitting[['LBR2']],function(x){x[[1]][['hlc']]})),main = 'LBR2 Kc')
aa = mean(unlist(sapply(lstfitting[['LBR2']],function(x){x[[1]][['hlc']]})))
legend('topright',legend=paste('mean = ',log(2)/aa))

boxplot(outline=F,log(2)/(unlist(sapply(lstfitting[['LBR2']],function(x){x[[1]][['hlm']]}))/unlist(sapply(lstfitting[['LBR2']],function(x){x[[1]][[1]]}))),main = 'LBR2 Kp')
bb = mean((unlist(sapply(lstfitting[['LBR2']],function(x){x[[1]][['hlm']]}))/unlist(sapply(lstfitting[['LBR2']],function(x){x[[1]][[1]]}))))
legend('topright',legend=paste('mean = ',log(2)/bb))

boxplot(outline=F,log(2)/unlist(sapply(lstfitting[['LBR2']],function(x){x[[1]][['hlm']]})),main = 'LBR2 Km')
cc = mean(unlist(sapply(lstfitting[['LBR2']],function(x){x[[1]][['hlm']]})))
legend('topright',legend=paste('mean = ',log(2)/cc))

XXX = wt_1;
DF= data.frame(time = as.numeric(rownames(XXX)),wt = as.numeric(unlist(XXX)),mut = as.numeric(unlist(100-XXX)),pos=rep(seq(1,nrow(XXX)),ncol(XXX)))
DF = DF[!is.na(rowSums(DF)),];
DF[,4]=as.numeric(sapply(DF[,1],function(x){which(sort(unique(DF[,1]))==x)}));
lll = ZLWB2fitDefaultAllTP(DF, U=(mean(unlist(sapply(lstfitting[['LBR2']],function(x){x[[1]][['Untf']]})))))

idx1 = sapply(lapply(lstfitting[['LBR2']],function(x){x[[1]][['broken']]}),length) == length(seq(0,max(time),0.1))
idx2 = time %in% as.numeric(rownames(XXX))

#intact
plot(DF[,1],DF[,2],ylim=c(0,100),main='LBR2 fitting', pch=20, col=1, cex=0.5, ylab="intact/total", xlab="time (h)")

# uncertainty scheme
mtx = matrix(NA,length(time),nt);
rownames(mtx) = as.character(time);

for (i in 1:floor(ncol(mtx)/10)){
  if (((sapply(lstfitting[['LBR2']],function(x){length(x[[1]][['intact']])}))==nrow(mtx))[i]){
    mtx[,i] = lstfitting[['LBR2']][[i]][[1]][['intact']]
    lines(time,mtx[,i]*100,col=rgb(0,0,1,0.2))
  }
}
lines(time,lll$intact*100,lwd=2,col=2)
points(DF[,1],DF[,2],ylim=c(0,100),pch=16)

#broken
plot(time,lll$broken*100,lwd=2,col=2,ylim=c(0,100),main='LBR2 broken')
mtx = sapply(lstfitting[['LBR2']][idx1],function(x){x[[1]][['broken']]});

for (i in 1:floor(ncol(mtx)/10)){
  lines(time,mtx[,i]*100,col=rgb(0,0,1,0.2))
}
lines(time,lll$broken*100,lwd=2,col=2,ylim=c(0,100))


#LBR8

#LBR8 outlier fittered
boxplot(outline=F,log(2)/unlist(sapply(lstfitting[['LBR8']],function(x){x[[1]][['hlc']]})),main = 'LBR8 Kc')
aa = mean(unlist(sapply(lstfitting[['LBR8']],function(x){x[[1]][['hlc']]})))
legend('topright',legend=paste('mean = ',log(2)/aa))

boxplot(outline=F,log(2)/(unlist(sapply(lstfitting[['LBR8']],function(x){x[[1]][['hlm']]}))/unlist(sapply(lstfitting[['LBR8']],function(x){x[[1]][[1]]}))),main = 'LBR8 Kp')
bb = mean((unlist(sapply(lstfitting[['LBR8']],function(x){x[[1]][['hlm']]}))/unlist(sapply(lstfitting[['LBR8']],function(x){x[[1]][[1]]}))))
legend('topright',legend=paste('mean = ',log(2)/bb))

boxplot(outline=F,log(2)/unlist(sapply(lstfitting[['LBR8']],function(x){x[[1]][['hlm']]})),main = 'LBR8 Km')
cc = mean(unlist(sapply(lstfitting[['LBR8']],function(x){x[[1]][['hlm']]})))
legend('topright',legend=paste('mean = ',log(2)/cc))

XXX = wt_LBR8;
DF= data.frame(time = as.numeric(rownames(XXX)),wt = as.numeric(unlist(XXX)),mut = as.numeric(unlist(100-XXX)),pos=rep(seq(1,nrow(XXX)),ncol(XXX)))
DF = DF[!is.na(rowSums(DF)),];
DF[,4]=as.numeric(sapply(DF[,1],function(x){which(sort(unique(DF[,1]))==x)}));
lll = ZLWB2fitDefaultAllTP(DF, U=(mean(unlist(sapply(lstfitting[['LBR8']],function(x){x[[1]][['Untf']]})))))

idx1 = sapply(lapply(lstfitting[['LBR8']],function(x){x[[1]][['broken']]}),length) == length(time)
idx2 = time %in% as.numeric(rownames(XXX))

#intact
plot(DF[,1],DF[,2],ylim=c(0,100),main='LBR8 fitting', pch=20, col=1, cex=0.5, ylab="intact/total", xlab="time (h)")

# uncertainty scheme
mtx = matrix(NA,length(time),nt);
rownames(mtx) = as.character(time);

for (i in 1:floor(ncol(mtx)/10)){
  if (((sapply(lstfitting[['LBR8']],function(x){length(x[[1]][['intact']])}))==nrow(mtx))[i]){
    mtx[,i] = lstfitting[['LBR8']][[i]][[1]][['intact']]
    lines(time,mtx[,i]*100,col=rgb(0,0,1,0.2))
  }
}
lines(time,lll$intact*100,lwd=2,col=2)
points(DF[,1],DF[,2],ylim=c(0,100),pch=16)

#broken
plot(time,lll$broken*100,lwd=2,col=2,ylim=c(0,100),main='LBR8 broken')
mtx = matrix(unlist(sapply(lstfitting[['LBR8']][idx1],function(x){x[[1]][['broken']]})),nrow=length(time))

for (i in 1:floor(ncol(mtx)/10)){
  lines(time,mtx[,i]*100,col=rgb(0,0,1,0.2))
}
lines(time,lll$broken*100,lwd=2,col=2,ylim=c(0,100))


#AAVS1

#AAVS1 outlier fittered
boxplot(outline=F,log(2)/unlist(sapply(lstfitting[['AAVS1']],function(x){x[[1]][['hlc']]})),main = 'AAVS1 Kc')
aa = mean(unlist(sapply(lstfitting[['AAVS1']],function(x){x[[1]][['hlc']]})))
legend('topright',legend=paste('mean = ',log(2)/aa))

boxplot(outline=F,log(2)/(unlist(sapply(lstfitting[['AAVS1']],function(x){x[[1]][['hlm']]}))/unlist(sapply(lstfitting[['AAVS1']],function(x){x[[1]][[1]]}))),main = 'AAVS1 Kp')
bb = mean((unlist(sapply(lstfitting[['AAVS1']],function(x){x[[1]][['hlm']]}))/unlist(sapply(lstfitting[['AAVS1']],function(x){x[[1]][[1]]}))))
legend('topright',legend=paste('mean = ',log(2)/bb))

boxplot(outline=F,log(2)/unlist(sapply(lstfitting[['AAVS1']],function(x){x[[1]][['hlm']]})),main = 'AAVS1 Km')
cc = mean(unlist(sapply(lstfitting[['AAVS1']],function(x){x[[1]][['hlm']]})))
legend('topright',legend=paste('mean = ',log(2)/cc))

XXX = wt_AAVS1;
DF= data.frame(time = as.numeric(rownames(XXX)),wt = as.numeric(unlist(XXX)),mut = as.numeric(unlist(100-XXX)),pos=rep(seq(1,nrow(XXX)),ncol(XXX)))
DF = DF[!is.na(rowSums(DF)),];
DF[,4]=as.numeric(sapply(DF[,1],function(x){which(sort(unique(DF[,1]))==x)}));
lll = ZLWB2fitDefaultAllTP(DF, U=(mean(unlist(sapply(lstfitting[['AAVS1']],function(x){x[[1]][['Untf']]})))))

idx1 = sapply(lapply(lstfitting[['AAVS1']],function(x){x[[1]][['broken']]}),length) == length(time)
idx2 = time %in% as.numeric(rownames(XXX))

#intact
plot(DF[,1],DF[,2],ylim=c(0,100),main='AAVS1 fitting', pch=20, col=1, cex=0.5, ylab="intact/total", xlab="time (h)")

# uncertainty scheme
mtx = matrix(NA,length(time),nt);
rownames(mtx) = as.character(time);

for (i in 1:floor(ncol(mtx)/10)){
  if (((sapply(lstfitting[['AAVS1']],function(x){length(x[[1]][['intact']])}))==nrow(mtx))[i]){
    mtx[,i] = lstfitting[['AAVS1']][[i]][[1]][['intact']]
    lines(time,mtx[,i]*100,col=rgb(0,0,1,0.2))
  }
}
lines(time,lll$intact*100,lwd=2,col=2)
points(DF[,1],DF[,2],ylim=c(0,100),pch=16)

plot(time,lll$broken*100,lwd=2,col=2,ylim=c(0,100),main='AAVS1 broken')
mtx = matrix(unlist(sapply(lstfitting[['AAVS1']],function(x){x[[1]][['broken']]})[sapply(sapply(lstfitting[['AAVS1']],function(x){x[[1]][['broken']]}),length)==length(time)]),nrow=length(time))

#broken
for (i in 1:floor(ncol(mtx)/10)){
  lines(time,mtx[,i]*100,col=rgb(0,0,1,0.2))
}

lines(time,lll$broken*100,lwd=2,col=2,ylim=c(0,100))

#chr11

#chr11 outlier fittered
boxplot(outline=F,log(2)/unlist(sapply(lstfitting[['chr11']],function(x){x[[1]][['hlc']]})),main = 'chr11 Kc')
aa = mean(unlist(sapply(lstfitting[['chr11']],function(x){x[[1]][['hlc']]})))
legend('topright',legend=paste('mean = ',log(2)/aa))

boxplot(outline=F,log(2)/(unlist(sapply(lstfitting[['chr11']],function(x){x[[1]][['hlm']]}))/unlist(sapply(lstfitting[['chr11']],function(x){x[[1]][[1]]}))),main = 'chr11 Kp')
bb = mean((unlist(sapply(lstfitting[['chr11']],function(x){x[[1]][['hlm']]}))/unlist(sapply(lstfitting[['chr11']],function(x){x[[1]][[1]]}))))
legend('topright',legend=paste('mean = ',log(2)/bb))

boxplot(outline=F,log(2)/unlist(sapply(lstfitting[['chr11']],function(x){x[[1]][['hlm']]})),main = 'chr11 Km')
cc = mean(unlist(sapply(lstfitting[['chr11']],function(x){x[[1]][['hlm']]})))
legend('topright',legend=paste('mean = ',log(2)/cc))

XXX = wt_chr11;
DF= data.frame(time = as.numeric(rownames(XXX)),wt = as.numeric(unlist(XXX)),mut = as.numeric(unlist(100-XXX)),pos=rep(seq(1,nrow(XXX)),ncol(XXX)))
DF = DF[!is.na(rowSums(DF)),];
DF[,4]=as.numeric(sapply(DF[,1],function(x){which(sort(unique(DF[,1]))==x)}));
lll = ZLWB2fitDefaultAllTP(DF, U=(mean(unlist(sapply(lstfitting[['chr11']],function(x){x[[1]][['Untf']]})))))

#intact
plot(DF[,1],DF[,2],ylim=c(0,100),main='chr11 fitting', pch=20, col=1, cex=0.5, ylab="intact/total", xlab="time (h)")

# uncertainty scheme
mtx = matrix(NA,length(time),nt);
rownames(mtx) = as.character(time);

for (i in 1:floor(ncol(mtx)/10)){
  if (((sapply(lstfitting[['chr11']],function(x){length(x[[1]][['intact']])}))==nrow(mtx))[i]){
    mtx[,i] = lstfitting[['chr11']][[i]][[1]][['intact']]
    lines(time,mtx[,i]*100,col=rgb(0,0,1,0.2))
  }
}
lines(time,lll$intact*100,lwd=2,col=2)
points(DF[,1],DF[,2],ylim=c(0,100),pch=16)

#broken
plot(time,lll$broken*100,lwd=2,col=2,ylim=c(0,100),main='chr11 broken')
mtx = matrix(unlist(sapply(lstfitting[['chr11']],function(x){x[[1]][['broken']]})[sapply(sapply(lstfitting[['chr11']],function(x){x[[1]][['broken']]}),length)==length(time)]),nrow=length(time))

for (i in 1:floor(ncol(mtx)/10)){
  lines(time,mtx[,i]*100,col=rgb(0,0,1,0.2))
}
lines(time,lll$broken*100,lwd=2,col=2,ylim=c(0,100))

#combine the bootstrapping results in one big dataset

LBR2_mtx <- cbind(
log(2)/unlist(sapply(lstfitting[['LBR2']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['hlc']],NA)})),
log(2)/(unlist(sapply(lstfitting[['LBR2']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['hlm']],NA)}))/unlist(sapply(lstfitting[['LBR2']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['perfectF']],NA)}))),
log(2)/unlist(sapply(lstfitting[['LBR2']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['hlm']],NA)})),
unlist(sapply(lstfitting[['LBR2']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['maxBro']],NA)})),
unlist(sapply(lstfitting[['LBR2']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['peakBro']],NA)})),
unlist(sapply(lstfitting[['LBR2']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['residual_sq']],NA)})))

colnames(LBR2_mtx) = c('kc','kp','km','maxBro', 'peakBro', 'residual_sq')

LBR8_mtx <- cbind(
  log(2)/unlist(sapply(lstfitting[['LBR8']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['hlc']],NA)})),
  log(2)/(unlist(sapply(lstfitting[['LBR8']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['hlm']],NA)}))/unlist(sapply(lstfitting[['LBR8']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['perfectF']],NA)}))),
  log(2)/unlist(sapply(lstfitting[['LBR8']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['hlm']],NA)})),
  unlist(sapply(lstfitting[['LBR8']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['maxBro']],NA)})),
  unlist(sapply(lstfitting[['LBR8']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['peakBro']],NA)})),
  unlist(sapply(lstfitting[['LBR8']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['residual_sq']],NA)})))

colnames(LBR8_mtx) = c('kc','kp','km','maxBro', 'peakBro', 'residual_sq')

AAVS1_mtx <- cbind(
  log(2)/unlist(sapply(lstfitting[['AAVS1']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['hlc']],NA)})),
  log(2)/(unlist(sapply(lstfitting[['AAVS1']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['hlm']],NA)}))/unlist(sapply(lstfitting[['AAVS1']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['perfectF']],NA)}))),
  log(2)/unlist(sapply(lstfitting[['AAVS1']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['hlm']],NA)})),
  unlist(sapply(lstfitting[['AAVS1']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['maxBro']],NA)})),
  unlist(sapply(lstfitting[['AAVS1']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['peakBro']],NA)})),
  unlist(sapply(lstfitting[['AAVS1']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['residual_sq']],NA)})))

colnames(AAVS1_mtx) = c('kc','kp','km','maxBro', 'peakBro', 'residual_sq')

chr11_mtx <- cbind(
  log(2)/unlist(sapply(lstfitting[['chr11']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['hlc']],NA)})),
  log(2)/(unlist(sapply(lstfitting[['chr11']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['hlm']],NA)}))/unlist(sapply(lstfitting[['chr11']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['perfectF']],NA)}))),
  log(2)/unlist(sapply(lstfitting[['chr11']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['hlm']],NA)})),
  unlist(sapply(lstfitting[['chr11']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['maxBro']],NA)})),
  unlist(sapply(lstfitting[['chr11']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['peakBro']],NA)})),
  unlist(sapply(lstfitting[['chr11']],function(x){ifelse(length(x[[1]][['hlm']]),x[[1]][['residual_sq']],NA)})))

colnames(chr11_mtx) = c('kc','kp','km','maxBro', 'peakBro', 'residual_sq')


mtx = list(
  LBR2=LBR2_mtx, 
  LBR8=LBR8_mtx,
  AAVS1=AAVS1_mtx,
  chr11=chr11_mtx)

df <- mtx

#load("df20180108.rda") # bootstrapping dataset as described in paper

for(i in names(df)) {df[[i]]<-cbind(df[[i]], df[[i]][,2] / (df[[i]][,3]+df[[i]][,2]))
	                 colnames(df[[i]])[7]<-"kp.fraction"	
	                }
for(i in names(df)) {print(apply(df[[i]], 2, quantile, c(0.05, 0.5, 0.95)))} #median & confidence margins

```

<h2>Determination of the upperbound of p/m and test parameter robustness, on the total mutation scale</h2>
<p>Apply functions ZLWB2PiledupOMMerge and ZLWB2PiledupSweepMerge to piled-up series, without NU7441 inhibitor</p>
<p>sweeping from 80% every time shrink a factor of 2 but compensent a factor of i, i is the number of iteration from i to 32</p>
<p>apply F-statistic (p<0.05) to determin upperbound</p>

```{r parameter sweep}

time = time_all
  
### optimal fitting for pipled up
optimalParaR = ZLWB2PiledupOMMerge(time,wt_1,indel_1);
optimalPara = optimalParaR[[1]];

upperboundPileupMerge = rep(list(NULL),32);
options(warn=-1)
for (i in 1:length(upperboundPileupMerge)){
  fc=0.75;
  sweep = fc/(1-fc)*2/(2^i)*i;
  upperboundPileupMerge[[i]]=try(ZLWB2PiledupSweepMerge(time,wt_1,indel_1),silent=TRUE)
}
options(warn=1)

# on the total mutation scale
#######################################################
###plot sweeping and residuals
plot(axes=FALSE,log10(1-1/(sapply(upperboundPileupMerge,function(x){x$perfectF})+1)),log2(sapply(upperboundPileupMerge,function(x){x$residual_sq})),pch=16,xlab=bquote('log'[10]*'(k'[p]*' /(k'[p]*'+k'[m]*'))'),ylab=bquote('log'[2]*'(sum of resid'^2*')'),type='o',lwd=3);
points(log10(1-1/(sapply(upperboundPileupMerge,function(x){x$perfectF})+1))[1],log2(sapply(upperboundPileupMerge,function(x){x$residual_sq}))[1],cex=1.5,col=3,pch=16)
axis(2)
axis(2,c(-10000,100000000000000))
axis(3,c(-10000,100000000000000))
axis(4,c(-10000,100000000000000))
axis(1,at=seq(-100,100))

abline(v=log10(optimalPara[[1]][3]/(optimalPara[[1]][2]+optimalPara[[1]][3])),lty=2,lwd=3)
abline(h=log2(sum(resid(optimalPara)^2)),lty=2,lwd=3)

#apply f-statistic
df2 = sum(as.numeric(!is.na(indel_1)))-2;

uppershift=log2(sum(resid(optimalPara)^2))+log2(qf(0.9,df2,df2));
abline(h=uppershift,col=2,lty=2,lwd=3)

#solve upperbound
idx2 = max(which(log2(sapply(upperboundPileupMerge,function(x){x$residual_sq}))>uppershift));
idx1 = idx2+1;

x1 = log10(sapply(upperboundPileupMerge,function(x){x$perfectF})[idx1]/(1+sapply(upperboundPileupMerge,function(x){x$perfectF})[idx1]));
x2 = log10(sapply(upperboundPileupMerge,function(x){x$perfectF})[idx2]/(1+sapply(upperboundPileupMerge,function(x){x$perfectF})[idx2]));
y1 = log2(sapply(upperboundPileupMerge,function(x){x$residual_sq}))[idx1];
y2 = log2(sapply(upperboundPileupMerge,function(x){x$residual_sq}))[idx2];

upperbound=(x2-x1)/(y2-y1)*(uppershift-y1)+x1;
abline(v=upperbound,col=2,lty=2,lwd=3);

#labeling
text(srt=90,pos=4,log10(optimalPara[[1]][3]/(optimalPara[[1]][2]+optimalPara[[1]][3])),
     as.numeric(crossprod(range(log2(sapply(upperboundPileupMerge,function(x){x$residual}))),c(17/18,1/18))),
     
     paste('op =',as.character(round((optimalPara[[1]][3]/(optimalPara[[1]][2]+optimalPara[[1]][3]))*10000000)/10000000)))

text(srt=90,pos=2,col=2,upperbound
     ,
     as.numeric(crossprod(range(log2(sapply(upperboundPileupMerge,function(x){x$residual}))),c(1/3,2/3))),
     paste('ub =',round(10^upperbound,2)));

legend('topleft', legend=c('p = 0.1',paste0('perfect repair = ',fc*100,'%')),bty='n',text.col=c(2,3));
#########

####
#get upperbound fitting
sweep=10^upperbound/(1-10^upperbound);
upperboundfitting=ZLWB2PiledupSweepMerge(time,wt_1,indel_1)
##

###plot sweeping and hlc
plot(axes=FALSE,log10(1-1/(sapply(upperboundPileupMerge,function(x){x$perfectF})+1)),log(2)/sapply(upperboundPileupMerge,function(x){x$hlc}),pch=16,xlab=bquote('log'[10]*'(k'[p]*' /(k'[p]*'+k'[m]*'))'),ylab=expression('k'['c']*'max ( h'^-1*')'),type='o',lwd=3,ylim=c(0,max(log(2)/sapply(upperboundPileupMerge,function(x){x$hlc}))))

axis(2)
axis(2,c(-10000,100000000000000))
axis(3,c(-10000,100000000000000))
axis(4,c(-10000,100000000000000))
axis(1,at=seq(-100,100))

abline(v=log10(optimalPara[[1]][3]/(optimalPara[[1]][3]+optimalPara[[1]][2])),lty=2,lwd=3)
abline(h=log(2)/optimalPara[[1]][1],lty=2,lwd=3)

abline(v=upperbound,col=2,lty=2,lwd=3)

#solve upperbound hlc
abline(h=log(2)/upperboundfitting$hlc,col=2,lty=2,lwd=3);
points(log10(1-1/(sapply(upperboundPileupMerge,function(x){x$perfectF})+1))[1],log(2)/sapply(upperboundPileupMerge,function(x){x$hlc})[1],cex=1.5,col=3,pch=16)


#labeling
text(pos=4,log10(optimalPara[[1]][3]/(optimalPara[[1]][2]+optimalPara[[1]][3])),
     as.numeric(crossprod(range(log(2)/(sapply(upperboundPileupMerge,function(x){x$hlc}))),c(8/9,1/9))),
     
     bquote('op = '*.(round(log(2)/optimalPara[[1]][1]/10^floor(log10(log(2)/optimalPara[[1]][1])),1)) *'x 10' ^ .(floor(log10(log(2)/optimalPara[[1]][1])))))

text(pos=2,col=2,upperbound
     ,
     as.numeric(crossprod(range(log(2)/(sapply(upperboundPileupMerge,function(x){x$hlc}))),c(3/5,2/5))),
     bquote('ub = '*.(round(log(2)/upperboundfitting$hlc/10^floor(log10(log(2)/upperboundfitting$hlc)),1)) *'x 10' ^ .(floor(log10(log(2)/upperboundfitting$hlc)))))

legend('topleft', legend=c('p = 0.1',paste0('perfect repair = ',fc*100,'%')),bty='n',text.col=c(2,3));
#########


##plot sweeping and hlm
plot(axes=FALSE,log10(1-1/(sapply(upperboundPileupMerge,function(x){x$perfectF})+1)),log(2)/sapply(upperboundPileupMerge,function(x){x$hlm}),pch=16,xlab=bquote('log'[10]*'(k'[p]*' /(k'[p]*'+k'[m]*'))'),ylab=expression('k'['m']*' ( h'^-1*')'),type='o',lwd=3,ylim=c(0,max(log(2)/sapply(upperboundPileupMerge,function(x){x$hlm}))))
axis(2)
axis(2,c(-10000,100000000000000))
axis(3,c(-10000,100000000000000))
axis(4,c(-10000,100000000000000))
axis(1,at=seq(-100,100))

abline(v=log10(optimalPara[[1]][3]/(optimalPara[[1]][3]+optimalPara[[1]][2])),lty=2,lwd=3)
abline(h=log(2)/optimalPara[[1]][3],lty=2,lwd=3)

abline(v=upperbound,col=2,lty=2,lwd=3)

points(log10(1-1/(sapply(upperboundPileupMerge,function(x){x$perfectF})+1))[1],log(2)/sapply(upperboundPileupMerge,function(x){x$hlm})[1],cex=1.5,col=3,pch=16)

#solve upperbound hlm

#abline(h=upperlevel,col=2,lty=2,lwd=3);
abline(h=log(2)/upperboundfitting$hlm,col=2,lty=2,lwd=3);


#labeling
text(pos=4,log10(optimalPara[[1]][3]/(optimalPara[[1]][3]+optimalPara[[1]][2])),
     as.numeric(crossprod(range(log(2)/sapply(upperboundPileupMerge,function(x){x$hlm})[sapply(upperboundPileupMerge,function(x){x$hlm})>0]),c(1/2,1/2))),
     
     bquote('op = '*.(round(log(2)/optimalPara[[1]][3]/10^floor(log10(log(2)/optimalPara[[1]][3])),1)) *'x 10' ^ .(floor(log10(log(2)/optimalPara[[1]][3])))))

text(pos=2,col=2,upperbound
     ,
    as.numeric(crossprod(range(log(2)/sapply(upperboundPileupMerge,function(x){x$hlm})[sapply(upperboundPileupMerge,function(x){x$hlm})>0]),c(2/3,1/3))),
     bquote('ub = '*.(round(log(2)/upperboundfitting$hlm/10^floor(log10(log(2)/upperboundfitting$hlm)),1)) *'x 10' ^ .(floor(log10(log(2)/upperboundfitting$hlm)))))

legend('topleft', legend=c('p = 0.1',paste0('perfect repair = ',fc*100,'%')),bty='n',text.col=c(2,3));
#########



###plot sweeping and peakBro
plot(axes=FALSE,log10(1-1/(sapply(upperboundPileupMerge,function(x){x$perfectF})+1)),sapply(upperboundPileupMerge,function(x){x$peakBro}),pch=16,xlab=bquote('log'[10]*'(k'[p]*' /(k'[p]*'+k'[m]*'))'),ylab=bquote(tau*' (h)'),type='o',lwd=3,ylim=c(0,max(sapply(upperboundPileupMerge,function(x){x$peakBro}))))

axis(2)
axis(2,c(-10000,100000000000000))
axis(3,c(-10000,100000000000000))
axis(4,c(-10000,100000000000000))
axis(1,at=seq(-100,100))

abline(v=log10(optimalPara[[1]][3]/(optimalPara[[1]][3]+optimalPara[[1]][2])),lty=2,lwd=3)
abline(h=optimalParaR[[2]],lty=2,lwd=3)

abline(v=upperbound,col=2,lty=2,lwd=3)
abline(h=upperboundfitting$peakBro,col=2,lty=2,lwd=3);

points(log10(1-1/(sapply(upperboundPileupMerge,function(x){x$perfectF})+1))[1],sapply(upperboundPileupMerge,function(x){x$peakBro})[1],cex=1.5,col=3,pch=16)

#solve upperbound hlc

#labeling
text(pos=4,log10(optimalPara[[1]][3]/(optimalPara[[1]][3]+optimalPara[[1]][2])),
     as.numeric(crossprod(range((sapply(upperboundPileupMerge,function(x){x$peakBro}))),c(1/9,8/9))),
     
     paste('op =',round(optimalParaR[[2]],1)))

text(pos=2,col=2,upperbound
     ,
     as.numeric(crossprod(range((sapply(upperboundPileupMerge,function(x){x$peakBro}))),c(1/3,2/3))),
     paste('ub =',round(upperboundfitting$peakBro,1)));

legend('bottomleft', legend=c('p = 0.1',paste0('perfect repair = ',fc*100,'%')),bty='n',text.col=c(2,3));
#########

###plot sweeping and maxBro
#transfected
AAA = rep(NA,ncol(wt_1));
for (i in 1:ncol(wt_1)){
  AAA [i] = (UntransfectedFitting(time,wt_1[,i],indel_1[,i])[1])*100
}

plot(axes=FALSE,log10(1-1/(sapply(upperboundPileupMerge,function(x){x$perfectF})+1)),mean(AAA)*sapply(upperboundPileupMerge,function(x){x$maxBro}),pch=16,xlab=bquote('log'[10]*'(k'[p]*' /(k'[p]*'+k'[m]*'))'),ylab=bquote('max'[broken]*' (%)'),type='o',lwd=3,ylim=c(0,max(mean(AAA)*sapply(upperboundPileupMerge,function(x){x$maxBro}))))

axis(2)
axis(2,c(-10000,100000000000000))
axis(3,c(-10000,100000000000000))
axis(4,c(-10000,100000000000000))
axis(1,at=seq(-100,100))

abline(v=log10(optimalPara[[1]][3]/(optimalPara[[1]][3]+optimalPara[[1]][2])),lty=2,lwd=3)
abline(h=mean(AAA)*upperboundPileupMerge[[which.min(abs(sapply(upperboundPileupMerge,function(x){x$perfectF})-optimalPara[[1]][3]/optimalPara[[1]][2]))[1]]][['maxBro']],lty=2,lwd=3)

abline(v=upperbound,col=2,lty=2,lwd=3)
abline(h=upperboundfitting$maxBro*mean(AAA),col=2,lty=2,lwd=3);

points(log10(1-1/(sapply(upperboundPileupMerge,function(x){x$perfectF})+1))[1],mean(AAA)*sapply(upperboundPileupMerge,function(x){x$maxBro})[1],cex=1.5,col=3,pch=16)

#solve upperbound hlc

#labeling
text(pos=4,log10(optimalPara[[1]][3]/(optimalPara[[1]][3]+optimalPara[[1]][2])),
     as.numeric(crossprod(range((mean(AAA)*sapply(upperboundPileupMerge,function(x){x$maxBro}))),c(1/2,1/2))),
     
     paste('op =',round(mean(AAA)*upperboundPileupMerge[[which.min(abs(sapply(upperboundPileupMerge,function(x){x$perfectF})-optimalPara[[1]][3]/optimalPara[[1]][2]))[1]]][['maxBro']],1)))

text(pos=2,col=2,upperbound
     ,
     as.numeric(crossprod(range((mean(AAA)*sapply(upperboundPileupMerge,function(x){x$maxBro}))),c(1/3,2/3))),
     paste('ub =',round(upperboundfitting$maxBro*mean(AAA),1)));

legend('bottomleft', legend=c('p = 0.1',paste0('perfect repair = ',fc*100,'%')),bty='n',text.col=c(2,3));



############################################
#print rates of 3 fits that not significant

print(log(2)/upperboundPileupMerge[[1]]$hlc)
print(log(2)/(upperboundPileupMerge[[1]]$hlm)*upperboundPileupMerge[[1]]$perfectF)
print(log(2)/upperboundPileupMerge[[1]]$hlm)

print(log(2)/upperboundPileupMerge[[3]]$hlc)
print(log(2)/(upperboundPileupMerge[[3]]$hlm)*upperboundPileupMerge[[3]]$perfectF)
print(log(2)/upperboundPileupMerge[[3]]$hlm)

print(log(2)/upperboundPileupMerge[[5]]$hlc)
print(log(2)/(upperboundPileupMerge[[5]]$hlm)*upperboundPileupMerge[[5]]$perfectF)
print(log(2)/upperboundPileupMerge[[5]]$hlm)

#####
upperboundPileupMerge = rep(list(NULL),13);
options(warn=-1)
for (i in 1:length(upperboundPileupMerge)){
  fc=0.99;
  sweep = fc/(1-fc)*2/(2^i)*i;
  upperboundPileupMerge[[i]]=try(ZLWB2PiledupSweepMerge(time,wt_1,indel_1),silent=TRUE)
}
options(warn=0)

upperboundPileupMerge[[6]] <- NULL

###plot sweeping and maxBro
#transfected
AAA = rep(NA,ncol(wt_1));
for (i in 1:ncol(wt_1)){
  AAA [i] = (UntransfectedFitting(time,wt_1[,i],indel_1[,i])[1])*100
}

plot(axes=FALSE,log10(1-1/(sapply(upperboundPileupMerge,function(x){x$perfectF})+1)),mean(AAA)*sapply(upperboundPileupMerge,function(x){x$maxBro}),pch=16,xlab=bquote('log'[10]*'(k'[p]*' /(k'[p]*'+k'[m]*'))'),ylab=bquote('max'[broken]*' (%)'),type='o',lwd=3,ylim=c(0,max(mean(AAA)*sapply(upperboundPileupMerge,function(x){x$maxBro}))))

axis(2)
axis(2,c(-10000,100000000000000))
axis(3,c(-10000,100000000000000))
axis(4,c(-10000,100000000000000))
axis(1,c(-10000,100000000000000))
axis(1)

abline(v=log10(optimalPara[[1]][3]/(optimalPara[[1]][3]+optimalPara[[1]][2])),lty=2,lwd=3)
abline(h=mean(AAA)*upperboundPileupMerge[[which.min(abs(sapply(upperboundPileupMerge,function(x){x$perfectF})-optimalPara[[1]][3]/optimalPara[[1]][2]))[1]]][['maxBro']],lty=2,lwd=3)

abline(v=upperbound,col=2,lty=2,lwd=3)
abline(h=upperboundfitting$maxBro*mean(AAA),col=2,lty=2,lwd=3);

points(log10(1-1/(sapply(upperboundPileupMerge,function(x){x$perfectF})+1))[1],mean(AAA)*sapply(upperboundPileupMerge,function(x){x$maxBro})[1],cex=1.5,col=3,pch=16)

#solve upperbound hlc

#labeling
text(pos=4,log10(optimalPara[[1]][3]/(optimalPara[[1]][3]+optimalPara[[1]][2])),
     as.numeric(crossprod(range((mean(AAA)*sapply(upperboundPileupMerge,function(x){x$maxBro}))),c(1/2,1/2))),
     
     paste('op =',round(mean(AAA)*upperboundPileupMerge[[which.min(abs(sapply(upperboundPileupMerge,function(x){x$perfectF})-optimalPara[[1]][3]/optimalPara[[1]][2]))[1]]][['maxBro']],1)))

text(pos=2,col=2,upperbound
     ,
     as.numeric(crossprod(range((mean(AAA)*sapply(upperboundPileupMerge,function(x){x$maxBro}))),c(1/3,2/3))),
     paste('ub =',round(upperboundfitting$maxBro*mean(AAA),1)));

legend('bottomleft', legend=c('p = 0.1',paste0('perfect repair = ',fc*100,'%')),bty='n',text.col=c(2,3));

```

<p>Determination of the upperbound of kc</p>:

```{r kc sweep}

upperboundPileupMerge = rep(list(NULL),32);
options(warn=-1)
for (i in 1:length(upperboundPileupMerge)){
  fc=7.5;
  sweep = fc/(1.1^(i-5));
  upperboundPileupMerge[[i]]=try(ZLWB2hlcPiledupSweepMerge (time,wt_1,indel_1),silent=TRUE)
}


###plot sweeping and residuals
plot(log10(sapply(upperboundPileupMerge,function(x){x$hlc})),log2(sapply(upperboundPileupMerge,function(x){x$residual_sq})),pch=16,cex=1.5,xlab=bquote('log'[10]*'(k'[c]*')'),ylab=bquote('log'[2]*'(sum of resid'^2*')'),type='o',lwd=3)

abline(v=log10(log(2)/optimalPara[[1]][1]),lty=2,lwd=3)
abline(h=log2(sum(resid(optimalPara)^2)),lty=2,lwd=3)

#apply f-statistic
df2 = sum(as.numeric(!is.na(indel_1)))-2;

uppershift=log2(sum(resid(optimalPara)^2))+log2(qf(0.9,df2,df2));
abline(h=uppershift,col=2,lty=2,lwd=3)

#solve upperbound
idx2 = which(log2(sapply(upperboundPileupMerge,function(x){x$residual_sq}))>uppershift)[3];
idx1 = idx2+1;

x1 = log10(sapply(upperboundPileupMerge,function(x){x$hlc}))[idx1];
x2 = log10(sapply(upperboundPileupMerge,function(x){x$hlc}))[idx2];
y1 = log2(sapply(upperboundPileupMerge,function(x){x$residual_sq}))[idx1];
y2 = log2(sapply(upperboundPileupMerge,function(x){x$residual_sq}))[idx2];

upperbound=(x2-x1)/(y2-y1)*(uppershift-y1)+x1;
upperbound1=upperbound
abline(v=upperbound,col=2,lty=2,lwd=3);

#solve upperbound
idx2 = which(log2(sapply(upperboundPileupMerge,function(x){x$residual_sq}))>uppershift)[4];
idx1 = idx2-1;

x1 = log10(sapply(upperboundPileupMerge,function(x){x$hlc}))[idx1];
x2 = log10(sapply(upperboundPileupMerge,function(x){x$hlc}))[idx2];
y1 = log2(sapply(upperboundPileupMerge,function(x){x$residual_sq}))[idx1];
y2 = log2(sapply(upperboundPileupMerge,function(x){x$residual_sq}))[idx2];

upperbound=(x2-x1)/(y2-y1)*(uppershift-y1)+x1;
upperbound2=upperbound
abline(v=upperbound,col=2,lty=2,lwd=3);


#labeling
text(srt=90,pos=4,log10(log(2)/optimalPara[[1]][1]),
     as.numeric(crossprod(range(log2(sapply(upperboundPileupMerge,function(x){x$residual}))),c(17/18,1/18))),
     
     paste('op =',as.character(round((log(2)/optimalPara[[1]][1])*100)/100)))

text(srt=90,pos=2,col=2,upperbound1
     ,
     as.numeric(crossprod(range(log2(sapply(upperboundPileupMerge,function(x){x$residual}))),c(1/3,2/3))),
     paste('ub =',round(10^upperbound1,2)));

text(srt=90,pos=2,col=2,upperbound2
     ,
     as.numeric(crossprod(range(log2(sapply(upperboundPileupMerge,function(x){x$residual}))),c(1/3,2/3))),
     paste('ub =',round(10^upperbound2,2)));


legend('topleft', legend='p = 0.1',bty='n',text.col=2);
#########


# peakbro
plot(log10(sapply(upperboundPileupMerge,function(x){x$hlc})),(sapply(upperboundPileupMerge,function(x){x$peakBro})),pch=16,cex=1.5,xlab=bquote('log'[10]*'(k'[c]*')'),ylab='peakBro (h)',type='o',lwd=3)
abline(v=log10(log(2)/optimalPara[[1]][1]),lty=2,lwd=3)
abline(v=upperbound1,col=2,lty=2,lwd=3);
abline(v=upperbound2,col=2,lty=2,lwd=3);


# maxbro
AAA = rep(NA,ncol(wt_1));
for (i in 1:ncol(wt_1)){
  AAA [i] = (UntransfectedFitting(time,wt_1[,i],indel_1[,i])[1])*100
}

plot(log10(sapply(upperboundPileupMerge,function(x){x$hlc})),mean(AAA)*(sapply(upperboundPileupMerge,function(x){x$maxBro})),pch=16,cex=1.5,xlab=bquote('log'[10]*'(k'[c]*')'),ylab='maxBro (%)',type='o',lwd=3)
abline(v=log10(log(2)/optimalPara[[1]][1]),lty=2,lwd=3)

#abline(h=mean(AAA)*upperboundPileupMerge[[which.min(abs(sapply(upperboundPileupMerge,function(x){x$perfectF})-optimalPara[[1]][3]/optimalPara[[1]][2]))[1]]][['maxBro']],lty=2,lwd=3)

abline(v=log10(log(2)/optimalPara[[1]][1]),lty=2,lwd=3)
abline(v=upperbound1,col=2,lty=2,lwd=3);
abline(v=upperbound2,col=2,lty=2,lwd=3);

```

<h2>Overlay theoretical predictions with experimental data of broken end fraction kinetics</h2>
<p>develop function brokenendPkfit to get peakBro</p>
<p>streching experiemntal data to overlay with therotical predictions</p>
<p>extracting peakBro values from both predictions and experiments, and compare without and with inhibitor treatment</p>
<p> also more meaningful to use polynomial to fit</p>
<p> also use indifidual data series to fit </p>

```{r broken fraction}

library(Hmisc)
###function brokenendPkfit

# function brokenendPk to get peakBro
brokenendPkfit = function(time,broken){
  t= seq(0,max(time*10))/10;
  
  ### cas9 fitting
  # Cas9 protein kinetics
  tWB = c(60,42,33,24,21,18,16,14,12,10,8,4,0)
  
  Cas9I = c(1.035116259,0.93119759,1.134895008,0.980514232,0.989879665,0.903886513,1.211372653,0.575621105,0.782199246,0.686693037,0.608119422,0.325573414,0.142920737)
  
  
  Cas9WIfit=function(par){
    
    b=par[1]
    D=Inf
    Dp=par[2]

    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
    return(c(coI)-c(Cas9))
  }
  
  Cas9WISim=function(par){
    
    b=par[1]
    D=Inf
    Dp=par[2]

    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
    return(list(coI))
  }
  
  par = c(1,0.1);
  FL= modFit(f= Cas9WIfit,p=par,lower=rep(0,length(par)))
  becy = FL$par;
  #####
  
  WB1rxnrate=function(t,c,parm){
    
    # rate constant passed through a list called parms
    kc=parm[1]
    kp=parm[2]
    km=parm[3]
    
    b = becy[1];
    D=Inf;
    Dp=becy[2];
    
    # c is the concentration of species
    
    # derivatives dc/dt are computed below
    r=rep(0,length(c))
    r[1]=-kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp+kp*c["B"] #dcA/dt
    r[2]=kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp-(kp+km)*c["B"] #dcB/dt
    r[3]=km*c["B"] #dcC/dt
    
    # the computed derivatives are returned as a list
    # order of derivatives needs to be the same as the order of species in c
    return(list(r))
    
  }
  
  # function for fitting results
  WB1rxnrate_fit = function(parms){
    
    tmax = max(time); 
    
    kc=log(2)/parms[1];
    kp=log(2)/parms[2];
    km=log(2)/parms[3];
    fac=parms[4];
    
    b = becy[1];
    D=Inf;
    Dp=becy[2];
    
    out=ode(y=c(P=1,B=0,M=0),times=t,func=WB1rxnrate,parms=c(kc,kp,km))
    
    s=out[,2:4]; 
    
    B = s[(out[,1]) %in% time,2];

    return(B*fac-broken)
    #return(B-broken)
  }
  
  # function for simulation
   WB1rxnrate_sim = function(parms){
    
    tmax = max(time); 
    
    kc=log(2)/parms[1];
    kp=log(2)/parms[2];
    km=log(2)/parms[3];
    fac=parms[4];
    
    b = becy[1];
    D=Inf;
    Dp=becy[2];
    
    out=ode(y=c(P=1,B=0,M=0),times=t,func=WB1rxnrate,parms=c(kc,kp,km))
    
    s=out[,2:4]; 
    
    B = s[,2];

    return(B*fac)
    #return(B)
  }
  
  parms=c(3,3,3,8)  

  FL = try(modFit(f=WB1rxnrate_fit,p=parms,lower=rep(0,length(parms))), silent = TRUE)
  
  return(list(FL,WB1rxnrate_sim(FL[[1]])));
 
}


## import broken fraction data from agarose gel 
timeb <- c(0,4,8,10,12,14,16,18,21,24,33,42,60)
timemin <- c(0, 8,16,24,60)
timeming <- c(62)

##############
#loading data
#############

##no inhibitor
#3prime broken fraction

noinhibitor_broken_end_3prime <- read.delim("noinhibitor_broken_end_3prime.txt", header=FALSE)
noinhibitor_broken_end_3prime <- noinhibitor_broken_end_3prime[,-1];

noinhibitor_broken_end_min_3prime <- read.delim("noinhibitor_broken_end_min_3prime.txt", header=FALSE)
noinhibitor_broken_end_min_3prime <- noinhibitor_broken_end_min_3prime[,-1];

noinhibitor_broken_end_minguide_3prime <- read.delim("noinhibitor_broken_end_minguide_3prime.txt", header=FALSE)
noinhibitor_broken_end_minguide_3prime <- noinhibitor_broken_end_minguide_3prime[,-1];

#3prime input PCR
noinhibitor_broken_end_3prime_inputPCR <- read.delim("noinhibitor_broken_end_3prime_inputPCR.txt", header=FALSE)
noinhibitor_broken_end_3prime_inputPCR <- noinhibitor_broken_end_3prime_inputPCR[,-1];

noinhibitor_broken_end_min_3prime_inputPCR <- read.delim("noinhibitor_broken_end_min_3prime_inputPCR.txt", header=FALSE)
noinhibitor_broken_end_min_3prime_inputPCR <- noinhibitor_broken_end_min_3prime_inputPCR[,-1];

noinhibitor_broken_end_minguide_3prime_inputPCR <- read.delim("noinhibitor_broken_end_minguide_3prime_inputPCR.txt", header=FALSE)
noinhibitor_broken_end_minguide_3prime_inputPCR <- noinhibitor_broken_end_minguide_3prime_inputPCR[,-1];

#5prime broken fraction
noinhibitor_broken_end_5prime <- read.delim("noinhibitor_broken_end_5prime.txt", header=FALSE)
noinhibitor_broken_end_5prime <- noinhibitor_broken_end_5prime[,-1];

noinhibitor_broken_end_min_5prime <- read.delim("noinhibitor_broken_end_min_5prime.txt", header=FALSE)
noinhibitor_broken_end_min_5prime <- noinhibitor_broken_end_min_5prime[,-1];

noinhibitor_broken_end_minguide_5prime <- read.delim("noinhibitor_broken_end_minguide_5prime.txt", header=FALSE)
noinhibitor_broken_end_minguide_5prime <- noinhibitor_broken_end_minguide_5prime[,-1];

#5prime input PCR
noinhibitor_broken_end_5prime_inputPCR <- read.delim("noinhibitor_broken_end_5prime_inputPCR.txt", header=FALSE)
noinhibitor_broken_end_5prime_inputPCR <- noinhibitor_broken_end_5prime_inputPCR[,-1];

noinhibitor_broken_end_min_5prime_inputPCR <- read.delim("noinhibitor_broken_end_min_5prime_inputPCR.txt", header=FALSE)
noinhibitor_broken_end_min_5prime_inputPCR <- noinhibitor_broken_end_min_5prime_inputPCR[,-1];

noinhibitor_broken_end_minguide_5prime_inputPCR <- read.delim("noinhibitor_broken_end_minguide_5prime_inputPCR.txt", header=FALSE)
noinhibitor_broken_end_minguide_5prime_inputPCR <- noinhibitor_broken_end_minguide_5prime_inputPCR[,-1];


##with inhibitor
#3prime broken fracction
withinhibitor_broken_end_3prime <- read.delim("withinhibitor_broken_end_3prime.txt", header=FALSE)
withinhibitor_broken_end_3prime <- withinhibitor_broken_end_3prime[,-1];

withinhibitor_broken_end_min_3prime <- read.delim("withinhibitor_broken_end_min_3prime.txt", header=FALSE)
withinhibitor_broken_end_min_3prime <- withinhibitor_broken_end_min_3prime[,-1];

withinhibitor_broken_end_minguide_3prime <- read.delim("withinhibitor_broken_end_minguide_3prime.txt", header=FALSE)
withinhibitor_broken_end_minguide_3prime <- withinhibitor_broken_end_minguide_3prime[,-1];

#3prime input PCR
withinhibitor_broken_end_3prime_inputPCR <- read.delim("withinhibitor_broken_end_3prime_inputPCR.txt", header=FALSE)
withinhibitor_broken_end_3prime_inputPCR <- withinhibitor_broken_end_3prime_inputPCR[,-1];

withinhibitor_broken_end_min_3prime_inputPCR <- read.delim("withinhibitor_broken_end_min_3prime_inputPCR.txt", header=FALSE)
withinhibitor_broken_end_min_3prime_inputPCR <- withinhibitor_broken_end_min_3prime_inputPCR[,-1];

withinhibitor_broken_end_minguide_3prime_inputPCR <- read.delim("withinhibitor_broken_end_minguide_3prime_inputPCR.txt", header=FALSE)
withinhibitor_broken_end_minguide_3prime_inputPCR <- withinhibitor_broken_end_minguide_3prime_inputPCR[,-1];


##no inhibitor LBR8
#3prime
noinhibitor_broken_end_LBR8_3prime <- read.delim("noinhibitor_broken_end_LBR8_3prime.txt", header=FALSE)
noinhibitor_broken_end_LBR8_3prime <- noinhibitor_broken_end_LBR8_3prime[,-1];

noinhibitor_broken_end_min_LBR8_3prime <- read.delim("noinhibitor_broken_end_min_LBR8_3prime.txt", header=FALSE)
noinhibitor_broken_end_min_LBR8_3prime <- noinhibitor_broken_end_min_LBR8_3prime[,-1];

noinhibitor_broken_end_minguide_LBR8_3prime <- read.delim("noinhibitor_broken_end_minguide_LBR8_3prime.txt", header=FALSE)
noinhibitor_broken_end_minguide_LBR8_3prime <- noinhibitor_broken_end_minguide_LBR8_3prime[,-1];

#5prime
noinhibitor_broken_end_LBR8_5prime <- read.delim("noinhibitor_broken_end_LBR8_5prime.txt", header=FALSE)
noinhibitor_broken_end_LBR8_5prime <- noinhibitor_broken_end_LBR8_5prime[,-1];

noinhibitor_broken_end_min_LBR8_5prime <- read.delim("noinhibitor_broken_end_min_LBR8_5prime.txt", header=FALSE)
noinhibitor_broken_end_min_LBR8_5prime <- noinhibitor_broken_end_min_LBR8_5prime[,-1];

noinhibitor_broken_end_minguide_LBR8_5prime <- read.delim("noinhibitor_broken_end_minguide_LBR8_5prime.txt", header=FALSE)
noinhibitor_broken_end_minguide_LBR8_5prime <- noinhibitor_broken_end_minguide_LBR8_5prime[,-1];

###################

##no inhibitor
#3prime
brokenfplus <- rowMeans(noinhibitor_broken_end_3prime, na.rm = T)
brokenfmin <- rowMeans(noinhibitor_broken_end_min_3prime, na.rm = T)
minguide <- rowMeans(noinhibitor_broken_end_minguide_3prime, na.rm = T)

sdplus <- apply(noinhibitor_broken_end_3prime,1,sd, na.rm = T)
sdmin <- apply(noinhibitor_broken_end_min_3prime, 1,sd, na.rm = T)
sdminguide <- apply(noinhibitor_broken_end_minguide_3prime, 1,sd, na.rm = T)

#5prime
brokenfplus_5 <- rowMeans(noinhibitor_broken_end_5prime, na.rm = T)
brokenfmin_5 <- rowMeans(noinhibitor_broken_end_min_5prime, na.rm = T)
minguide_5 <- rowMeans(noinhibitor_broken_end_minguide_5prime, na.rm = T)

sdplus_5 <- apply(noinhibitor_broken_end_5prime,1,sd, na.rm = T)
sdmin_5 <- apply(noinhibitor_broken_end_min_5prime, 1,sd, na.rm = T)
sdminguide_5 <- apply(noinhibitor_broken_end_minguide_5prime, 1,sd, na.rm = T)

#LBR2 #3+5
brokenfplus3_5 <- rowMeans(cbind(noinhibitor_broken_end_3prime,noinhibitor_broken_end_5prime ), na.rm = T)
brokenfmin3_5 <- rowMeans(cbind(noinhibitor_broken_end_min_3prime,noinhibitor_broken_end_min_5prime), na.rm = T)
minguide3_5 <- rowMeans(cbind(noinhibitor_broken_end_minguide_3prime,noinhibitor_broken_end_minguide_5prime), na.rm = T)

sdplus3_5 <- apply(cbind(noinhibitor_broken_end_3prime,noinhibitor_broken_end_5prime),1,sd, na.rm = T)
sdmin3_5 <- apply(cbind(noinhibitor_broken_end_min_3prime,noinhibitor_broken_end_min_5prime), 1,sd, na.rm = T)
sdminguide3_5 <- apply(cbind(noinhibitor_broken_end_minguide_3prime,noinhibitor_broken_end_minguide_5prime), 1,sd, na.rm = T)


###inputPCR
#3prime
brokenfplus_inputPCR <- rowMeans(noinhibitor_broken_end_3prime_inputPCR, na.rm = T)
brokenfmin_inputPCR <- rowMeans(noinhibitor_broken_end_min_3prime_inputPCR, na.rm = T)
minguide_inputPCR <- rowMeans(noinhibitor_broken_end_minguide_3prime_inputPCR, na.rm = T)

sdplus_inputPCR <- apply(noinhibitor_broken_end_3prime_inputPCR,1,sd, na.rm = T)
sdmin_inputPCR <- apply(noinhibitor_broken_end_min_3prime_inputPCR, 1,sd, na.rm = T)
sdminguide_inputPCR <- apply(noinhibitor_broken_end_minguide_3prime_inputPCR, 1,sd, na.rm = T)

#5prime
brokenfplus_5_inputPCR <- rowMeans(noinhibitor_broken_end_5prime_inputPCR, na.rm = T)
brokenfmin_5_inputPCR <- rowMeans(noinhibitor_broken_end_min_5prime_inputPCR, na.rm = T)
minguide_5_inputPCR <- rowMeans(noinhibitor_broken_end_minguide_5prime_inputPCR, na.rm = T)

sdplus_5_inputPCR <- apply(noinhibitor_broken_end_5prime_inputPCR,1,sd, na.rm = T)
sdmin_5_inputPCR <- apply(noinhibitor_broken_end_min_5prime_inputPCR, 1,sd, na.rm = T)
sdminguide_5_inputPCR <- apply(noinhibitor_broken_end_minguide_5prime_inputPCR, 1,sd, na.rm = T)

##with inhibitor
brokenfplusN <- rowMeans(withinhibitor_broken_end_3prime, na.rm = T)
brokenfminN <- rowMeans(withinhibitor_broken_end_min_3prime, na.rm = T)
minguideN <- rowMeans(withinhibitor_broken_end_minguide_3prime, na.rm = T)

sdplusN <- apply(withinhibitor_broken_end_3prime,1,sd, na.rm = T)
sdminN <- apply(withinhibitor_broken_end_min_3prime, 1,sd, na.rm = T)
sdminguideN <- apply(withinhibitor_broken_end_minguide_3prime, 1,sd, na.rm = T)

#inputPCR
brokenfplusN_inputPCR <- rowMeans(withinhibitor_broken_end_3prime_inputPCR, na.rm = T)
brokenfminN_inputPCR <- rowMeans(withinhibitor_broken_end_min_3prime_inputPCR, na.rm = T)
minguideN_inputPCR <- rowMeans(withinhibitor_broken_end_minguide_3prime_inputPCR, na.rm = T)

sdplusN_inputPCR <- apply(withinhibitor_broken_end_3prime_inputPCR,1,sd, na.rm = T)
sdminN_inputPCR <- apply(withinhibitor_broken_end_min_3prime_inputPCR, 1,sd, na.rm = T)
sdminguideN_inputPCR <- apply(withinhibitor_broken_end_minguide_3prime_inputPCR, 1,sd, na.rm = T)


########## 
#no inhibitor

brokenfraction_D <- data.frame(timeb=timeb, brokenf=brokenfplus, sd=sdplus)
brokenfraction_Dm <- data.frame(timemin=timemin, brokenfmin=brokenfmin, sdmin=sdmin)
brokenfraction_Dmg <- data.frame(timeming=timeming, minguide=minguide, sdminguide=sdminguide)


# put on min max data range
rangecolor <- rgb(30,144,255,alpha=80,maxColorValue=255)
minmaxbro=t(apply(matrix(unlist(lapply(noinhibitor_total_individual_series,function(x){x$broken})),ncol=length(noinhibitor_total_individual_series)),1,range));

plot(main='w/o NU7441 LBR2 3prime',seq(0,max(timeb),0.1),minmaxbro[,2]*100,col='white',type='l',lwd=4,ylim=c(-0.05,1.5),xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="a.u")

# fitting the curve
FL=brokenendPkfit(timeb, brokenfraction_D$brokenf);

# add experimental data
with (
  data = brokenfraction_D
  , expr = errbar(timeb, brokenf/max(FL[[2]]), (brokenf/max(FL[[2]])+sd/max(FL[[2]])), (brokenf/max(FL[[2]])-sd/max(FL[[2]])), add=T, pch=20, cap=.01, col=4,cex=1.5)
)

with (
  data = brokenfraction_Dm
  , expr = errbar(timemin, brokenfmin/max(FL[[2]]), (brokenfmin/max(FL[[2]])+sdmin/max(FL[[2]])), (brokenfmin/max(FL[[2]])-sdmin/max(FL[[2]])), add=T, pch=20, cap=.01, col="grey",cex=1.5)
)

with (
  data = brokenfraction_Dmg
  , expr = errbar(timeming, minguide/max(FL[[2]]), (minguide/max(FL[[2]])+sdminguide/max(FL[[2]])), (minguide/max(FL[[2]])-sdminguide/max(FL[[2]])), add=T, pch=20, cap=.01, col=1,cex=1.5)
)

lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]),col=4);

abline(v=seq(0,max(timeb),0.1)[which.max(FL[[2]])],col=4,lty=2,lwd=2)

abline(v=optimalParaR[[2]],lty=2,col=rangecolor,lwd=2)

l=legend("topright", legend=c("+shield", "-shield", "-guide +shield",'minmax(prediction)'), pch=c(16, 16, 16,17), pt.cex=c(1,1,1,1),col=c(4, "grey", 1,rangecolor), pt.bg =rangecolor, text.col=c(1, 1, 1,1),bty="n")


text(pos=4,l$text$x[1],min(l$text$y)+(diff(l$text$y)[1]),paste('peak(exp) =',seq(0,max(timeb),0.1)[which.max(FL[[2]])],'h',sep=''),col=4)

text(pos=4,l$text$x[1],min(l$text$y)+2*(diff(l$text$y)[1]),paste('peak(prd) =',optimalParaR[[2]],'h',sep=''),col=rangecolor)

noinhibitorPeak = c(seq(0,max(timeb),0.1)[which.max(FL[[2]])],optimalParaR[[2]])



##################################################
#invividual series fitting, expected shape fitting
##################################################

pbe= rep(0,ncol(noinhibitor_broken_end_3prime));

for (i in 1:ncol(noinhibitor_broken_end_3prime)){
  Y=noinhibitor_broken_end_3prime[,i];
  FL=brokenendPkfit(timeb[is.finite(timeb+Y)], Y[is.finite(timeb+Y)]);

  plot(main=paste('w/o NU7441 LBR2 3 prime exp',i),timeb,Y/max(FL[[2]]),pch=16,xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="broken fraction (a.u.)")
  lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]));
  pbe[i]=seq(0,max(timeb),0.1)[which.max(FL[[2]])];
  legend('topright',legend=bquote(tau == .(round(pbe[i],1))),bty='n');
  abline(lwd=2,v=pbe[i],lty=2);
}

mean(pbe)
sd(pbe)

##################################################
#average fitting, expected shape fitting
##################################################

# put on min max data range
rangecolor <- rgb(30,144,255,alpha=80,maxColorValue=255)
minmaxbro=t(apply(matrix(unlist(lapply(noinhibitor_total_individual_series,function(x){x$broken})),ncol=length(noinhibitor_total_individual_series)),1,range));

plot(main='w/o NU7441',seq(0,max(timeb),0.1),minmaxbro[,2]*100,col='white',type='l',lwd=4,ylim=c(-0.05,1.5),xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="broken fraction (a.u.)")

polygon(sort(rep(c(mean(sapply(noinhibitor_total_individual_series,function(x){x$peakBro}))-sd(sapply(noinhibitor_total_individual_series,function(x){x$peakBro})),mean(sapply(noinhibitor_total_individual_series,function(x){x$peakBro}))+sd(sapply(noinhibitor_total_individual_series,function(x){x$peakBro}))),2)),c(-100,100,100,-100),col=rangecolor,border=rangecolor)
prm=mean(sapply(noinhibitor_total_individual_series,function(x){x$peakBro}));
sdm=sd(sapply(noinhibitor_total_individual_series,function(x){x$peakBro}));

print(prm)
print(sdm)

#shading
pbe1=mean(pbe)-sd(pbe)

pbe2=mean(pbe)+sd(pbe)

polygon(sort(c(pbe1,pbe2,pbe1,pbe2)),c(-100,100,100,-100),col=rgb(0,0,1,0.5),border=rgb(0,0,1,0.5))

#fit
Y=brokenfraction_D$brokenf
FL=brokenendPkfit(timeb, Y);

# add experimental data
with (
  data = brokenfraction_D
  , expr = errbar(timeb, brokenf/max(FL[[2]]), (brokenf/max(FL[[2]])+sd/max(FL[[2]])), (brokenf/max(FL[[2]])-sd/max(FL[[2]])), add=T, pch=20, cap=.01, col=4,cex=1.5)
)

with (
  data = brokenfraction_Dm
  , expr = errbar(timemin, brokenfmin/max(FL[[2]]), (brokenfmin/max(FL[[2]])+sdmin/max(FL[[2]])), (brokenfmin/max(FL[[2]])-sdmin/max(FL[[2]])), add=T, pch=20, cap=.01, col="grey",cex=1.5)
)

with (
  data = brokenfraction_Dmg
  , expr = errbar(timeming, minguide/max(FL[[2]]), (minguide/max(FL[[2]])+sdminguide/max(FL[[2]])), (minguide/max(FL[[2]])-sdminguide/max(FL[[2]])), add=T, pch=20, cap=.01, col=1,cex=1.5)
)

lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]),col=4);
l=legend("topright", legend=c("+shield", "-shield", "-guide +shield",expression(tau['prediction']),expression(tau['measurement'])), pch=c(16, 16, 16,15,15), pt.cex=c(1,1,1,1),col=c(4, "grey", 1,rangecolor,rgb(0,0,1,0.5)), text.col=c(1, 1, 1, 1),bty="n")



########## 
#no inhibitor 5 prime

brokenfraction_D5 <- data.frame(timeb=timeb, brokenf=brokenfplus_5, sd=sdplus_5)
brokenfraction_Dm5 <- data.frame(timemin=timemin, brokenfmin=brokenfmin_5, sdmin=sdmin_5)
brokenfraction_Dmg5 <- data.frame(timeming=timeming, minguide=minguide_5, sdminguide=sdminguide_5)


# put on min max data range
rangecolor <- rgb(30,144,255,alpha=80,maxColorValue=255)
minmaxbro=t(apply(matrix(unlist(lapply(noinhibitor_total_individual_series,function(x){x$broken})),ncol=length(noinhibitor_total_individual_series)),1,range));

plot(main='w/o NU7441 LBR2 5prime',seq(0,max(timeb),0.1),minmaxbro[,2]*100,col='white',type='l',lwd=4,ylim=c(-0.05,1.5),xlim=range(c(timeb,timeming)),xlab="tim (h)", ylab="broken (%)")

# fitting the curve
FL=brokenendPkfit(timeb, brokenfraction_D5$brokenf);

# add experimental data
with (
  data = brokenfraction_D5
  , expr = errbar(timeb, brokenf/max(FL[[2]]), (brokenf/max(FL[[2]])+sd/max(FL[[2]])), (brokenf/max(FL[[2]])-sd/max(FL[[2]])), add=T, pch=20, cap=.01, col=4,cex=1.5)
)

with (
  data = brokenfraction_Dm5
  , expr = errbar(timemin, brokenfmin/max(FL[[2]]), (brokenfmin/max(FL[[2]])+sdmin/max(FL[[2]])), (brokenfmin/max(FL[[2]])-sdmin/max(FL[[2]])), add=T, pch=20, cap=.01, col="grey",cex=1.5)
)

with (
  data = brokenfraction_Dmg5
  , expr = errbar(timeming, minguide/max(FL[[2]]), (minguide/max(FL[[2]])+sdminguide/max(FL[[2]])), (minguide/max(FL[[2]])-sdminguide/max(FL[[2]])), add=T, pch=20, cap=.01, col=1,cex=1.5)
)

lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]),col=4);

abline(v=seq(0,max(timeb),0.1)[which.max(FL[[2]])],col=4,lty=2,lwd=2)

abline(v=optimalParaR[[2]],lty=2,col=rangecolor,lwd=2)

l=legend("topright", legend=c("+shield", "-shield", "-guide +shield",'minmax(prediction)'), pch=c(16, 16, 16,17), pt.cex=c(1,1,1,1),col=c(4, "grey", 1,rangecolor), pt.bg =rangecolor, text.col=c(1, 1, 1,1),bty="n")


text(pos=4,l$text$x[1],min(l$text$y)+(diff(l$text$y)[1]),paste('peak(exp) =',seq(0,max(timeb),0.1)[which.max(FL[[2]])],'h',sep=''),col=4)

text(pos=4,l$text$x[1],min(l$text$y)+2*(diff(l$text$y)[1]),paste('peak(prd) =',optimalParaR[[2]],'h',sep=''),col=rangecolor)

noinhibitorPeak = c(seq(0,max(timeb),0.1)[which.max(FL[[2]])],optimalParaR[[2]])



##################################################
#invividual series fitting, expected shape fitting
##################################################

pbe= rep(0,ncol(noinhibitor_broken_end_5prime));

for (i in 1:ncol(noinhibitor_broken_end_5prime)){
  Y=noinhibitor_broken_end_5prime[,i];
  FL=brokenendPkfit(timeb[is.finite(timeb+Y)], Y[is.finite(timeb+Y)]);

  plot(main=paste('w/o NU7441 LBR2 5prime exp',i),timeb,Y/max(FL[[2]]),pch=16,xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="broken fraction (a.u.)")
  lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]));
  pbe[i]=seq(0,max(timeb),0.1)[which.max(FL[[2]])];
  legend('topright',legend=bquote(tau == .(round(pbe[i],1))),bty='n');
  abline(lwd=2,v=pbe[i],lty=2);
}

mean(pbe)
sd(pbe)

##################################################
#average fitting, expected shape fitting
##################################################

# put on min max data range
rangecolor <- rgb(30,144,255,alpha=80,maxColorValue=255)
minmaxbro=t(apply(matrix(unlist(lapply(noinhibitor_total_individual_series,function(x){x$broken})),ncol=length(noinhibitor_total_individual_series)),1,range));

plot(main='w/o NU7441 LBR2 5prime',seq(0,max(timeb),0.1),minmaxbro[,2]*100,col='white',type='l',lwd=4,ylim=c(-0.05,1.5),xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="broken fraction (a.u.)")

polygon(sort(rep(c(mean(sapply(noinhibitor_total_individual_series,function(x){x$peakBro}))-sd(sapply(noinhibitor_total_individual_series,function(x){x$peakBro})),mean(sapply(noinhibitor_total_individual_series,function(x){x$peakBro}))+sd(sapply(noinhibitor_total_individual_series,function(x){x$peakBro}))),2)),c(-100,100,100,-100),col=rangecolor,border=rangecolor)
prm=mean(sapply(noinhibitor_total_individual_series,function(x){x$peakBro}));
sdm=sd(sapply(noinhibitor_total_individual_series,function(x){x$peakBro}));

print(prm)
print(sdm)

#shading
pbe1=mean(pbe)-sd(pbe)

pbe2=mean(pbe)+sd(pbe)

polygon(sort(c(pbe1,pbe2,pbe1,pbe2)),c(-100,100,100,-100),col=rgb(0,0,1,0.5),border=rgb(0,0,1,0.5))

#fit
Y=brokenfraction_D5$brokenf
FL=brokenendPkfit(timeb, Y);

# add experimental data
with (
  data = brokenfraction_D5
  , expr = errbar(timeb, brokenf/max(FL[[2]]), (brokenf/max(FL[[2]])+sd/max(FL[[2]])), (brokenf/max(FL[[2]])-sd/max(FL[[2]])), add=T, pch=20, cap=.01, col=4,cex=1.5)
)

with (
  data = brokenfraction_Dm5
  , expr = errbar(timemin, brokenfmin/max(FL[[2]]), (brokenfmin/max(FL[[2]])+sdmin/max(FL[[2]])), (brokenfmin/max(FL[[2]])-sdmin/max(FL[[2]])), add=T, pch=20, cap=.01, col="grey",cex=1.5)
)

with (
  data = brokenfraction_Dmg5
  , expr = errbar(timeming, minguide/max(FL[[2]]), (minguide/max(FL[[2]])+sdminguide/max(FL[[2]])), (minguide/max(FL[[2]])-sdminguide/max(FL[[2]])), add=T, pch=20, cap=.01, col=1,cex=1.5)
)

lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]),col=4);
l=legend("topright", legend=c("+shield", "-shield", "-guide +shield",expression(tau['prediction']),expression(tau['measurement'])), pch=c(16, 16, 16,15,15), pt.cex=c(1,1,1,1),col=c(4, "grey", 1,rangecolor,rgb(0,0,1,0.5)), text.col=c(1, 1, 1, 1),bty="n")

pbeD=pbe;


########## with inhibitor

brokenfraction_N <- data.frame(timeb=timeb, brokenf=brokenfplusN, sd=sdplusN)
brokenfraction_Nm <- data.frame(timemin=timemin, brokenfmin=brokenfminN, sdmin=sdminN)
brokenfraction_Nmg <- data.frame(timeming=timeming, minguide=minguideN, sdminguide=sdminguideN)

# put on min max data range
rangecolor <- rgb(220,100,0,alpha=80,maxColorValue=255)
minmaxbro=t(apply(matrix(unlist(lapply(withinhibitor_total_individual_series,function(x){x$broken})),ncol=length(withinhibitor_total_individual_series)),1,range));

plot(main='with NU7441',seq(0,max(timeb),0.1),minmaxbro[,2]*100,col='white',type='l',lwd=4,ylim=c(-0.05,1.5),xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="a.u")

# fitting the curve
FL=brokenendPkfit(timeb, brokenfraction_N$brokenf);

# add experimental data
with (
  data = brokenfraction_N
  , expr = errbar(timeb, brokenf/max(FL[[2]]), (brokenf/max(FL[[2]])+sd/max(FL[[2]])), (brokenf/max(FL[[2]])-sd/max(FL[[2]])), add=T, pch=20, cap=.01, col=2,cex=1.5)
)

with (
  data = brokenfraction_Nm
  , expr = errbar(timemin, brokenfmin/max(FL[[2]]), (brokenfmin/max(FL[[2]])+sdmin/max(FL[[2]])), (brokenfmin/max(FL[[2]])-sdmin/max(FL[[2]])), add=T, pch=20, cap=.01, col="grey",cex=1.5)
)

with (
  data = brokenfraction_Nmg
  , expr = errbar(timeming, minguide/max(FL[[2]]), (minguide/max(FL[[2]])+sdminguide/max(FL[[2]])), (minguide/max(FL[[2]])-sdminguide/max(FL[[2]])), add=T, pch=20, cap=.01, col=1,cex=1.5)
)

lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]),col=2);

abline(v=seq(0,max(timeb),0.1)[which.max(FL[[2]])],col=2,lty=2,lwd=2)

opPB =ZLWB2PiledupOMMerge(as.numeric(row.names(wildtype_tot_LBR2)),wt_2,indel_2)[[2]];
abline(v=opPB,lty=2,col=rangecolor,lwd=2)

l=legend("topright", legend=c("+shield", "-shield", "-guide +shield",'minmax(prediction)'), pch=c(16, 16, 16,17), pt.cex=c(1,1,1,1),col=c(2, "grey", 1,rangecolor), pt.bg =rangecolor, text.col=c(1, 1, 1,1),bty="n")

text(pos=4,l$text$x[1],min(l$text$y)+(diff(l$text$y)[1]),paste('peak(exp) =',seq(0,max(timeb),0.1)[which.max(FL[[2]])],'h',sep=''),col=2)

text(pos=4,l$text$x[1],min(l$text$y)+2*(diff(l$text$y)[1]),paste('peak(prd) =',opPB,'h',sep=''),col=rangecolor)

withinhibitorPeak = c(seq(0,max(timeb),0.1)[which.max(FL[[2]])],opPB);


##################################################
#individual series fitting, expected shape fitting

######invividual series fitting, expected shape fitting
withinhibitor_broken_end_3prime <- read.delim("withinhibitor_broken_end_3prime.txt", header=FALSE)
withinhibitor_broken_end_3prime = withinhibitor_broken_end_3prime[,-1];
pbe= rep(0,ncol(withinhibitor_broken_end_3prime));

for (i in 1:ncol(withinhibitor_broken_end_3prime)){
  Y=withinhibitor_broken_end_3prime[,i];
  FL=brokenendPkfit(timeb[is.finite(timeb+Y)], Y[is.finite(timeb+Y)]);
  
  plot(main=paste('with NU7441 exp',i),timeb,Y/max(FL[[2]]),pch=16,xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="broken fraction (a.u.)")
  lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]));
  pbe[i]=seq(0,max(timeb),0.1)[which.max(FL[[2]])];
  legend('topright',legend=bquote(tau == .(round(pbe[i],1))),bty='n');
  abline(lwd=2,v=pbe[i],lty=2);
}

mean(pbe)
sd(pbe)

##################################################
#average fitting, expected shape fitting
##################################################

# put on min max data range
rangecolor <- rgb(220,100,0,alpha=80,maxColorValue=255)
minmaxbro=t(apply(matrix(unlist(lapply(withinhibitor_total_individual_series,function(x){x$broken})),ncol=length(withinhibitor_total_individual_series)),1,range));

plot(main='with NU7441',seq(0,max(timeb),0.1),minmaxbro[,2]*100,col='white',type='l',lwd=4,ylim=c(-0.05,1.5),xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="broken fraction (a.u.)")

polygon(sort(rep(c(mean(sapply(withinhibitor_total_individual_series,function(x){x$peakBro}))-sd(sapply(withinhibitor_total_individual_series,function(x){x$peakBro})),mean(sapply(withinhibitor_total_individual_series,function(x){x$peakBro}))+sd(sapply(withinhibitor_total_individual_series,function(x){x$peakBro}))),2)),c(-100,100,100,-100),col=rangecolor,border=rangecolor)
prm=mean(sapply(withinhibitor_total_individual_series,function(x){x$peakBro}));
sdm=sd(sapply(withinhibitor_total_individual_series,function(x){x$peakBro}));

print(prm)
print(sdm)

#shading
pbe1=mean(pbe)-sd(pbe)

pbe2=mean(pbe)+sd(pbe)

polygon(sort(c(pbe1,pbe2,pbe1,pbe2)),c(-100,100,100,-100),col=rgb(1,0,0,0.5),border=rgb(1,0,0,0.5))

#fit
Y=brokenfraction_N$broken
FL=brokenendPkfit(timeb, Y);

# add experimental data
with (
  data = brokenfraction_N
  , expr = errbar(timeb, brokenf/max(FL[[2]]), (brokenf/max(FL[[2]])+sd/max(FL[[2]])), (brokenf/max(FL[[2]])-sd/max(FL[[2]])), add=T, pch=20, cap=.01, col=2,cex=1.5)
)

with (
  data = brokenfraction_Nm
  , expr = errbar(timemin, brokenfmin/max(FL[[2]]), (brokenfmin/max(FL[[2]])+sdmin/max(FL[[2]])), (brokenfmin/max(FL[[2]])-sdmin/max(FL[[2]])), add=T, pch=20, cap=.01, col="grey",cex=1.5)
)

with (
  data = brokenfraction_Nmg
  , expr = errbar(timeming, minguide/max(FL[[2]]), (minguide/max(FL[[2]])+sdminguide/max(FL[[2]])), (minguide/max(FL[[2]])-sdminguide/max(FL[[2]])), add=T, pch=20, cap=.01, col=1,cex=1.5)
)

lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]),col=2);
l=legend("topright", legend=c("+shield", "-shield", "-guide +shield",expression(tau['prediction']),expression(tau['measurement'])), pch=c(16, 16, 16,15,15), pt.cex=c(1,1,1,1),col=c(2, "grey", 1,rangecolor,rgb(1,0,0,0.5)), text.col=c(1, 1, 1,1),bty="n")


######################################################################## 
#+/- inhibitor
########################################################################

# put on min max data range
rangecolor <- rgb(220,100,0,alpha=80,maxColorValue=255)
minmaxbro=t(apply(matrix(unlist(lapply(withinhibitor_total_individual_series,function(x){x$broken})),ncol=length(withinhibitor_total_individual_series)),1,range));

plot(main='wo/with NU7441',seq(0,max(timeb),0.1),minmaxbro[,2]*100,col='white',type='l',lwd=4,ylim=c(-0.05,1.5),xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="a.u")

# fitting the curve
FL=brokenendPkfit(timeb, brokenfraction_D$brokenf);
FL2=brokenendPkfit(timeb, brokenfraction_N$brokenf);

# add experimental data
with (
  data = brokenfraction_D
  , expr = errbar(timeb, brokenf/max(FL[[2]]), (brokenf/max(FL[[2]])+sd/max(FL[[2]])), (brokenf/max(FL[[2]])-sd/max(FL[[2]])), add=T, pch=20, cap=.01, col=4,cex=1.5)
)

with (
  data = brokenfraction_Dm
  , expr = errbar(timemin, brokenfmin/max(FL[[2]]), (brokenfmin/max(FL[[2]])+sdmin/max(FL[[2]])), (brokenfmin/max(FL[[2]])-sdmin/max(FL[[2]])), add=T, pch=20, cap=.01, col="grey",cex=1.5)
)

with (
  data = brokenfraction_Dmg
  , expr = errbar(timeming, minguide/max(FL[[2]]), (minguide/max(FL[[2]])+sdminguide/max(FL[[2]])), (minguide/max(FL[[2]])-sdminguide/max(FL[[2]])), add=T, pch=20, cap=.01, col=1,cex=1.5)
)

with (
  data = brokenfraction_N
  , expr = errbar(timeb, brokenf/max(FL2[[2]]), (brokenf/max(FL2[[2]])+sd/max(FL[[2]])), (brokenf/max(FL2[[2]])-sd/max(FL[[2]])), add=T, pch=20, cap=.01, col=2,cex=1.5)
)

with (
  data = brokenfraction_Nm
  , expr = errbar(timemin, brokenfmin/max(FL2[[2]]), (brokenfmin/max(FL2[[2]])+sdmin/max(FL[[2]])), (brokenfmin/max(FL2[[2]])-sdmin/max(FL[[2]])), add=T, pch=20, cap=.01, col=5,cex=1.5)
)

lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]),col=4);

abline(v=seq(0,max(timeb),0.1)[which.max(FL[[2]])],col=4,lty=2,lwd=2)

lines(seq(0,max(timeb),0.1),FL2[[2]]/max(FL2[[2]]),col=2);

abline(v=seq(0,max(timeb),0.1)[which.max(FL2[[2]])],col=2,lty=2,lwd=2)

l=legend("topright", legend=c("w/o NU7441 +shield", "w/o NU7441 -shield", "w NU7441 +shield", "w NU7441 -shield", "-guide +shield"), pch=c(16, 16, 16,16, 16), pt.cex=c(1,1,1,1,1),col=c(4, "grey", 2, 5, 1), pt.bg =rangecolor, text.col=c(1, 1, 1,1,1),bty="n")

text(pos=4,l$text$x[1],min(l$text$y)+(diff(l$text$y)[1]),paste('peak(exp) =',seq(0,max(timeb),0.1)[which.max(FL[[2]])],'h',sep=''),col=4)

text(pos=4,l$text$x[1],min(l$text$y)+2+(diff(l$text$y)[1]),paste('peak(exp) =',seq(0,max(timeb),0.1)[which.max(FL2[[2]])],'h',sep=''),col=2)


##################################################
#individual series fitting, expected shape fitting
##################################################

#w/o inhitibotr
pbeD= rep(0,ncol(noinhibitor_broken_end_3prime));

for (i in 1:ncol(noinhibitor_broken_end_3prime)){
  Y=noinhibitor_broken_end_3prime[,i];
  FL=brokenendPkfit(timeb[is.finite(timeb+Y)], Y[is.finite(timeb+Y)]);
  
  plot(main=paste('w/o NU7441 exp',i),timeb,Y/max(FL[[2]]),pch=16,xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="broken fraction (a.u.)")
  lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]));
  pbeD[i]=seq(0,max(timeb),0.1)[which.max(FL[[2]])];
  legend('topright',legend=bquote(tau == .(round(pbeD[i],1))),bty='n');
  abline(lwd=2,v=pbeD[i],lty=2);
}

mean(pbeD)
sd(pbeD)

#with inhitibotr
pbeN= rep(0,ncol(withinhibitor_broken_end_3prime));

for (i in 1:ncol(withinhibitor_broken_end_3prime)){
  Y=withinhibitor_broken_end_3prime[,i];
  FL=brokenendPkfit(timeb[is.finite(timeb+Y)], Y[is.finite(timeb+Y)]);
  
  plot(main=paste('with NU7441 exp',i),timeb,Y/max(FL[[2]]),pch=16,xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="broken fraction (a.u.)")
  lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]));
  pbeN[i]=seq(0,max(timeb),0.1)[which.max(FL[[2]])];
  legend('topright',legend=bquote(tau == .(round(pbeN[i],1))),bty='n');
  abline(lwd=2,v=pbeD[i],lty=2);
}

mean(pbeN)
sd(pbeN)

##################################################
#average fitting, expected shape fitting
##################################################

# put on min max data range
rangecolor <- rgb(220,100,0,alpha=80,maxColorValue=255)
minmaxbro=t(apply(matrix(unlist(lapply(withinhibitor_total_individual_series,function(x){x$broken})),ncol=length(withinhibitor_total_individual_series)),1,range));

plot(main='w/o & with NU7441',seq(0,max(timeb),0.1),minmaxbro[,2]*100,col='white',type='l',lwd=4,ylim=c(-0.05,1.5),xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="broken fraction (a.u.)")


#shading
pbe1=mean(pbeD)-sd(pbeD)

pbe2=mean(pbeD)+sd(pbeD)

polygon(sort(c(pbe1,pbe2,pbe1,pbe2)),c(-100,100,100,-100),col=rgb(0,0,1,0.5),border=rgb(0,0,1,0.5))

#shading
pbeN1=mean(pbeN)-sd(pbeN)

pbeN2=mean(pbeN)+sd(pbeN)

polygon(sort(c(pbeN1,pbeN2,pbeN1,pbeN2)),c(-100,100,100,-100),col=rgb(1,0,0,0.5),border=rgb(1,0,0,0.5))

# fitting the curve
FL=brokenendPkfit(timeb, brokenfraction_D$brokenf);
FL2=brokenendPkfit(timeb, brokenfraction_N$brokenf);

# add experimental data
with (
  data = brokenfraction_D
  , expr = errbar(timeb, brokenf/max(FL[[2]]), (brokenf/max(FL[[2]])+sd/max(FL[[2]])), (brokenf/max(FL[[2]])-sd/max(FL[[2]])), add=T, pch=20, cap=.01, col=4,cex=1.5)
)

with (
  data = brokenfraction_Dm
  , expr = errbar(timemin, brokenfmin/max(FL[[2]]), (brokenfmin/max(FL[[2]])+sdmin/max(FL[[2]])), (brokenfmin/max(FL[[2]])-sdmin/max(FL[[2]])), add=T, pch=20, cap=.01, col="grey",cex=1.5)
)

with (
  data = brokenfraction_Dmg
  , expr = errbar(timeming, minguide/max(FL[[2]]), (minguide/max(FL[[2]])+sdminguide/max(FL[[2]])), (minguide/max(FL[[2]])-sdminguide/max(FL[[2]])), add=T, pch=20, cap=.01, col=1,cex=1.5)
)

with (
  data = brokenfraction_N
  , expr = errbar(timeb, brokenf/max(FL2[[2]]), (brokenf/max(FL2[[2]])+sd/max(FL[[2]])), (brokenf/max(FL2[[2]])-sd/max(FL[[2]])), add=T, pch=20, cap=.01, col=2,cex=1.5)
)

with (
  data = brokenfraction_Nm
  , expr = errbar(timemin, brokenfmin/max(FL2[[2]]), (brokenfmin/max(FL2[[2]])+sdmin/max(FL[[2]])), (brokenfmin/max(FL2[[2]])-sdmin/max(FL[[2]])), add=T, pch=20, cap=.01, col=5,cex=1.5)
)


lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]),col=4);
lines(seq(0,max(timeb),0.1),FL2[[2]]/max(FL2[[2]]),col=2);
l=legend("topright", legend=c("w/o NU7441 +shield", "w/o NU7441 -shield", "with NU7441 +shield", "with NU7441 -shield", "-guide +shield",expression(tau['w/o measurement']), expression(tau['with measurement'])), pch=c(16, 16, 16,16,16,15,15), pt.cex=c(1,1,1,1,1,1),col=c(4, "grey", 2, 5, 1,rangecolor, rgb(0,0,1,0.5), rangecolor,rgb(1,0,0,0.5)), text.col=c(1, 1, 1,1,1,1),bty="n")

t.test(pbeD, pbeN)
wilcox.test(pbeD, pbeN)

#####

# barplot
noinhibitorPeak=c(mean(pbeD),mean(sapply(noinhibitor_total_individual_series,function(x){x$peakBro})))
withinhibitorPeak=c(mean(pbeN),mean(sapply(withinhibitor_total_individual_series,function(x){x$peakBro})))

combPeak = t(matrix(c(noinhibitorPeak,withinhibitorPeak),2));
colnames(combPeak )=c('measurement','prediction')
combPeak =combPeak [,c(2,1)];

batp  = barplot(combPeak,beside=TRUE,col=c(4,2),ylab=expression(tau* ' (h)'),ylim=c(0,30))

# add error bar
errbar(as.numeric(batp),as.numeric(combPeak),as.numeric(combPeak)-c(sd(sapply(noinhibitor_total_individual_series,function(x){x$peakBro})),
sd(sapply(withinhibitor_total_individual_series,function(x){x$peakBro})),
sd(pbeD),sd(pbeN)),as.numeric(combPeak)+c(sd(sapply(noinhibitor_total_individual_series,function(x){x$peakBro})),
sd(sapply(withinhibitor_total_individual_series,function(x){x$peakBro})),
sd(pbeD),sd(pbeN)),add=TRUE,pch='',lwd=2)

legend("topright", 
       legend = c("w/o NU7441", "with NU7441"), 
       fill = c(4, 2),bty='n')

###############################################################
#input PCR
###############################################################

#no inhibitor #3 prime

brokenfraction_D_inputPCR <- data.frame(timeb=timeb, brokenf=brokenfplus_inputPCR, sd=sdplus_inputPCR)
brokenfraction_Dm_inputPCR <- data.frame(timemin=timemin, brokenfmin=brokenfmin_inputPCR, sdmin=sdmin_inputPCR)
brokenfraction_Dmg_inputPCR <- data.frame(timeming=timeming, minguide=minguide_inputPCR, sdminguide=sdminguide_inputPCR)


# put on min max data range
rangecolor <- rgb(30,144,255,alpha=80,maxColorValue=255)
minmaxbro=t(apply(matrix(unlist(lapply(noinhibitor_total_individual_series,function(x){x$broken})),ncol=length(noinhibitor_total_individual_series)),1,range));

plot(main='w/o NU7441 input LBR2 3prime',seq(0,max(timeb),0.1),minmaxbro[,2]*100,col='white',type='l',lwd=4,ylim=c(-0.05,1.5),xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="intensity (a.u)")

with (
  data = brokenfraction_D_inputPCR
  , expr = errbar(timeb, brokenf/max(brokenfraction_D_inputPCR$brokenf), (brokenf/max(brokenfraction_D_inputPCR$brokenf)+sd/max(brokenfraction_D_inputPCR$brokenf)), (brokenf/max(brokenfraction_D_inputPCR$brokenf)-sd/max(brokenfraction_D_inputPCR$brokenf)), add=T, pch=20, cap=.01, col=4,cex=1.5)
)

with (
  data = brokenfraction_Dm_inputPCR
  , expr = errbar(timemin, brokenfmin/max(brokenfraction_D_inputPCR$brokenf), (brokenfmin/max(brokenfraction_D_inputPCR$brokenf)+sdmin/max(brokenfraction_D_inputPCR$brokenf)), (brokenfmin/max(brokenfraction_D_inputPCR$brokenf)-sdmin/max(brokenfraction_D_inputPCR$brokenf)), add=T, pch=20, cap=.01, col="grey",cex=1.5)
)

with (
  data = brokenfraction_Dmg_inputPCR
  , expr = errbar(timeming, minguide/max(brokenfraction_D_inputPCR$brokenf), (minguide/max(brokenfraction_D_inputPCR$brokenf)+sdminguide/max(brokenfraction_D_inputPCR$brokenf)), (minguide/max(brokenfraction_D_inputPCR$brokenf)-sdminguide/max(brokenfraction_D_inputPCR$brokenf)), add=T, pch=20, cap=.01, col=1,cex=1.5)
) 


#no inhibitor #5 prime

brokenfraction_D5_inputPCR <- data.frame(timeb=timeb, brokenf=brokenfplus_5_inputPCR, sd=sdplus_5_inputPCR)
brokenfraction_Dm5_inputPCR <- data.frame(timemin=timemin, brokenfmin=brokenfmin_5_inputPCR, sdmin=sdmin_5_inputPCR)
brokenfraction_Dmg5_inputPCR <- data.frame(timeming=timeming, minguide=minguide_5_inputPCR, sdminguide=sdminguide_5_inputPCR)


# put on min max data range
rangecolor <- rgb(30,144,255,alpha=80,maxColorValue=255)
minmaxbro=t(apply(matrix(unlist(lapply(noinhibitor_total_individual_series,function(x){x$broken})),ncol=length(noinhibitor_total_individual_series)),1,range));

plot(main='w/o NU7441 input LBR2 5prime',seq(0,max(timeb),0.1),minmaxbro[,2]*100,col='white',type='l',lwd=4,ylim=c(-0.05,1.5),xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="intensity (a.u)")

with (
  data = brokenfraction_D5_inputPCR
  , expr = errbar(timeb, brokenf/max(brokenfraction_D5_inputPCR$brokenf), (brokenf/max(brokenfraction_D5_inputPCR$brokenf)+sd/max(brokenfraction_D5_inputPCR$brokenf)), (brokenf/max(brokenfraction_D5_inputPCR$brokenf)-sd/max(brokenfraction_D5_inputPCR$brokenf)), add=T, pch=20, cap=.01, col=4,cex=1.5)
)

with (
  data = brokenfraction_Dm5_inputPCR
  , expr = errbar(timemin, brokenfmin/max(brokenfraction_D5_inputPCR$brokenf), (brokenfmin/max(brokenfraction_D5_inputPCR$brokenf)+sdmin/max(brokenfraction_D5_inputPCR$brokenf)), (brokenfmin/max(brokenfraction_D5_inputPCR$brokenf)-sdmin/max(brokenfraction_D5_inputPCR$brokenf)), add=T, pch=20, cap=.01, col="grey",cex=1.5)
)

with (
  data = brokenfraction_Dmg5_inputPCR
  , expr = errbar(timeming, minguide/max(brokenfraction_D5_inputPCR$brokenf), (minguide/max(brokenfraction_D5_inputPCR$brokenf)+sdminguide/max(brokenfraction_D5_inputPCR$brokenf)), (minguide/max(brokenfraction_D5_inputPCR$brokenf)-sdminguide/max(brokenfraction_D5_inputPCR$brokenf)), add=T, pch=20, cap=.01, col=1,cex=1.5)
) 


#with inhibitor #3 prime

brokenfraction_N_inputPCR <- data.frame(timeb=timeb, brokenf=brokenfplusN_inputPCR, sd=sdplusN_inputPCR)
brokenfraction_Nm_inputPCR <- data.frame(timemin=timemin, brokenfmin=brokenfminN_inputPCR, sdmin=sdminN_inputPCR)
brokenfraction_Nmg_inputPCR <- data.frame(timeming=timeming, minguide=minguideN_inputPCR, sdminguide=sdminguideN_inputPCR)


# put on min max data range
rangecolor <- rgb(30,144,255,alpha=80,maxColorValue=255)
minmaxbro=t(apply(matrix(unlist(lapply(withinhibitor_total_individual_series,function(x){x$broken})),ncol=length(withinhibitor_total_individual_series)),1,range));

plot(main='NU7441 input 3prime',seq(0,max(timeb),0.1),minmaxbro[,2]*100,col='white',type='l',lwd=4,ylim=c(-0.05,1.5),xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="intensity (a.u)")

with (
  data = brokenfraction_N_inputPCR
  , expr = errbar(timeb, brokenf/max(brokenfraction_N_inputPCR$brokenf), (brokenf/max(brokenfraction_N_inputPCR$brokenf)+sd/max(brokenfraction_N_inputPCR$brokenf)), (brokenf/max(brokenfraction_N_inputPCR$brokenf)-sd/max(brokenfraction_N_inputPCR$brokenf)), add=T, pch=20, cap=.01, col=4,cex=1.5)
)

with (
  data = brokenfraction_Nm_inputPCR
  , expr = errbar(timemin, brokenfmin/max(brokenfraction_N_inputPCR$brokenf), (brokenfmin/max(brokenfraction_N_inputPCR$brokenf)+sdmin/max(brokenfraction_N_inputPCR$brokenf)), (brokenfmin/max(brokenfraction_N_inputPCR$brokenf)-sdmin/max(brokenfraction_N_inputPCR$brokenf)), add=T, pch=20, cap=.01, col="grey",cex=1.5)
)

with (
  data = brokenfraction_Nmg_inputPCR
  , expr = errbar(timeming, minguide/max(brokenfraction_N_inputPCR$brokenf), (minguide/max(brokenfraction_N_inputPCR$brokenf)+sdminguide/max(brokenfraction_N_inputPCR$brokenf)), (minguide/max(brokenfraction_N_inputPCR$brokenf)-sdminguide/max(brokenfraction_N_inputPCR$brokenf)), add=T, pch=20, cap=.01, col=1,cex=1.5)
) 


##############################################################
#LBR8 
#############################################################

#3prime
brokenfplus8 <- rowMeans(noinhibitor_broken_end_LBR8_3prime, na.rm = T)
brokenfmin8 <- rowMeans(noinhibitor_broken_end_min_LBR8_3prime, na.rm = T)
minguide8 <- rowMeans(noinhibitor_broken_end_minguide_LBR8_3prime, na.rm = T)

sdplus8 <- apply(noinhibitor_broken_end_LBR8_3prime,1,sd, na.rm = T)
sdmin8 <- apply(noinhibitor_broken_end_min_LBR8_3prime, 1,sd, na.rm = T)
sdminguide8 <- apply(noinhibitor_broken_end_minguide_LBR8_3prime, 1,sd, na.rm = T)

#5prime
brokenfplus8_5 <- rowMeans(noinhibitor_broken_end_LBR8_5prime, na.rm = T)
brokenfmin8_5 <- rowMeans(noinhibitor_broken_end_min_LBR8_5prime, na.rm = T)
minguide8_5 <- rowMeans(noinhibitor_broken_end_minguide_LBR8_5prime, na.rm = T)

sdplus8_5 <- apply(noinhibitor_broken_end_LBR8_5prime,1,sd, na.rm = T)
sdmin8_5 <- apply(noinhibitor_broken_end_min_LBR8_5prime, 1,sd, na.rm = T)
sdminguide8_5 <- apply(noinhibitor_broken_end_minguide_LBR8_5prime, 1,sd, na.rm = T)

#LBR8 #3+5
brokenfplus8_3_5 <- rowMeans(cbind(noinhibitor_broken_end_LBR8_3prime,noinhibitor_broken_end_LBR8_5prime ), na.rm = T)

brokenfmin8_3_5 <- rowMeans(cbind(noinhibitor_broken_end_min_LBR8_3prime,noinhibitor_broken_end_min_LBR8_5prime), na.rm = T)

minguide8_3_5 <- rowMeans(cbind(noinhibitor_broken_end_minguide_LBR8_3prime,noinhibitor_broken_end_minguide_LBR8_5prime), na.rm = T)

sdplus8_3_5 <- apply(cbind(noinhibitor_broken_end_LBR8_3prime,noinhibitor_broken_end_LBR8_5prime),1,sd, na.rm = T)
sdmin8_3_5 <- apply(cbind(noinhibitor_broken_end_min_LBR8_3prime,noinhibitor_broken_end_min_LBR8_5prime), 1,sd, na.rm = T)
sdminguide8_3_5 <- apply(cbind(noinhibitor_broken_end_minguide_LBR8_3prime,noinhibitor_broken_end_minguide_LBR8_5prime), 1,sd, na.rm = T)


###################

#3prime
brokenfraction_8 <- data.frame(timeb=timeb, brokenf=brokenfplus8, sd=sdplus8)
brokenfraction_8m <- data.frame(timemin=timemin, brokenfmin=brokenfmin8, sdmin=sdmin8)
brokenfraction_8mg <- data.frame(timeming=timeming, minguide=minguide8, sdminguide=sdminguide8)

# put on min max data range
rangecolor <- rgb(30,144,255,alpha=80,maxColorValue=255)
minmaxbro=t(apply(matrix(unlist(lapply(noinhibitor_total_individual_series,function(x){x$broken})),ncol=length(noinhibitor_total_individual_series)),1,range));

plot(main='w/o NU7441 LBR8 3prime',seq(0,max(timeb),0.1),minmaxbro[,2]*100,col='white',type='l',lwd=4,ylim=c(-0.05,1.5),xlim=range(c(timeb,timeming)),xlab="tim (h)", ylab="broken (%)")

# fitting the curve
FL=brokenendPkfit(timeb, brokenfraction_8$brokenf);

# add experimental data
with (
  data = brokenfraction_8
  , expr = errbar(timeb, brokenf/max(FL[[2]]), (brokenf/max(FL[[2]])+sd/max(FL[[2]])), (brokenf/max(FL[[2]])-sd/max(FL[[2]])), add=T, pch=20, cap=.01, col=4,cex=1.5)
)

with (
  data = brokenfraction_8m
  , expr = errbar(timemin, brokenfmin/max(FL[[2]]), (brokenfmin/max(FL[[2]])+sdmin/max(FL[[2]])), (brokenfmin/max(FL[[2]])-sdmin/max(FL[[2]])), add=T, pch=20, cap=.01, col="grey",cex=1.5)
)

with (
  data = brokenfraction_8mg
  , expr = errbar(timeming, minguide/max(FL[[2]]), (minguide/max(FL[[2]])+sdminguide/max(FL[[2]])), (minguide/max(FL[[2]])-sdminguide/max(FL[[2]])), add=T, pch=20, cap=.01, col=1,cex=1.5)
)

lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]),col=4);

abline(v=seq(0,max(timeb),0.1)[which.max(FL[[2]])],col=4,lty=2,lwd=2)


l=legend("topright", legend=c("+shield", "-shield", "-guide +shield"), pch=c(16, 16, 16), pt.cex=c(1,1,1),col=c(4, "grey", 1), pt.bg =rangecolor, text.col=c(1, 1, 1),bty="n")


text(pos=4,l$text$x[1],min(l$text$y)+(diff(l$text$y)[1]),paste('peak(exp) =',seq(0,max(timeb),0.1)[which.max(FL[[2]])],'h',sep=''),col=4)



##################################################
#invividual series fitting, expected shape fitting
##################################################

pbe= rep(0,ncol(noinhibitor_broken_end_LBR8_3prime));

for (i in 1:ncol(noinhibitor_broken_end_LBR8_3prime)){
  Y=noinhibitor_broken_end_LBR8_3prime[,i];
 FL=brokenendPkfit(timeb[is.finite(timeb+Y)], Y[is.finite(timeb+Y)]);

  plot(main=paste('w/o NU7441 LBR8 3prime exp',i),timeb,Y/max(FL[[2]]),pch=16,xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="broken fraction (a.u.)")
  lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]));
  pbe[i]=seq(0,max(timeb),0.1)[which.max(FL[[2]])];
  legend('topright',legend=bquote(tau == .(round(pbe[i],1))),bty='n');
  abline(lwd=2,v=pbe[i],lty=2);
}

mean(pbe)
sd(pbe)

##################################################
#average fitting, expected shape fitting
##################################################

# put on min max data range
rangecolor <- rgb(30,144,255,alpha=80,maxColorValue=255)
minmaxbro=t(apply(matrix(unlist(lapply(noinhibitor_total_individual_series,function(x){x$broken})),ncol=length(noinhibitor_total_individual_series)),1,range));

plot(main='w/o NU7441 LBR8 3prime',seq(0,max(timeb),0.1),minmaxbro[,2]*100,col='white',type='l',lwd=4,ylim=c(-0.05,1.5),xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="broken fraction (a.u.)")

#shading
pbe1=mean(pbe)-sd(pbe)

pbe2=mean(pbe)+sd(pbe)

polygon(sort(c(pbe1,pbe2,pbe1,pbe2)),c(-100,100,100,-100),col=rgb(0,0,1,0.5),border=rgb(0,0,1,0.5))

#fit
Y=brokenfraction_8$brokenf
FL=brokenendPkfit(timeb, Y)

# add experimental data
with (
  data = brokenfraction_8
  , expr = errbar(timeb, brokenf/max(FL[[2]]), (brokenf/max(FL[[2]])+sd/max(FL[[2]])), (brokenf/max(FL[[2]])-sd/max(FL[[2]])), add=T, pch=20, cap=.01, col=4,cex=1.5)
)

with (
  data = brokenfraction_8m
  , expr = errbar(timemin, brokenfmin/max(FL[[2]]), (brokenfmin/max(FL[[2]])+sdmin/max(FL[[2]])), (brokenfmin/max(FL[[2]])-sdmin/max(FL[[2]])), add=T, pch=20, cap=.01, col="grey",cex=1.5)
)

with (
  data = brokenfraction_8mg
  , expr = errbar(timeming, minguide/max(FL[[2]]), (minguide/max(FL[[2]])+sdminguide/max(FL[[2]])), (minguide/max(FL[[2]])-sdminguide/max(FL[[2]])), add=T, pch=20, cap=.01, col=1,cex=1.5)
)


lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]),col=4);
l=legend("topright", legend=c("+shield", "-shield", "-guide +shield",expression(tau['measurement'])), pch=c(16, 16, 16,15), pt.cex=c(1,1,1),col=c(4, "grey", 1,rangecolor,rgb(0,0,1,0.5)), text.col=c(1, 1, 1),bty="n")



########## 
#no inhibitor 5 prime

brokenfraction_85 <- data.frame(timeb=timeb, brokenf=brokenfplus_5, sd=sdplus_5)
brokenfraction_8m5 <- data.frame(timemin=timemin, brokenfmin=brokenfmin_5, sdmin=sdmin_5)
brokenfraction_8mg5 <- data.frame(timeming=timeming, minguide=minguide_5, sdminguide=sdminguide_5)


# put on min max data range
rangecolor <- rgb(30,144,255,alpha=80,maxColorValue=255)
minmaxbro=t(apply(matrix(unlist(lapply(noinhibitor_total_individual_series,function(x){x$broken})),ncol=length(noinhibitor_total_individual_series)),1,range));

plot(main='w/o NU7441 LBR8 5prime',seq(0,max(timeb),0.1),minmaxbro[,2]*100,col='white',type='l',lwd=4,ylim=c(-0.05,1.5),xlim=range(c(timeb,timeming)),xlab="tim (h)", ylab="broken (%)")

# fitting the curve
FL=brokenendPkfit(timeb, brokenfraction_85$brokenf);

# add experimental data
with (
  data = brokenfraction_85
  , expr = errbar(timeb, brokenf/max(FL[[2]]), (brokenf/max(FL[[2]])+sd/max(FL[[2]])), (brokenf/max(FL[[2]])-sd/max(FL[[2]])), add=T, pch=20, cap=.01, col=4,cex=1.5)
)

with (
  data = brokenfraction_8m5
  , expr = errbar(timemin, brokenfmin/max(FL[[2]]), (brokenfmin/max(FL[[2]])+sdmin/max(FL[[2]])), (brokenfmin/max(FL[[2]])-sdmin/max(FL[[2]])), add=T, pch=20, cap=.01, col="grey",cex=1.5)
)

with (
  data = brokenfraction_8mg5
  , expr = errbar(timeming, minguide/max(FL[[2]]), (minguide/max(FL[[2]])+sdminguide/max(FL[[2]])), (minguide/max(FL[[2]])-sdminguide/max(FL[[2]])), add=T, pch=20, cap=.01, col=1,cex=1.5)
)


lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]),col=4);

abline(v=seq(0,max(timeb),0.1)[which.max(FL[[2]])],col=4,lty=2,lwd=2)


l=legend("topright", legend=c("+shield", "-shield", "-guide +shield",'minmax(prediction)'), pch=c(16, 16, 16,17), pt.cex=c(1,1,1,1),col=c(4, "grey", 1,rangecolor), pt.bg =rangecolor, text.col=c(1, 1, 1,1),bty="n")

text(pos=4,l$text$x[1],min(l$text$y)+(diff(l$text$y)[1]),paste('peak(exp) =',seq(0,max(timeb),0.1)[which.max(FL[[2]])],'h',sep=''),col=4)



##################################################
#invividual series fitting, expected shape fitting
##################################################

pbe= rep(0,ncol(noinhibitor_broken_end_LBR8_5prime));

for (i in 1:ncol(noinhibitor_broken_end_LBR8_5prime)){
  Y=noinhibitor_broken_end_LBR8_5prime[,i];
  FL=brokenendPkfit(timeb[is.finite(timeb+Y)], Y[is.finite(timeb+Y)]);

  plot(main=paste('w/o NU7441 lBR8 5prime exp',i),timeb,Y/max(FL[[2]]),pch=16,xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="broken fraction (a.u.)")
  lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]));
  pbe[i]=seq(0,max(timeb),0.1)[which.max(FL[[2]])];
  legend('topright',legend=bquote(tau == .(round(pbe[i],1))),bty='n');
  abline(lwd=2,v=pbe[i],lty=2);
}

mean(pbe)
sd(pbe)

##################################################
#average fitting, expected shape fitting
##################################################

# put on min max data range
rangecolor <- rgb(30,144,255,alpha=80,maxColorValue=255)
minmaxbro=t(apply(matrix(unlist(lapply(noinhibitor_total_individual_series,function(x){x$broken})),ncol=length(noinhibitor_total_individual_series)),1,range));

plot(main='w/o NU7441 LBR8 5prime',seq(0,max(timeb),0.1),minmaxbro[,2]*100,col='white',type='l',lwd=4,ylim=c(-0.05,1.5),xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="broken fraction (a.u.)")

#shading
pbe1=mean(pbe)-sd(pbe)

pbe2=mean(pbe)+sd(pbe)

polygon(sort(c(pbe1,pbe2,pbe1,pbe2)),c(-100,100,100,-100),col=rgb(0,0,1,0.5),border=rgb(0,0,1,0.5))

#fit
Y=brokenfraction_85$brokenf
FL=brokenendPkfit(timeb, Y);

# add experimental data
with (
  data = brokenfraction_85
  , expr = errbar(timeb, brokenf/max(FL[[2]]), (brokenf/max(FL[[2]])+sd/max(FL[[2]])), (brokenf/max(FL[[2]])-sd/max(FL[[2]])), add=T, pch=20, cap=.01, col=4,cex=1.5)
)

with (
  data = brokenfraction_8m5
  , expr = errbar(timemin, brokenfmin/max(FL[[2]]), (brokenfmin/max(FL[[2]])+sdmin/max(FL[[2]])), (brokenfmin/max(FL[[2]])-sdmin/max(FL[[2]])), add=T, pch=20, cap=.01, col="grey",cex=1.5)
)

with (
  data = brokenfraction_8mg5
  , expr = errbar(timeming, minguide/max(FL[[2]]), (minguide/max(FL[[2]])+sdminguide/max(FL[[2]])), (minguide/max(FL[[2]])-sdminguide/max(FL[[2]])), add=T, pch=20, cap=.01, col=1,cex=1.5)
)


lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]),col=4);
l=legend("topright", legend=c("+shield", "-shield", "-guide +shield",expression(tau['measurement'])), pch=c(16, 16, 16,15), pt.cex=c(1,1,1),col=c(4, "grey", 1,rangecolor,rgb(0,0,1,0.5)), text.col=c(1, 1, 1),bty="n")



######
#LBR2 vs LBR8

brokenfraction_35 <- data.frame(timeb=timeb, brokenf=brokenfplus3_5, sd=sdplus3_5)
brokenfraction_m35 <- data.frame(timemin=timemin, brokenfmin=brokenfmin3_5, sdmin=sdmin3_5)
brokenfraction_mg35 <- data.frame(timeming=timeming, minguide=minguide3_5, sdminguide=sdminguide3_5)

brokenfraction8_35 <- data.frame(timeb=timeb, brokenf=brokenfplus8_3_5, sd=sdplus8_3_5)
brokenfraction8_m35 <- data.frame(timemin=timemin, brokenfmin=brokenfmin8_3_5, sdmin=sdmin8_3_5)
brokenfraction8_mg35 <- data.frame(timeming=timeming, minguide=minguide8_3_5, sdminguide=sdminguide8_3_5)

# put on min max data range
rangecolor <- rgb(30,144,255,alpha=80,maxColorValue=255)
minmaxbro=t(apply(matrix(unlist(lapply(noinhibitor_total_individual_series,function(x){x$broken})),ncol=length(noinhibitor_total_individual_series)),1,range));

plot(main='w/o NU7441 LBR2 & LBR8 3&5prime',seq(0,max(timeb),0.1),minmaxbro[,2]*100,col='white',type='l',lwd=4,ylim=c(-0.05,1.5),xlim=range(c(timeb,timeming)),xlab="tim (h)", ylab="broken (%)")


# fitting the curve
FL=brokenendPkfit(timeb, brokenfraction_35$brokenf);
FL2=brokenendPkfit(timeb, brokenfraction8_35$brokenf);

# add experimental data
with (
  data = brokenfraction_35
  , expr = errbar(timeb, brokenf/max(FL[[2]]), (brokenf/max(FL[[2]])+sd/max(FL[[2]])), (brokenf/max(FL[[2]])-sd/max(FL[[2]])), add=T, pch=20, cap=.01, col=4,cex=1.5)
)

with (
  data = brokenfraction_m35
  , expr = errbar(timemin, brokenfmin/max(FL[[2]]), (brokenfmin/max(FL[[2]])+sdmin/max(FL[[2]])), (brokenfmin/max(FL[[2]])-sdmin/max(FL[[2]])), add=T, pch=20, cap=.01, col="grey",cex=1.5)
)

with (
  data = brokenfraction_mg35
  , expr = errbar(timeming, minguide/max(FL[[2]]), (minguide/max(FL[[2]])+sdminguide/max(FL[[2]])), (minguide/max(FL[[2]])-sdminguide/max(FL[[2]])), add=T, pch=20, cap=.01, col=1,cex=1.5)
)

with (
  data = brokenfraction8_35
  , expr = errbar(timeb, brokenf/max(FL2[[2]]), (brokenf/max(FL2[[2]])+sd/max(FL2[[2]])), (brokenf/max(FL2[[2]])-sd/max(FL2[[2]])), add=T, pch=20, cap=.01, col=2,cex=1.5)
)

with (
  data = brokenfraction8_m35
  , expr = errbar(timemin, brokenfmin/max(FL2[[2]]), (brokenfmin/max(FL2[[2]])+sdmin/max(FL2[[2]])), (brokenfmin/max(FL2[[2]])-sdmin/max(FL2[[2]])), add=T, pch=20, cap=.01, col=5,cex=1.5)
)

lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]),col=4);

abline(v=seq(0,max(timeb),0.1)[which.max(FL[[2]])],col=4,lty=2,lwd=2)

l=legend("topright", legend=c("+shield lBR2", "-shield lBR2", "+shield lBR8", "-shield lBR8", "-guide +shield"), pch=c(16, 16, 16,16, 16), pt.cex=c(1,1,1, 1),col=c(4, "grey",2, 5, 1), text.col=c(1, 1, 1, 1),bty="n")

text(pos=4,l$text$x[1],min(l$text$y)+(diff(l$text$y)[1]),paste('peak(exp) =',seq(0,max(timeb),0.1)[which.max(FL[[2]])],'h',sep=''),col=4)

lines(seq(0,max(timeb),0.1),FL2[[2]]/max(FL2[[2]]),col=2);

abline(v=seq(0,max(timeb),0.1)[which.max(FL2[[2]])],col=2,lty=2,lwd=2)

text(pos=4,l$text$x[1],min(l$text$y)+(diff(l$text$y)[1]),paste('peak(exp) =',seq(0,max(timeb),0.1)[which.max(FL2[[2]])],'h',sep=''),col=5)


##################################################
#invividual series fitting, expected shape fitting
##################################################

#lbr2
pbe= rep(0,ncol(cbind(noinhibitor_broken_end_3prime,noinhibitor_broken_end_5prime)));

for (i in 1:ncol(cbind(noinhibitor_broken_end_3prime,noinhibitor_broken_end_5prime))){
  Y=cbind(noinhibitor_broken_end_3prime,noinhibitor_broken_end_5prime)[,i];
  FL=brokenendPkfit(timeb[is.finite(timeb+Y)], Y[is.finite(timeb+Y)]);

  plot(main=paste('w/o NU7441 lBR2 3&5prime exp',i),timeb,Y/max(FL[[2]]),pch=16,xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="broken fraction (a.u.)")
  lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]));
  pbe[i]=seq(0,max(timeb),0.1)[which.max(FL[[2]])];
  legend('topright',legend=bquote(tau == .(round(pbe[i],1))),bty='n');
  abline(lwd=2,v=pbe[i],lty=2);
}

#lbr8
pbe8= rep(0,ncol(cbind(noinhibitor_broken_end_LBR8_3prime,noinhibitor_broken_end_LBR8_5prime)));

for (i in 1:ncol(cbind(noinhibitor_broken_end_LBR8_3prime,noinhibitor_broken_end_LBR8_5prime))){
  Y=cbind(noinhibitor_broken_end_LBR8_3prime,noinhibitor_broken_end_LBR8_5prime)[,i];
FL=brokenendPkfit(timeb[is.finite(timeb+Y)], Y[is.finite(timeb+Y)]);

  plot(main=paste('w/o NU7441 lBR8 3&5prime exp',i),timeb,Y/max(FL[[2]]),pch=16,xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="broken fraction (a.u.)")
  lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]));
  pbe8[i]=seq(0,max(timeb),0.1)[which.max(FL[[2]])];
  legend('topright',legend=bquote(tau == .(round(pbe8[i],1))),bty='n');
  abline(lwd=2,v=pbe8[i],lty=2);
}

t.test(pbe, pbe8)
wilcox.test(pbe, pbe8)

##################################################
#average fitting, expected shape fitting
##################################################

# put on min max data range
rangecolor <- rgb(30,144,255,alpha=80,maxColorValue=255)
minmaxbro=t(apply(matrix(unlist(lapply(noinhibitor_total_individual_series,function(x){x$broken})),ncol=length(noinhibitor_total_individual_series)),1,range));

plot(main='w/o NU7441 LBR2 & LBR8 3&5prime',seq(0,max(timeb),0.1),minmaxbro[,2]*100,col='white',type='l',lwd=4,ylim=c(-0.05,1.5),xlim=range(c(timeb,timeming)),xlab="time (h)", ylab="broken fraction (a.u.)")


#shading
pbe1=mean(pbe)-sd(pbe)

pbe2=mean(pbe)+sd(pbe)

polygon(sort(c(pbe1,pbe2,pbe1,pbe2)),c(-100,100,100,-100),col=rgb(0,0,1,0.5),border=rgb(0,0,1,0.5))

pbe81=mean(pbe8)-sd(pbe8)

pbe82=mean(pbe8)+sd(pbe8)

polygon(sort(c(pbe81,pbe82,pbe81,pbe82)),c(-100,100,100,-100),col=rgb(1,0,0,0.5),border=rgb(1,0,0,0.5))

#fit
Y=brokenfraction_35$brokenf
FL=brokenendPkfit(timeb, Y);

Y2=brokenfraction8_35$brokenf
FL2=brokenendPkfit(timeb, Y2);

with (
  data = brokenfraction_35
  , expr = errbar(timeb, brokenf/max(FL[[2]]), (brokenf/max(FL[[2]])+sd/max(FL[[2]])), (brokenf/max(FL[[2]])-sd/max(FL[[2]])), add=T, pch=20, cap=.01, col=4,cex=1.5)
)

with (
  data = brokenfraction_m35
  , expr = errbar(timemin, brokenfmin/max(FL[[2]]), (brokenfmin/max(FL[[2]])+sdmin/max(FL[[2]])), (brokenfmin/max(FL[[2]])-sdmin/max(FL[[2]])), add=T, pch=20, cap=.01, col="grey",cex=1.5)
)

with (
  data = brokenfraction_mg35
  , expr = errbar(timeming, minguide/max(FL[[2]]), (minguide/max(FL[[2]])+sdminguide/max(FL[[2]])), (minguide/max(FL[[2]])-sdminguide/max(FL[[2]])), add=T, pch=20, cap=.01, col=1,cex=1.5)
)

with (
  data = brokenfraction8_35
  , expr = errbar(timeb, brokenf/max(FL2[[2]]), (brokenf/max(FL2[[2]])+sd/max(FL2[[2]])), (brokenf/max(FL2[[2]])-sd/max(FL2[[2]])), add=T, pch=20, cap=.01, col=2,cex=1.5)
)

with (
  data = brokenfraction8_m35
  , expr = errbar(timemin, brokenfmin/max(FL2[[2]]), (brokenfmin/max(FL2[[2]])+sdmin/max(FL2[[2]])), (brokenfmin/max(FL2[[2]])-sdmin/max(FL2[[2]])), add=T, pch=20, cap=.01, col=5,cex=1.5)
)

lines(seq(0,max(timeb),0.1),FL[[2]]/max(FL[[2]]),col=4);
lines(seq(0,max(timeb),0.1),FL2[[2]]/max(FL2[[2]]),col=2);

l=legend("topright", legend=c("+shield lBR2", "-shield lBR2", "+shield lBR8", "-shield lBR8", "-guide +shield",expression(tau['measurement LBR2']), expression(tau['measurement LBR2'])), pch=c(16, 16, 16,16, 16, 15, 15), pt.cex=c(1,1,1, 1,1,1),col=c(4, "grey",2, 5, 1,rangecolor,rgb(0,0,1,0.5), rangecolor,rgb(0,0,1,0.5)), text.col=c(1, 1, 1, 1, 1, 1),bty="n")

pbeD=pbe;

```


<h2>Modeling individual series to break down into +1, -7 and other indels</h2>
<p>Apply function ZLWB2fitDefault to individual series, spliting into without and with NU7441 inhibitor</p>

```{r fit ODE model for individual indels}

# loading data
intact_LBR2 <- read.delim("intact_LBR2.txt", stringsAsFactors=FALSE);
deletion7_LBR2 <- read.delim("deletion7_LBR2.txt", stringsAsFactors=FALSE);
insertion1_LBR2 <- read.delim("insertion1_LBR2.txt", stringsAsFactors=FALSE);
othermut_LBR2 <- read.delim("othermut_LBR2.txt", stringsAsFactors=FALSE);

# remove the sigmoid fitting data
intact_LBR2 = intact_LBR2[-nrow(intact_LBR2),];
deletion7_LBR2 = deletion7_LBR2[-nrow(deletion7_LBR2),];
insertion1_LBR2 = insertion1_LBR2[-nrow(insertion1_LBR2),];
othermut_LBR2 = othermut_LBR2[-nrow(othermut_LBR2),];

# extract time point information
time = as.numeric(row.names(wildtype_tot_LBR2));

#without inhibitor
wt_3=  intact_LBR2[,-c(4,6,8,10,12)]
indel_3=  100-intact_LBR2[,-c(4,6,8,10,12)]
plus1_3=insertion1_LBR2[,-c(4,6,8,10,12)]
minus7_3=deletion7_LBR2[,-c(4,6,8,10,12)]

#with inhibitor
wt_4=  intact_LBR2[,c(4,6,8,10)]
indel_4=  100-intact_LBR2[,c(4,6,8,10)]
plus1_4=insertion1_LBR2[,c(4,6,8,10)]
minus7_4=deletion7_LBR2[,c(4,6,8,10)]


# fitting for noinhibitor
#################################################################
R_sq=NA
R_sq_plus1=NA
R_sq_minus7=NA

noinhibitor_total_individual_series_split = rep(list(NULL),ncol(wt_3));
for (i in 1:ncol(wt_3)){

  noinhibitor_total_individual_series_split[[i]]=ZLWB2fit_MutantsDefault(time,wt_3[,i],indel_3[,i],plus1_3[,i],minus7_3[,i]);
AA = UntransfectedFitting(time,wt_3[,i],indel_3[,i]);

# data
plot(time,wt_3[,i],main=paste(colnames(wt_3)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='intact/(intact+mutated) (%)',xlab='time (h)');

# untransfected
plot(time,wt_3[,i],main=paste('w/o NU7441:',colnames(wt_3)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='intact/(intact+mutated) (%)',xlab='time (h)');
lines(seq(0,60,0.01),(1-AA[1]/(1 + exp(-AA[2] * (seq(0,60,0.01)-AA[3]))))*100,lwd=3);
legend('topright',paste('U =',round(100-AA[1]*100),'%'),bty='n')  

# fitting intact
plot(time,wt_3[,i],main=paste('w/o NU7441:',colnames(wt_3)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='intact/(intact+mutated) (%)',xlab='time (h)',col=2);
lines(time[which(is.finite(wt_3[,i]))],noinhibitor_total_individual_series_split[[i]]$intact*100,lwd=3,col=2)

R_sq[i]=cor(noinhibitor_total_individual_series_split[[i]]$intact,wt_3[which(is.finite(wt_3[,i])),i])^2;
kcmax= log(2)/noinhibitor_total_individual_series_split[[i]]$hlc;
kp= log(2)/(noinhibitor_total_individual_series_split[[i]]$hlm/noinhibitor_total_individual_series_split[[i]]$perfectF);
km=log(2)/noinhibitor_total_individual_series_split[[i]]$hlm;
kpl1=log(2)/noinhibitor_total_individual_series_split[[i]]$hlpl1;
kmn7=log(2)/noinhibitor_total_individual_series_split[[i]]$hlmn7;

legend('bottomleft',legend=bquote(R^2 == .(round(R_sq[i],2))), bty='n')
  

# plotting mutants
plot(time,indel_3[,i],main=paste('w/o NU7441:',colnames(wt_3)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='mutated/(intact+mutated) (%)',xlab='time (h)',col=3);
lines(time[which(is.finite(wt_3[,i]))],noinhibitor_total_individual_series_split[[i]]$mutant*100,lwd=3,col=3)

R_sq[i]=cor(noinhibitor_total_individual_series_split[[i]]$mutant,indel_3[which(is.finite(wt_3[,i])),i])^2

  legend('bottomleft',legend=bquote(R^2 == .(round(R_sq[i],2))), bty='n')
  

# plotting +1
plot(time,plus1_3[,i],main=paste('w/o NU7441:',colnames(wt_3)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='+1/(intact+mutated) (%)',xlab='time (h)',col=5);
lines(time[which(is.finite(wt_3[,i]))],noinhibitor_total_individual_series_split[[i]]$plus1*100,lwd=3,col=5)

R_sq_plus1[i]=cor(noinhibitor_total_individual_series_split[[i]]$plus1,plus1_3[which(is.finite(wt_3[,i])),i])^2

legend('bottomleft',legend=bquote(R^2 == .(round(R_sq_plus1[i],2))), bty='n')
  

# plotting -7
plot(time,minus7_3[,i],main=paste('w/o NU7441:',colnames(wt_3)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='-7/(intact+mutated) (%)',xlab='time (h)',col=6);
lines(time[which(is.finite(wt_3[,i]))],noinhibitor_total_individual_series_split[[i]]$minus7*100,lwd=3,col=6)

R_sq_minus7[i]=cor(noinhibitor_total_individual_series_split[[i]]$minus7,minus7_3[which(is.finite(wt_3[,i])),i])^2

legend('bottomleft',legend=bquote(R^2 == .(round(R_sq_minus7[i],2))), bty='n')
  

# plotting broken
plot(seq(0,max(time),0.1),main=paste('w/o NU7441:',colnames(wt_3)[i]),noinhibitor_total_individual_series_split[[i]]$broken*100,lwd=3,col=4,type='l',ylab='broken (%)',xlab='time (h)')
abline(v=noinhibitor_total_individual_series_split[[i]]$peakBro,col=4,lwd=3,lty=2)
abline(h=0,col=4,lwd=3,lty=2)

legend('topright',legend=bquote(tau == .(noinhibitor_total_individual_series_split[[i]]$peakBro)~' h '), bty='n')

#plot rates
bplt=barplot(main=paste('w/o NU7441:',colnames(wt_3)[i]),c(kcmax,kp,km,kpl1,kmn7),
        col=c(4,1,2,5,6),names.arg=
          c(expression('k'['c']*'max'), 
            expression('k'['p']), 
            expression('k'['m']),
            expression('k'['+1']),
            expression('k'['-7'])
            ),horiz=TRUE,las=2,xlab=expression('h'^-1));

rg=range(c(kcmax,kp,km,kpl1,kmn7));

text(mean(rg),bplt[1,1],bquote(.(round(kcmax/10^floor(log10(kcmax)),1)) *'x 10' ^ .(floor(log10(kcmax)))),col=3,cex=1.5)

text(mean(rg),bplt[2,1],bquote(.(round(kp/10^floor(log10(kp)),1)) *'x 10' ^ .(floor(log10(kp)))),col=3,cex=1.5)

text(mean(rg),bplt[3,1],bquote(.(round(km/10^floor(log10(km)),1)) *'x 10' ^ .(floor(log10(km)))),col=3,cex=1.5)

text(mean(rg),bplt[4,1],bquote(.(round(kpl1/10^floor(log10(kpl1)),1)) *'x 10' ^ .(floor(log10(kpl1)))),col=3,cex=1.5)

text(mean(rg),bplt[5,1],bquote(.(round(kmn7/10^floor(log10(kmn7)),1)) *'x 10' ^ .(floor(log10(kmn7)))),col=3,cex=1.5)
  
}

print(R_sq)
print(mean(R_sq))
print(sd(R_sq))

print(R_sq_plus1)
print(mean(R_sq_plus1))
print(sd(R_sq_plus1))

print(R_sq_minus7)
print(mean(R_sq_minus7))
print(sd(R_sq_minus7))

#################################################################
# fitting for withinhibitor
#################################################################

R_sq_i=NA
R_sq_i_plus1=NA
R_sq_i_minus7=NA

withinhibitor_total_individual_series_split = rep(list(NULL),ncol(wt_4));
for (i in 1:ncol(wt_4)){
  
  withinhibitor_total_individual_series_split[[i]]=ZLWB2fit_MutantsDefault(time,wt_4[,i],indel_4[,i],plus1_4[,i],minus7_4[,i]);
  AA = UntransfectedFitting(time,wt_4[,i],indel_4[,i]);
  
  # data
  plot(time,wt_4[,i],main=paste(colnames(wt_4)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='intact/(intact+mutated) (%)',xlab='time (h)');
  
  # untransfected
  plot(time,wt_4[,i],main=paste('with NU7441:',colnames(wt_4)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='intact/(intact+mutated) (%)',xlab='time (h)');
  lines(seq(0,60,0.01),(1-AA[1]/(1 + exp(-AA[2] * (seq(0,60,0.01)-AA[3]))))*100,lwd=3);
  legend('topright',paste('U =',round(100-AA[1]*100),'%'),bty='n')  
  
  # fitting intact
  plot(time,wt_4[,i],main=paste('with NU7441:',colnames(wt_4)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='intact/(intact+mutated) (%)',xlab='time (h)',col=2);
  lines(time[which(is.finite(wt_4[,i]))],withinhibitor_total_individual_series_split[[i]]$intact*100,lwd=3,col=2)
  
  R_sq_i[i]=cor(withinhibitor_total_individual_series_split[[i]]$intact,wt_4[which(is.finite(wt_4[,i])),i])^2;
  kcmax= log(2)/withinhibitor_total_individual_series_split[[i]]$hlc;
  kp= log(2)/(withinhibitor_total_individual_series_split[[i]]$hlm/withinhibitor_total_individual_series_split[[i]]$perfectF);
  km=log(2)/withinhibitor_total_individual_series_split[[i]]$hlm;
  kpl1=log(2)/withinhibitor_total_individual_series_split[[i]]$hlpl1;
  kmn7=log(2)/withinhibitor_total_individual_series_split[[i]]$hlmn7;
  
  legend('bottomleft',legend=bquote(R^2 == .(round(R_sq[i],2))), bty='n')
  
  
  # plotting mutants
  plot(time,indel_4[,i],main=paste('with NU7441:',colnames(wt_4)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='mutated/(intact+mutated) (%)',xlab='time (h)',col=3);
  lines(time[which(is.finite(wt_4[,i]))],withinhibitor_total_individual_series_split[[i]]$mutant*100,lwd=3,col=3)
  
   R_sq_i[i]=cor(withinhibitor_total_individual_series_split[[i]]$mutant,indel_4[which(is.finite(wt_4[,i])),i])^2;
  
  legend('bottomleft',legend=bquote(R^2 == .(round(R_sq_i[i],2))), bty='n')
  
  
  # plotting +1
  plot(time,plus1_4[,i],main=paste('with NU7441:',colnames(wt_4)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='+1/(intact+mutated) (%)',xlab='time (h)',col=5);
  lines(time[which(is.finite(wt_4[,i]))],withinhibitor_total_individual_series_split[[i]]$plus1*100,lwd=3,col=5)
  
  R_sq_i_plus1[i]=cor(withinhibitor_total_individual_series_split[[i]]$plus1,plus1_4[which(is.finite(wt_4[,i])),i])^2;
  
  legend('bottomleft',legend=bquote(R^2 == .(round(R_sq_i_plus1[i],2))), bty='n')
  
  # plotting -7
  plot(time,minus7_4[,i],main=paste('with NU7441:',colnames(wt_4)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='-7/(intact+mutated) (%)',xlab='time (h)',col=6);
  lines(time[which(is.finite(wt_4[,i]))],withinhibitor_total_individual_series_split[[i]]$minus7*100,lwd=3,col=6)
  
  R_sq_i_minus7[i]=cor(withinhibitor_total_individual_series_split[[i]]$minus7,minus7_4[which(is.finite(wt_4[,i])),i])^2
  
  legend('bottomleft',legend=bquote(R^2 == .(round(R_sq_i_minus7[i],2))), bty='n')
  
  # plotting broken
  plot(seq(0,max(time),0.1),main=paste('with NU7441:',colnames(wt_4)[i]),withinhibitor_total_individual_series_split[[i]]$broken*100,lwd=3,col=4,type='l',ylab='broken (%)',xlab='time (h)')
  abline(v=withinhibitor_total_individual_series_split[[i]]$peakBro,col=4,lwd=3,lty=2)
  abline(h=0,col=4,lwd=3,lty=2)
  
  legend('topright',legend=bquote(tau == .(withinhibitor_total_individual_series_split[[i]]$peakBro)~' h '), bty='n')
  
  #plot rates
  bplt=barplot(main=paste('with NU7441:',colnames(wt_4)[i]),c(kcmax,kp,km,kpl1,kmn7),
               col=c(4,1,2,5,6),names.arg=
                 c(expression('k'['c']*'max'), 
                   expression('k'['p']), 
                   expression('k'['m']),
                   expression('k'['+1']),
                   expression('k'['-7'])
                 ),horiz=TRUE,las=2,xlab=expression('h'^-1));
  
  rg=range(c(kcmax,kp,km,kpl1,kmn7));
  
  text(mean(rg),bplt[1,1],bquote(.(round(kcmax/10^floor(log10(kcmax)),1)) *'x 10' ^ .(floor(log10(kcmax)))),col=3,cex=1.5)
  
  text(mean(rg),bplt[2,1],bquote(.(round(kp/10^floor(log10(kp)),1)) *'x 10' ^ .(floor(log10(kp)))),col=3,cex=1.5)
  
  text(mean(rg),bplt[3,1],bquote(.(round(km/10^floor(log10(km)),1)) *'x 10' ^ .(floor(log10(km)))),col=3,cex=1.5)
  
  text(mean(rg),bplt[4,1],bquote(.(round(kpl1/10^floor(log10(kpl1)),1)) *'x 10' ^ .(floor(log10(kpl1)))),col=3,cex=1.5)
  
  text(mean(rg),bplt[5,1],bquote(.(round(kmn7/10^floor(log10(kmn7)),1)) *'x 10' ^ .(floor(log10(kmn7)))),col=3,cex=1.5)
  
}

print(R_sq_i)
print(mean(R_sq_i))
print(sd(R_sq_i))

print(R_sq_i_plus1)
print(mean(R_sq_i_plus1))
print(sd(R_sq_i_plus1))

print(R_sq_i_minus7)
print(mean(R_sq_i_minus7))
print(sd(R_sq_i_minus7))

```

<h2>Collect individual data series and represent parameters, +1 and -7</h2>
<p>split into without and with NU7441</p>

```{r rate constants for individual indels}

library(beeswarm);
# hlc
beeswarm(list(log(2)/sapply(noinhibitor_total_individual_series_split,function(x){x$hlc}),log(2)/sapply(withinhibitor_total_individual_series_split,function(x){x$hlc})),pch=16,cex=1.5,col=c(4,2),labels = c("w/o NU7441", "with NU7441"),ylab=expression('k'['c']*'max'*' (h'^-1*')'))

lgd = legend('topright',c(paste(round(mean(sapply(noinhibitor_total_individual_series_split,function(x){x$hlc})),1),'',round(sd(sapply(noinhibitor_total_individual_series_split,function(x){x$hlc})),1)),paste(round(mean(sapply(withinhibitor_total_individual_series_split,function(x){x$hlc})),1),'+/-',round(sd(sapply(withinhibitor_total_individual_series_split,function(x){x$hlc})),1))),text.col=c(0,0),bty='n');

d1 = log(2)/sapply(noinhibitor_total_individual_series_split,function(x){x$hlc});
d2 = log(2)/sapply(withinhibitor_total_individual_series_split,function(x){x$hlc});

text(lgd$text$x[1],lgd$text$y[1],bquote('('*.(round(mean(d1)/10^(floor(log10(mean(d1)))),1)) *''* .(round(sd(d1)/10^(floor(log10(mean(d1)))),1))*') x 10' ^ .(floor(log10(mean(d1))))),col=4)

text(lgd$text$x[2],lgd$text$y[2],bquote('('*.(round(mean(d2)/10^(floor(log10(mean(d2)))),1)) *''* .(round(sd(d2)/10^(floor(log10(mean(d2)))),1))*') x 10' ^ .(floor(log10(mean(d2))))),col=2)

# hlp
beeswarm(list(log(2)/(sapply(noinhibitor_total_individual_series_split,function(x){x$hlm})/sapply(noinhibitor_total_individual_series_split,function(x){x$perfectF})),log(2)/(sapply(withinhibitor_total_individual_series_split,function(x){x$hlm})/sapply(withinhibitor_total_individual_series_split,function(x){x$perfectF}))),pch=16,cex=1.5,col=c(4,2),labels = c("w/o NU7441", "with NU7441"),ylab=expression('k'['p']*' (h'^-1*')'));

lgd = legend('bottomright',c(paste(round(mean(log(2)/(sapply(noinhibitor_total_individual_series_split,function(x){x$hlm})/sapply(noinhibitor_total_individual_series_split,function(x){x$perfectF}))),2),'+/-',round(sd(log(2)/(sapply(noinhibitor_total_individual_series_split,function(x){x$hlm})/sapply(noinhibitor_total_individual_series_split,function(x){x$perfectF}))),2)),paste(round(mean(log(2)/(sapply(withinhibitor_total_individual_series_split,function(x){x$hlm})/sapply(withinhibitor_total_individual_series_split,function(x){x$perfectF}))),2),'+/-',round(sd(log(2)/(sapply(withinhibitor_total_individual_series_split,function(x){x$hlm})/sapply(withinhibitor_total_individual_series_split,function(x){x$perfectF}))),2))),text.col=c(0,0),bty='n')

d1 = (log(2)/(sapply(noinhibitor_total_individual_series_split,function(x){x$hlm})/sapply(noinhibitor_total_individual_series_split,function(x){x$perfectF})));
d2 = (log(2)/(sapply(withinhibitor_total_individual_series_split,function(x){x$hlm})/sapply(withinhibitor_total_individual_series_split,function(x){x$perfectF})));

text(lgd$text$x[1],lgd$text$y[1],bquote('('*.(round(mean(d1)/10^(floor(log10(mean(d1)))),1)) *''* .(round(sd(d1)/10^(floor(log10(mean(d1)))),1))*') x 10' ^ .(floor(log10(mean(d1))))),col=4)

text(lgd$text$x[2],lgd$text$y[2],bquote('('*.(round(mean(d2)/10^(floor(log10(mean(d2)))),1)) *''* .(round(sd(d2)/10^(floor(log10(mean(d2)))),1))*') x 10' ^ .(floor(log10(mean(d2))))),col=2)


# hlm
beeswarm(list(log(2)/sapply(noinhibitor_total_individual_series_split,function(x){x$hlm}),log(2)/sapply(withinhibitor_total_individual_series_split,function(x){x$hlm})),pch=16,cex=1.5,col=c(4,2),labels = c("w/o NU7441", "with NU7441"),ylab=expression('k'['m']*' (h'^-1*')'))

lgd = legend('topright',c(paste(round(mean(sapply(noinhibitor_total_individual_series_split,function(x){x$hlm})),1),'',round(sd(sapply(noinhibitor_total_individual_series_split,function(x){x$hlm})),1)),paste(round(mean(sapply(withinhibitor_total_individual_series_split,function(x){x$hlm})),1),'+/-',round(sd(sapply(withinhibitor_total_individual_series_split,function(x){x$hlm})),1))),text.col=c(0,0),bty='n');

d1 = log(2)/sapply(noinhibitor_total_individual_series_split,function(x){x$hlm});
d2 = log(2)/sapply(withinhibitor_total_individual_series_split,function(x){x$hlm});

text(lgd$text$x[1],lgd$text$y[1],bquote('('*.(round(mean(d1)/10^(floor(log10(mean(d1)))),1)) *''* .(round(sd(d1)/10^(floor(log10(mean(d1)))),1))*') x 10' ^ .(floor(log10(mean(d1))))),col=4)

text(lgd$text$x[2],lgd$text$y[2],bquote('('*.(round(mean(d2)/10^(floor(log10(mean(d2)))),1)) *''* .(round(sd(d2)/10^(floor(log10(mean(d2)))),1))*') x 10' ^ .(floor(log10(mean(d2))))),col=2)


# hlpl1
beeswarm(list(log(2)/sapply(noinhibitor_total_individual_series_split,function(x){x$hlpl1}),log(2)/sapply(withinhibitor_total_individual_series_split,function(x){x$hlpl1})),pch=16,cex=1.5,col=c(4,2),labels = c("w/o NU7441", "with NU7441"),ylab=expression('k'['+1']*' (h'^-1*')'))

lgd = legend('topright',c(paste(round(mean(sapply(noinhibitor_total_individual_series_split,function(x){x$hlpl1})),1),'',round(sd(sapply(noinhibitor_total_individual_series_split,function(x){x$hlpl1})),1)),paste(round(mean(sapply(withinhibitor_total_individual_series_split,function(x){x$hlpl1})),1),'+/-',round(sd(sapply(withinhibitor_total_individual_series_split,function(x){x$hlpl1})),1))),text.col=c(0,0),bty='n');

d1 = log(2)/sapply(noinhibitor_total_individual_series_split,function(x){x$hlpl1});
d2 = log(2)/sapply(withinhibitor_total_individual_series_split,function(x){x$hlpl1});

text(lgd$text$x[1],lgd$text$y[1],bquote('('*.(round(mean(d1)/10^(floor(log10(mean(d1)))),1)) *''* .(round(sd(d1)/10^(floor(log10(mean(d1)))),1))*') x 10' ^ .(floor(log10(mean(d1))))),col=4)

text(lgd$text$x[2],lgd$text$y[2],bquote('('*.(round(mean(d2)/10^(floor(log10(mean(d2)))),1)) *''* .(round(sd(d2)/10^(floor(log10(mean(d2)))),1))*') x 10' ^ .(floor(log10(mean(d2))))),col=2)


# hlmn7
beeswarm(list(log(2)/sapply(noinhibitor_total_individual_series_split,function(x){x$hlmn7}),log(2)/sapply(withinhibitor_total_individual_series_split,function(x){x$hlmn7})),pch=16,cex=1.5,col=c(4,2),labels = c("w/o NU7441", "with NU7441"),ylab=expression('k'['-7']*' (h'^-1*')'))

lgd = legend('topright',c(paste(round(mean(sapply(noinhibitor_total_individual_series_split,function(x){x$hlmn7})),1),'',round(sd(sapply(noinhibitor_total_individual_series_split,function(x){x$hlmn7})),1)),paste(round(mean(sapply(withinhibitor_total_individual_series_split,function(x){x$hlmn7})),1),'+/-',round(sd(sapply(withinhibitor_total_individual_series_split,function(x){x$hlmn7})),1))),text.col=c(0,0),bty='n');

d1 = log(2)/sapply(noinhibitor_total_individual_series_split,function(x){x$hlmn7});
d2 = log(2)/sapply(withinhibitor_total_individual_series_split,function(x){x$hlmn7});

text(lgd$text$x[1],lgd$text$y[1],bquote('('*.(round(mean(d1)/10^(floor(log10(mean(d1)))),1)) *''* .(round(sd(d1)/10^(floor(log10(mean(d1)))),1))*') x 10' ^ .(floor(log10(mean(d1))))),col=4)

text(lgd$text$x[2],lgd$text$y[2],bquote('('*.(round(mean(d2)/10^(floor(log10(mean(d2)))),1)) *''* .(round(sd(d2)/10^(floor(log10(mean(d2)))),1))*') x 10' ^ .(floor(log10(mean(d2))))),col=2)



# peakBro
beeswarm(list(sapply(noinhibitor_total_individual_series_split,function(x){x$peakBro}),sapply(withinhibitor_total_individual_series_split,function(x){x$peakBro})),pch=16,cex=1.5,col=c(4,2),labels = c("w/o NU7441", "with NU7441"),ylab=bquote(tau * ' (h)' ))

legend('bottomright',c(paste(round(mean(sapply(noinhibitor_total_individual_series_split,function(x){x$peakBro})),1),'+/-',round(sd(sapply(noinhibitor_total_individual_series_split,function(x){x$peakBro})),1)),paste(round(mean(sapply(withinhibitor_total_individual_series_split,function(x){x$peakBro})),1),'+/-',round(sd(sapply(withinhibitor_total_individual_series_split,function(x){x$peakBro})),1))),text.col=c(4,2),bty='n')

```


<h2>Compare combinated mutation model and individual mutation model</h2>
<p>split into without and with NU7441</p>
<p>Compare common values for hlc, hlp, hlm and peakBro</p>

```{r combined model (km) vs individual indels model (k+1, k-7, kother) - rates}

####without inhibitor
# hlc
beeswarm(main='w/o NU7441',list(log(2)/sapply(noinhibitor_total_individual_series,function(x){x$hlc}),log(2)/sapply(noinhibitor_total_individual_series_split,function(x){x$hlc})),pch=c(16,16),cex=1.5,col=c(6,3),labels = c("fitting comb.mut", "fitting indv. mut"),ylab=expression('k'['c']*'max'*' (h'^-1*')'))

legend('topleft',legend=bquote(rho==.(round(cor(log(2)/sapply(noinhibitor_total_individual_series,function(x){x$hlc}),log(2)/sapply(noinhibitor_total_individual_series_split,function(x){x$hlc}),method='spearman'),2))),bty='n')

# hlp
beeswarm(main='w/o NU7441',list(log(2)/(sapply(noinhibitor_total_individual_series,function(x){x$hlm})/sapply(noinhibitor_total_individual_series,function(x){x$perfectF})),log(2)/(sapply(noinhibitor_total_individual_series_split,function(x){x$hlm})/sapply(noinhibitor_total_individual_series_split,function(x){x$perfectF}))),pch=c(16,16),cex=1.5,col=c(6,3),labels = c("fitting comb.mut", "fitting indv. mut"),ylab=expression('k'['p']*' (h'^-1*')'))

legend('topleft',legend=bquote(rho==.(round(cor(log(2)/(sapply(noinhibitor_total_individual_series,function(x){x$hlm})/sapply(noinhibitor_total_individual_series,function(x){x$perfectF})),log(2)/(sapply(noinhibitor_total_individual_series_split,function(x){x$hlm})/sapply(noinhibitor_total_individual_series_split,function(x){x$perfectF})),method='spearman'),2))),bty='n')
       
# hlm
beeswarm(main='w/o NU7441',list(log(2)/sapply(noinhibitor_total_individual_series,function(x){x$hlm}),log(2)/sapply(noinhibitor_total_individual_series_split,function(x){x$hlm})),pch=c(16,16),cex=1.5,col=c(6,3),labels = c("fitting comb.mut", "fitting indv. mut"),ylab=expression('k'['m']*' (h'^-1*')'))

legend('topleft',legend=bquote(rho==.(round(cor(log(2)/sapply(noinhibitor_total_individual_series,function(x){x$hlm}),log(2)/sapply(noinhibitor_total_individual_series_split,function(x){x$hlm}),method='spearman'),2))),bty='n')

# peakBro
beeswarm(main='w/o NU7441',list(sapply(noinhibitor_total_individual_series,function(x){x$peakBro}),sapply(noinhibitor_total_individual_series_split,function(x){x$peakBro})),pch=c(16,16),cex=1.5,col=c(6,3),labels = c("fitting comb.mut", "fitting indv. mut"),ylab=expression(tau *' (h)'))

legend('topleft',legend=bquote(rho==.(round(cor(sapply(noinhibitor_total_individual_series,function(x){x$peakBro}),sapply(noinhibitor_total_individual_series_split,function(x){x$peakBro}),method='spearman'),2))),bty='n')


####without inhibitor
# hlc
beeswarm(main='with NU7441',list(log(2)/sapply(withinhibitor_total_individual_series,function(x){x$hlc}),log(2)/sapply(withinhibitor_total_individual_series_split,function(x){x$hlc})),pch=c(16,16),cex=1.5,col=c(6,3),labels = c("fitting comb.mut", "fitting indv. mut"),ylab=expression('k'['c']*'max'*' (h'^-1*')'))

legend('topleft',legend=bquote(rho==.(round(cor(log(2)/sapply(withinhibitor_total_individual_series,function(x){x$hlc}),log(2)/sapply(withinhibitor_total_individual_series_split,function(x){x$hlc}),method='spearman'),2))),bty='n')

# hlp
beeswarm(main='with NU7441',list(log(2)/(sapply(withinhibitor_total_individual_series,function(x){x$hlm})/sapply(withinhibitor_total_individual_series,function(x){x$perfectF})),log(2)/(sapply(withinhibitor_total_individual_series_split,function(x){x$hlm})/sapply(withinhibitor_total_individual_series_split,function(x){x$perfectF}))),pch=c(16,16),cex=1.5,col=c(6,3),labels = c("fitting comb.mut", "fitting indv. mut"),ylab=expression('k'['p']*' (h'^-1*')'))

legend('topleft',legend=bquote(rho==.(round(cor(log(2)/(sapply(withinhibitor_total_individual_series,function(x){x$hlm})/sapply(withinhibitor_total_individual_series,function(x){x$perfectF})),log(2)/(sapply(withinhibitor_total_individual_series_split,function(x){x$hlm})/sapply(withinhibitor_total_individual_series_split,function(x){x$perfectF})),method='spearman'),2))),bty='n')


# hlm
beeswarm(main='with NU7441',list(log(2)/sapply(withinhibitor_total_individual_series,function(x){x$hlm}),log(2)/sapply(withinhibitor_total_individual_series_split,function(x){x$hlm})),pch=c(16,16),cex=1.5,col=c(6,3),labels = c("fitting comb.mut", "fitting indv. mut"),ylab=expression('k'['m']*' (h'^-1*')'))

legend('topleft',legend=bquote(rho==.(round(cor(log(2)/sapply(withinhibitor_total_individual_series,function(x){x$hlm}),log(2)/sapply(withinhibitor_total_individual_series_split,function(x){x$hlm}),method='spearman'),2))),bty='n')

# peakBro
beeswarm(main='with NU7441',list(sapply(withinhibitor_total_individual_series,function(x){x$peakBro}),sapply(withinhibitor_total_individual_series_split,function(x){x$peakBro})),pch=c(16,16),cex=1.5,col=c(6,3),labels = c("fitting comb.mut", "fitting indv. mut"),ylab=expression(tau *' (h)'))

legend('topleft',legend=bquote(rho==.(round(cor(sapply(withinhibitor_total_individual_series,function(x){x$peakBro}),sapply(withinhibitor_total_individual_series_split,function(x){x$peakBro}),method='spearman'),2))),bty='n')

```

<h2>Compare combinated indel model and individual indel model</h2>
<p>split into without and with NU7441</p>
<p>Compare R square in terms of total, +1 and -7 </p>

```{r combined model (km) vs individual indels model (k+1, k-7, kother) - R^2}

# R square comparison
library(beeswarm);
# function R_sq caculator
R2calculator = function(x,y){
  vec = rep(0,ncol(y));
  for (i in 1:ncol(y)){
   vec[i] = cor(x[!is.na(x[,i]),i],y[,i])^2
  }
  return(vec)
}

rg=c(0.85,1);

# without inhibitor
beeswarm(main='w/o NU7441',list(R2calculator(indel_1,sapply(noinhibitor_total_individual_series,function(x){x$mutant})),R2calculator(indel_3,sapply(noinhibitor_total_individual_series_split,function(x){x$mutant})),R2calculator(plus1_3,sapply(noinhibitor_total_individual_series_split,function(x){x$plus1})),R2calculator(minus7_3,sapply(noinhibitor_total_individual_series_split,function(x){x$minus7})))
  ,pch=c(16,16,17,18),cex=1.5,col=c(6,3,3,3),labels = c("total", "total","+1","-7"),ylab=expression('R'^2),ylim=rg)

legend('bottomleft',c(paste(round(mean(R2calculator(indel_1,sapply(noinhibitor_total_individual_series,function(x){x$mutant}))),2),'+/-',round(sd(R2calculator(indel_1,sapply(noinhibitor_total_individual_series,function(x){x$mutant}))),2))
                      ,paste(round(mean(R2calculator(indel_3,sapply(noinhibitor_total_individual_series_split,function(x){x$mutant}))),2),'+/-',round(sd(R2calculator(indel_3,sapply(noinhibitor_total_individual_series_split,function(x){x$mutant}))),2)),
                      paste(round(mean(R2calculator(plus1_3,sapply(noinhibitor_total_individual_series_split,function(x){x$plus1}))),2),'+/-',round(sd(R2calculator(plus1_3,sapply(noinhibitor_total_individual_series_split,function(x){x$plus1}))),2)),
                      paste(round(mean(R2calculator(minus7_3,sapply(noinhibitor_total_individual_series_split,function(x){x$minus7}))),2),'+/-',round(sd(R2calculator(minus7_3,sapply(noinhibitor_total_individual_series_split,function(x){x$minus7}))),2))
                      ),pch=c(16,16,17,18),col=c(6,3,3,3),bty='n')

legend('bottomright',c('fitting combined mutation','fitting individual mutation'),text.col=c(6,3),bty='n')
  

# with inhibitor
beeswarm(main='with NU7441',list(R2calculator(indel_2,sapply(withinhibitor_total_individual_series,function(x){x$mutant})),R2calculator(indel_4,sapply(withinhibitor_total_individual_series_split,function(x){x$mutant})),R2calculator(plus1_4,sapply(withinhibitor_total_individual_series_split,function(x){x$plus1})),R2calculator(minus7_4,sapply(withinhibitor_total_individual_series_split,function(x){x$minus7})))
  ,pch=c(16,16,17,18),cex=1.5,col=c(6,3,3,3),labels = c("total", "total","+1","-7"),ylab=expression('R'^2),ylim=rg)

legend('bottomleft',c(paste(round(mean(R2calculator(indel_2,sapply(withinhibitor_total_individual_series,function(x){x$mutant}))),2),'+/-',round(sd(R2calculator(indel_2,sapply(withinhibitor_total_individual_series,function(x){x$mutant}))),2))
                      ,paste(round(mean(R2calculator(indel_4,sapply(withinhibitor_total_individual_series_split,function(x){x$mutant}))),2),'+/-',round(sd(R2calculator(indel_4,sapply(withinhibitor_total_individual_series_split,function(x){x$mutant}))),2)),
                      paste(round(mean(R2calculator(plus1_4,sapply(withinhibitor_total_individual_series_split,function(x){x$plus1}))),2),'+/-',round(sd(R2calculator(plus1_4,sapply(withinhibitor_total_individual_series_split,function(x){x$plus1}))),2)),
                      paste(round(mean(R2calculator(minus7_4,sapply(withinhibitor_total_individual_series_split,function(x){x$minus7}))),2),'+/-',round(sd(R2calculator(minus7_4,sapply(withinhibitor_total_individual_series_split,function(x){x$minus7}))),2))
),pch=c(16,16,17,18),col=c(6,3,3,3),bty='n')

legend('bottomright',c('fitting combined mutation','fitting individual mutation'),text.col=c(6,3),bty='n')

```

<h2>Develop an accelerating model for minus7 which is MMEJ pathway</h2>
<p>split into without and with NU7441</p>
<p>Develop function ZLWB2fit_MutantsDefaultMinus7ab: assume linear build up of activity of -7 rate</p>
<p> Fit to individual indels, a complete model for optimal values of kc kp and km, kplus1, kminus7a and kminusb, with all predictions stored and returned</p>


```{r accelerating model for -7 deletion}

##################################################################################
# ZLWB2fit_MutantsDefaultMinus7ab: fitting to individual indels, a complete model for optimal values of kc kp and km, kplus1, kminus7a and kminusb, with all predictions stored and returned
##################################################################################
ZLWB2fit_MutantsDefaultMinus7ab = function(time,wt,indel,plus1,minus7){
  
  # fitting untransfected
  x=time
  y=wt/100
  z=indel/100
  
  is1 = plus1/100;
  mn7 = minus7/100;
  
  index = which(is.finite(x+y+z));
  
  x = x[index];
  y = y[index];
  z = z[index];
  is1 =   is1[index];
  mn7=    mn7[index];
  
  fitmodel <- nls(y~(1-a/(1 + exp(-b * (x-c)))), start=list(a=25,b=1,c=1))
  U = 1-coef(fitmodel)[1]
  untransf=U
  
  
  t= seq(0,max(time*10))/10;
  
  ### cas9 fitting
  # Cas9 protein kinetics
  tWB = c(60,42,33,24,21,18,16,14,12,10,8,4,0)
  
  Cas9I = c(1.035116259,0.93119759,1.134895008,0.980514232,0.989879665,0.903886513, 1.211372653,0.575621105,0.782199246,0.686693037,0.608119422,0.325573414,0.142920737)
  
Cas9WIfit=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]

    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
     return(c(coI)-c(Cas9))
  }
  
  Cas9WISim=function(parms){
    
    b=parms[1]
    D=Inf
    Dp=parms[2]

    Cas9=Cas9I;
    
    coI=b/Dp+(b/D-b/Dp)*exp(-Dp*tWB)
     return(list(coI))
  }
  
  parms = c(1,0.1);
  FL= modFit(f= Cas9WIfit,p=parms,lower=rep(0,length(parms)))
  becy = FL$par;

  listkinetc=list(NULL);
  
  WB1rxnrate=function(t,c,parms){
    
    # rate constant passed through a list called parms
    kc=parms[1];
    kp=parms[2];
    km=parms[3];
    kplus1 = parms[4]
    kminus7min = parms[5];
    kminus7max = parms[6];
    
    b = becy[1];
    D=Inf;
    Dp=becy[2];
    
    # c is the concentration of species
    
    # derivatives dc/dt are computed below
    r=rep(0,length(c))
    r[1]=-kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp+kp*c["B"] #dcA/dt
    r[2]=kc*c["P"]*(b/Dp+(b/D-b/Dp)*exp(-Dp*t))/b*Dp-(kp+km)*c["B"] #dcB/dt
    r[3]=km*c["B"] #dcC/dt
    r[4]=kplus1*c["B"]#dcC/dt
    r[5]=((kminus7max-kminus7min)/max(time)*t+kminus7min)*c["B"]
    
    # the computed derivatives are returned as a list
    # order of derivatives needs to be the same as the order of species in c
    return(list(r))
    
  }
  
  
  
   # function for fitting results
  WB1rxnrate_fit = function(parms){
    
    tmax = max(time); 
    
    kc=log(2)/parms[1];
    kp=log(2)/parms[2];
    km=log(2)/parms[3];
    kplus1 = log(2)/parms[4]
    kminus7min = log(2)/parms[5];
    kminus7max = log(2)/parms[6];
    
    b = becy[1];
    D=Inf;
    Dp=becy[2];
    
    out=ode(y=c(P=as.numeric(1-U),B=0,M=0,PL1=0,MN7=0),times=t,func=WB1rxnrate,parms=c(kc,kp,km,kplus1,kminus7min,kminus7max))
    
    s=out[,2:6]; 
    
    P = s[(out[,1]) %in% x,1];
    M=  s[(out[,1]) %in% x,3];
    PL1=  s[(out[,1]) %in% x,4];
    MN7=  s[(out[,1]) %in% x,5];
    
    return(c(M/(U+P+M)-df[,3],PL1/(U+P+M)-df[,4],MN7/(U+P+M)-df[,5]))
  }
  
  
  # function for repair results
  rxnrate_repair = function(parms,U){
    
    tmax = max(time); 
    
    kc=log(2)/parms[1];
    kp=log(2)/parms[2];
    km=log(2)/parms[3];
    kplus1 = log(2)/parms[4]
    kminus7min = log(2)/parms[5];
    kminus7max = log(2)/parms[6];
    
    b = becy[1];
    D=Inf;
    Dp=becy[2];
    
    out=ode(y=c(P=as.numeric(1-U),B=0,M=0,PL1=0,MN7=0),times=t,func=WB1rxnrate,parms=c(kc,kp,km,kplus1,kminus7min,kminus7max))
    
    s=out[,2:6]; 
    
    P = s[(out[,1]) %in% x,1];
    M=  s[(out[,1]) %in% x,3];
    PL1=  s[(out[,1]) %in% x,4];
    MN7=  s[(out[,1]) %in% x,5];
    
    return(list(s[,2],(P+U)/(P+U+M),M/(P+U+M),PL1/(U+P+M),MN7/(U+P+M)))
  }
  
  
  # fitting
  
  df= data.frame(time=x, wt=y*100, indel=z*100, plus1=  is1*100, minus7=mn7*100)
  
  df[,1]=df[,1]-df[1,1]
  
  df[,2:5]=df[,2:5]/100
  
  t= seq(0,max(df[,1])*10)/10
  
  parms=c(8,8,8,8,8,8)
  
  FL= try(modFit(f=  WB1rxnrate_fit,p=parms,lower=rep(0,length(parms))),silent=TRUE)
  
   if (length(FL)>1){
    residuals=resid (FL)
    
    listkinetc=list(  perfectF = FL$par[3]/FL$par[2],
                      hlc = FL$par[1],
                      hlm = FL$par[3],
                      hlpl1 = FL$par[4],
                      hlmn7a = FL$par[5],
                      hlmn7b = FL$par[6],
                      intact=rxnrate_repair(FL$par,U)[[2]],
                      broken=rxnrate_repair(FL$par,U)[[1]],
                      maxBro = max(rxnrate_repair(FL$par,U)[[1]]),
                      peakBro =seq(0,max(time),0.1)[which.max(rxnrate_repair(FL$par,U)[[1]])],
                      mutant=rxnrate_repair(FL$par,U)[[3]],
                      plus1=rxnrate_repair(FL$par,U)[[4]],
                      minus7=rxnrate_repair(FL$par,U)[[5]],
                      residual_sq=sum(residuals^2));
  }
  
  return(listkinetc);
}
##################################################################################
```

<h2>Modeling individual series to break down into +1, -7a and -7b, combined model</h2>
<p>Apply function ZLWB2fit_MutantsDefaultMinus7ab to individual series, spliting into without and with NU7441 inhibitor</p>
  
```{r fitting accelerating model}

# fitting for noinhibitor
#################################################################
R_sq=NA
R_sq_plus1=NA
R_sq_minus7=NA

combined_noinhibitor_nonlinearminus7 = rep(list(NULL),ncol(wt_3));
for (i in 1:ncol(wt_3)){
  
  combined_noinhibitor_nonlinearminus7[[i]]=ZLWB2fit_MutantsDefaultMinus7ab(time,wt_3[,i],indel_3[,i],plus1_3[,i],minus7_3[,i]);
  AA = UntransfectedFitting(time,wt_3[,i],indel_3[,i]);
  
  # data
  plot(time,wt_3[,i],main=paste(colnames(wt_3)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='intact/(intact+mutated) (%)',xlab='time (h)');
  
  # untransfected
  plot(time,wt_3[,i],main=paste('w/o NU7441:',colnames(wt_3)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='intact/(intact+mutated) (%)',xlab='time (h)');
  lines(seq(0,60,0.01),(1-AA[1]/(1 + exp(-AA[2] * (seq(0,60,0.01)-AA[3]))))*100,lwd=3);
  legend('topright',paste('U =',round(100-AA[1]*100),'%'),bty='n')  
  
  # fitting intact
  plot(time,wt_3[,i],main=paste('w/o NU7441:',colnames(wt_3)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='intact/(intact+mutated) (%)',xlab='time (h)',col=2);
  lines(time[which(is.finite(wt_3[,i]))],combined_noinhibitor_nonlinearminus7[[i]]$intact*100,lwd=3,col=2)
  
  R_sq[i]=cor(combined_noinhibitor_nonlinearminus7[[i]]$intact,wt_3[which(is.finite(wt_3[,i])),i])^2;
  kcmax= log(2)/combined_noinhibitor_nonlinearminus7[[i]]$hlc;
  kp= log(2)/(combined_noinhibitor_nonlinearminus7[[i]]$hlm/combined_noinhibitor_nonlinearminus7[[i]]$perfectF);
  km=log(2)/combined_noinhibitor_nonlinearminus7[[i]]$hlm;
  kpl1=log(2)/combined_noinhibitor_nonlinearminus7[[i]]$hlpl1;
  kmn7a=log(2)/combined_noinhibitor_nonlinearminus7[[i]]$hlmn7a;
  kmn7b=log(2)/combined_noinhibitor_nonlinearminus7[[i]]$hlmn7b;
  
  legend('bottomright',legend=bquote(R^2 == .(round(R_sq[i],2))), bty='n')
  
  # plotting mutants
  plot(time,indel_3[,i],main=paste('w/o NU7441:',colnames(wt_3)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='mutated/(intact+mutated) (%)',xlab='time (h)',col=3);
  lines(time[which(is.finite(wt_3[,i]))],combined_noinhibitor_nonlinearminus7[[i]]$mutant*100,lwd=3,col=3)
  
  R_sq[i]=cor(combined_noinhibitor_nonlinearminus7[[i]]$mutant,indel_3[which(is.finite(wt_3[,i])),i])^2
  
  legend('bottomright',legend=bquote(R^2 == .(round(R_sq[i],2))), bty='n')
  
  # plotting +1
  plot(time,plus1_3[,i],main=paste('w/o NU7441:',colnames(wt_3)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='+1/(intact+mutated) (%)',xlab='time (h)',col=5);
  lines(time[which(is.finite(wt_3[,i]))],combined_noinhibitor_nonlinearminus7[[i]]$plus1*100,lwd=3,col=5)
  
  R_sq_plus1[i]=cor(combined_noinhibitor_nonlinearminus7[[i]]$plus1,plus1_3[which(is.finite(wt_3[,i])),i])^2
  
  legend('bottomright',legend=bquote(R^2 == .(round(R_sq_plus1[i],2))), bty='n')
  
  # plotting -7
  plot(time,minus7_3[,i],main=paste('w/o NU7441:',colnames(wt_3)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='-7/(intact+mutated) (%)',xlab='time (h)',col=6);
  lines(time[which(is.finite(wt_3[,i]))],combined_noinhibitor_nonlinearminus7[[i]]$minus7*100,lwd=3,col=6)
  
  R_sq_minus7[i]=cor(combined_noinhibitor_nonlinearminus7[[i]]$minus7,minus7_3[which(is.finite(wt_3[,i])),i])^2
  
  legend('bottomright',legend=bquote(R^2 == .(round(R_sq_minus7[i],2))), bty='n')
  
  
  # plot -7 repair activity
  plot(main=paste('w/o NU7441:',colnames(minus7_3)[i]),time, ((log(2)/combined_noinhibitor_nonlinearminus7[[i]]$hlmn7b-log(2)/combined_noinhibitor_nonlinearminus7[[i]]$hlmn7a)/max(time)*time+log(2)/combined_noinhibitor_nonlinearminus7[[i]]$hlmn7a),type='l',lwd=2,xlab='time (h)', ylab=expression('k'['-7']*' (h'^-1*')'), ylim=range(c(((log(2)/combined_noinhibitor_nonlinearminus7[[i]]$hlmn7b-log(2)/combined_noinhibitor_nonlinearminus7[[i]]$hlmn7a)/max(time)*time+log(2)/combined_noinhibitor_nonlinearminus7[[i]]$hlmn7a)),0))
  
  legend('topleft',legend=bquote('activity'[0]==.(round(combined_noinhibitor_nonlinearminus7[[i]]$hlmn7b/combined_noinhibitor_nonlinearminus7[[i]]$hlmn7a*100,1))*'%'),bty='n')

  
  # plotting broken
  plot(seq(0,max(time),0.1),main=paste('w/o NU7441:',colnames(wt_3)[i]),combined_noinhibitor_nonlinearminus7[[i]]$broken*100,lwd=3,col=4,type='l',ylab='broken (%)',xlab='time (h)')
  abline(v=combined_noinhibitor_nonlinearminus7[[i]]$peakBro,col=4,lwd=3,lty=2)
  abline(h=0,col=4,lwd=3,lty=2)
  
  legend('topright',legend=bquote(tau == .(combined_noinhibitor_nonlinearminus7[[i]]$peakBro)~' h '), bty='n')
  
  #plot rates
  bplt=barplot(main=paste('w/o NU7441:',colnames(wt_3)[i]),c(kcmax,kp,km,kpl1,kmn7a,kmn7b),
               col=c(4,1,2,5,6,7),names.arg=
                 c(expression('k'['c']*'max'), 
                   expression('k'['p']), 
                   expression('k'['m']),
                   expression('k'['+1']),
                   expression('k'['-7,t=0h']),
                   expression('k'['-7,t=60h'])
                 ),horiz=TRUE,las=2,xlab=expression('h'^-1));
  
  rg=range(c(kcmax,kp,km,kpl1,kmn7a,kmn7b));
  
  text(mean(rg),bplt[1,1],bquote(.(round(kcmax/10^floor(log10(kcmax)),1)) *'x 10' ^ .(floor(log10(kcmax)))),col=3,cex=1.5)
  
  text(mean(rg),bplt[2,1],bquote(.(round(kp/10^floor(log10(kp)),1)) *'x 10' ^ .(floor(log10(kp)))),col=3,cex=1.5)
  
  text(mean(rg),bplt[3,1],bquote(.(round(km/10^floor(log10(km)),1)) *'x 10' ^ .(floor(log10(km)))),col=3,cex=1.5)
  
  text(mean(rg),bplt[4,1],bquote(.(round(kpl1/10^floor(log10(kpl1)),1)) *'x 10' ^ .(floor(log10(kpl1)))),col=3,cex=1.5)
  
  text(mean(rg),bplt[5,1],bquote(.(round(kmn7a/10^floor(log10(kmn7a)),1)) *'x 10' ^ .(floor(log10(kmn7a)))),col=3,cex=1.5)
  
  text(mean(rg),bplt[6,1],bquote(.(round(kmn7b/10^floor(log10(kmn7b)),1)) *'x 10' ^ .(floor(log10(kmn7b)))),col=3,cex=1.5)
  
}


print(R_sq)
print(mean(R_sq))
print(sd(R_sq))

print(R_sq_plus1)
print(mean(R_sq_plus1))
print(sd(R_sq_plus1))

print(R_sq_minus7)
print(mean(R_sq_minus7))
print(sd(R_sq_minus7))

#################################################################
# fitting for withinhibitor
#################################################################

R_sq_i=NA
R_sq_i_plus1=NA
R_sq_i_minus7=NA

combined_withinhibitor_nonlinearminus7 = rep(list(NULL),ncol(wt_4));
for (i in 1:ncol(wt_4)){
  
  combined_withinhibitor_nonlinearminus7[[i]]=ZLWB2fit_MutantsDefaultMinus7ab(time,wt_4[,i],indel_4[,i],plus1_4[,i],minus7_4[,i]);
  AA = UntransfectedFitting(time,wt_4[,i],indel_4[,i]);
  
  # data
  plot(time,wt_4[,i],main=paste(colnames(wt_4)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='intact/(intact+mutated) (%)',xlab='time (h)');
  
  # untransfected
  plot(time,wt_4[,i],main=paste('with NU7441:',colnames(wt_4)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='intact/(intact+mutated) (%)',xlab='time (h)');
  lines(seq(0,60,0.01),(1-AA[1]/(1 + exp(-AA[2] * (seq(0,60,0.01)-AA[3]))))*100,lwd=3);
  legend('topright',paste('U =',round(100-AA[1]*100),'%'),bty='n')  
  
  # fitting intact
  plot(time,wt_4[,i],main=paste('with NU7441:',colnames(wt_4)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='intact/(intact+mutated) (%)',xlab='time (h)',col=2);
  lines(time[which(is.finite(wt_4[,i]))],combined_withinhibitor_nonlinearminus7[[i]]$intact*100,lwd=3,col=2)
  
  R_sq_i[i]=cor(combined_withinhibitor_nonlinearminus7[[i]]$intact,wt_4[which(is.finite(wt_4[,i])),i])^2;
  kcmax= log(2)/combined_withinhibitor_nonlinearminus7[[i]]$hlc;
  kp= log(2)/(combined_withinhibitor_nonlinearminus7[[i]]$hlm/combined_withinhibitor_nonlinearminus7[[i]]$perfectF);
  km=log(2)/combined_withinhibitor_nonlinearminus7[[i]]$hlm;
  kpl1=log(2)/combined_withinhibitor_nonlinearminus7[[i]]$hlpl1;
  kmn7a=log(2)/combined_withinhibitor_nonlinearminus7[[i]]$hlmn7a;
  kmn7b=log(2)/combined_withinhibitor_nonlinearminus7[[i]]$hlmn7b;
  
  legend('bottomleft',legend=bquote(R^2 == .(round(R_sq[i],2))), bty='n')
  
  # plotting mutants
  plot(time,indel_4[,i],main=paste('with NU7441:',colnames(wt_4)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='mutated/(intact+mutated) (%)',xlab='time (h)',col=3);
  lines(time[which(is.finite(wt_4[,i]))],combined_withinhibitor_nonlinearminus7[[i]]$mutant*100,lwd=3,col=3)
  
  R_sq_i[i]=cor(combined_withinhibitor_nonlinearminus7[[i]]$mutant,indel_4[which(is.finite(wt_4[,i])),i])^2
  
  legend('bottomright',legend=bquote(R^2 == .(R_sq_i[i])), bty='n')
  
  # plotting +1
  plot(time,plus1_4[,i],main=paste('with NU7441:',colnames(wt_4)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='+1/(intact+mutated) (%)',xlab='time (h)',col=5);
  lines(time[which(is.finite(wt_4[,i]))],combined_withinhibitor_nonlinearminus7[[i]]$plus1*100,lwd=3,col=5)
  
  R_sq_i_plus1[i]=cor(combined_withinhibitor_nonlinearminus7[[i]]$plus1,plus1_4[which(is.finite(wt_4[,i])),i])^2
  
  legend('bottomright',legend=bquote(R^2 == .(round(R_sq_i_plus1[i],2))), bty='n')
  
  # plotting -7
  plot(time,minus7_4[,i],main=paste('with NU7441:',colnames(wt_4)[i]),ylim=c(0,100),pch=16,cex=1.5,ylab='-7/(intact+mutated) (%)',xlab='time (h)',col=6);
  lines(time[which(is.finite(wt_4[,i]))],combined_withinhibitor_nonlinearminus7[[i]]$minus7*100,lwd=3,col=6)
  
  R_sq_i_minus7[i]=cor(combined_withinhibitor_nonlinearminus7[[i]]$minus7,minus7_4[which(is.finite(wt_4[,i])),i])^2
  
  legend('bottomright',legend=bquote(R^2 == .(round(R_sq_i_minus7[i],2))), bty='n')
  
  
    # plot -7 repair activity
  plot(main=paste('w/o NU7441:',colnames(minus7_3)[i]),time, ((log(2)/combined_withinhibitor_nonlinearminus7[[i]]$hlmn7b-log(2)/combined_withinhibitor_nonlinearminus7[[i]]$hlmn7a)/max(time)*time+log(2)/combined_withinhibitor_nonlinearminus7[[i]]$hlmn7a),type='l',lwd=2,xlab='time (h)', ylab=expression('k'['-7']*' (h'^-1*')'), ylim=range(c(((log(2)/combined_withinhibitor_nonlinearminus7[[i]]$hlmn7b-log(2)/combined_withinhibitor_nonlinearminus7[[i]]$hlmn7a)/max(time)*time+log(2)/combined_withinhibitor_nonlinearminus7[[i]]$hlmn7a)),0))
  
  legend('topleft',legend=bquote('activity'[0]==.(round(combined_withinhibitor_nonlinearminus7[[i]]$hlmn7b/combined_withinhibitor_nonlinearminus7[[i]]$hlmn7a*100,1))*'%'),bty='n')
  
  
  # plotting broken
  plot(seq(0,max(time),0.1),main=paste('with NU7441:',colnames(wt_4)[i]),combined_withinhibitor_nonlinearminus7[[i]]$broken*100,lwd=3,col=4,type='l',ylab='broken (%)',xlab='time (h)')
  abline(v=combined_withinhibitor_nonlinearminus7[[i]]$peakBro,col=4,lwd=3,lty=2)
  abline(h=0,col=4,lwd=3,lty=2)
  
  legend('topright',legend=bquote(tau == .(combined_withinhibitor_nonlinearminus7[[i]]$peakBro)~' h '), bty='n')
  
  #plot rates
  bplt=barplot(main=paste('with NU7441:',colnames(wt_4)[i]),c(kcmax,kp,km,kpl1,kmn7a,kmn7b),
               col=c(4,1,2,5,6,7),names.arg=
                 c(expression('k'['c']*'max'), 
                   expression('k'['p']), 
                   expression('k'['m']),
                   expression('k'['+1']),
                   expression('k'['-7,t=0h']),
                   expression('k'['-7,t=60h'])
                 ),horiz=TRUE,las=2,xlab=expression('h'^-1));
  
  rg=range(c(kcmax,kp,km,kpl1,kmn7a,kmn7b));
  
  text(mean(rg),bplt[1,1],bquote(.(round(kcmax/10^floor(log10(kcmax)),1)) *'x 10' ^ .(floor(log10(kcmax)))),col=3,cex=1.5)
  
  text(mean(rg),bplt[2,1],bquote(.(round(kp/10^floor(log10(kp)),1)) *'x 10' ^ .(floor(log10(kp)))),col=3,cex=1.5)
  
  text(mean(rg),bplt[3,1],bquote(.(round(km/10^floor(log10(km)),1)) *'x 10' ^ .(floor(log10(km)))),col=3,cex=1.5)
  
  text(mean(rg),bplt[4,1],bquote(.(round(kpl1/10^floor(log10(kpl1)),1)) *'x 10' ^ .(floor(log10(kpl1)))),col=3,cex=1.5)
  
  text(mean(rg),bplt[5,1],bquote(.(round(kmn7a/10^floor(log10(kmn7a)),1)) *'x 10' ^ .(floor(log10(kmn7a)))),col=3,cex=1.5)
  
  text(mean(rg),bplt[6,1],bquote(.(round(kmn7b/10^floor(log10(kmn7b)),1)) *'x 10' ^ .(floor(log10(kmn7b)))),col=3,cex=1.5)
  
}

print(R_sq_i)
print(mean(R_sq_i))
print(sd(R_sq_i))

print(R_sq_i_plus1)
print(mean(R_sq_i_plus1))
print(sd(R_sq_i_plus1))

print(R_sq_i_minus7)
print(mean(R_sq_i_minus7))
print(sd(R_sq_i_minus7))

```

<h2>Compare the accerlating model (combined model) with the constant model</h2>
  <p>1: R_sq comparison</p>
  <p>2: F-statistic: invididual series</p>
  <p>3: without and with inhibitor</p>
  
```{r constant model vs accerlating model}

rg=c(0.8,1);

# without inhibitor
beeswarm(main='w/o NU7441',list(R2calculator(indel_1,sapply(noinhibitor_total_individual_series,function(x){x$mutant})),R2calculator(indel_3,sapply(noinhibitor_total_individual_series_split,function(x){x$mutant})),R2calculator(plus1_3,sapply(noinhibitor_total_individual_series_split,function(x){x$plus1})),R2calculator(minus7_3,sapply(noinhibitor_total_individual_series_split,function(x){x$minus7})),R2calculator(minus7_3,sapply(combined_noinhibitor_nonlinearminus7,function(x){x$minus7})))
         ,pch=c(16,16,17,18,15),cex=1.5,col=c(6,3,3,3,4),labels = c("total", "total","+1","-7",'-7'),ylab=expression('R'^2),ylim=rg)

legend('bottomleft',c(paste(round(mean(R2calculator(indel_1,sapply(noinhibitor_total_individual_series,function(x){x$mutant}))),2),'+/-',round(sd(R2calculator(indel_1,sapply(noinhibitor_total_individual_series,function(x){x$mutant}))),2))
                      ,paste(round(mean(R2calculator(indel_3,sapply(noinhibitor_total_individual_series_split,function(x){x$mutant}))),2),'+/-',round(sd(R2calculator(indel_3,sapply(noinhibitor_total_individual_series_split,function(x){x$mutant}))),2)),
                      paste(round(mean(R2calculator(plus1_3,sapply(noinhibitor_total_individual_series_split,function(x){x$plus1}))),2),'+/-',round(sd(R2calculator(plus1_3,sapply(noinhibitor_total_individual_series_split,function(x){x$plus1}))),2)),
                      paste(round(mean(R2calculator(minus7_3,sapply(noinhibitor_total_individual_series_split,function(x){x$minus7}))),2),'+/-',round(sd(R2calculator(minus7_3,sapply(noinhibitor_total_individual_series_split,function(x){x$minus7}))),2)),
                      paste(round(mean(R2calculator(minus7_3,sapply(combined_noinhibitor_nonlinearminus7,function(x){x$minus7}))),2),'+/-',round(sd(R2calculator(minus7_3,sapply(combined_noinhibitor_nonlinearminus7,function(x){x$minus7}))),2))
),pch=c(16,16,17,18,15),col=c(6,3,3,3,4),bty='n')

legend('bottomright',c('combined','constant','accelerating'),text.col=c(6,3,4),bty='n')


# with inhibitor
beeswarm(main='with NU7441',list(R2calculator(indel_2,sapply(withinhibitor_total_individual_series,function(x){x$mutant})),R2calculator(indel_4,sapply(withinhibitor_total_individual_series_split,function(x){x$mutant})),R2calculator(plus1_4,sapply(withinhibitor_total_individual_series_split,function(x){x$plus1})),R2calculator(minus7_4,sapply(withinhibitor_total_individual_series_split,function(x){x$minus7})),R2calculator(minus7_4,sapply(combined_withinhibitor_nonlinearminus7,function(x){x$minus7})))
         ,pch=c(16,16,17,18,15),cex=1.5,col=c(6,3,3,3,4),labels = c("total", "total","+1","-7",'-7'),ylab=expression('R'^2),ylim=rg)

legend('bottomleft',c(paste(round(mean(R2calculator(indel_2,sapply(withinhibitor_total_individual_series,function(x){x$mutant}))),2),'+/-',round(sd(R2calculator(indel_2,sapply(withinhibitor_total_individual_series,function(x){x$mutant}))),2))
                      ,paste(round(mean(R2calculator(indel_4,sapply(withinhibitor_total_individual_series_split,function(x){x$mutant}))),2),'+/-',round(sd(R2calculator(indel_4,sapply(withinhibitor_total_individual_series_split,function(x){x$mutant}))),2)),
                      paste(round(mean(R2calculator(plus1_4,sapply(withinhibitor_total_individual_series_split,function(x){x$plus1}))),2),'+/-',round(sd(R2calculator(plus1_4,sapply(withinhibitor_total_individual_series_split,function(x){x$plus1}))),2)),
                      paste(round(mean(R2calculator(minus7_4,sapply(withinhibitor_total_individual_series_split,function(x){x$minus7}))),2),'+/-',round(sd(R2calculator(minus7_4,sapply(withinhibitor_total_individual_series_split,function(x){x$minus7}))),2)),
                      paste(round(mean(R2calculator(minus7_4,sapply(combined_withinhibitor_nonlinearminus7,function(x){x$minus7}))),2),'+/-',round(sd(R2calculator(minus7_4,sapply(combined_withinhibitor_nonlinearminus7,function(x){x$minus7}))),2))
),pch=c(16,16,17,18,15),col=c(6,3,3,3,4),bty='n')

legend('bottomright',c('combined','constant','accelerating'),text.col=c(6,3,4),bty='n')



#F statistic
#################################################################
# extract time point information
time = as.numeric(row.names(wildtype_tot_LBR2));

#### no inhibitor
### individual series
df2 = min(apply(minus7_3,2,function(x){sum(as.numeric(!is.na(x)))-1}));

# residual sum square for constant model
conresisq = colSums((apply(minus7_3,2,function(x){x[!is.na(x)]})/100-sapply(noinhibitor_total_individual_series_split,function(x){x$minus7}))^2);

# residual sum square for accelerating model
accresisq = colSums((apply(minus7_3,2,function(x){x[!is.na(x)]})/100-sapply(combined_noinhibitor_nonlinearminus7,function(x){x$minus7}))^2);

rg = range(c(log2(conresisq),log2(accresisq)));

plot(main='w/o NU7441',log2(conresisq),log2(accresisq),xlim=rg,ylim=rg,pch=16,col=4,cex=2,xlab=bquote('log'[2]*'(sum of resid'^2*'): constant'),ylab=bquote('log'[2]*'(sum of resid'^2*'): accelerating'));

abline(-log2(qf(0.95,df2,df2-1)),1,lwd=2,lty=2,col=3)

abline(-log2(qf(0.5,df2,df2-1)),1,lwd=2,lty=2)
abline(log2(qf(0.5,df2-1,df2)),1,lwd=2,lty=2)
abline(log2(qf(0.95,df2-1,df2)),1,lwd=2,lty=2,col=6)

text(mean(rg)+log2(qf(0.95,df2,df2-1))/2,mean(rg)-log2(qf(0.95,df2,df2-1))/2,'p=0.05',pos=4,col=3)
text(mean(rg)-log2(qf(0.95,df2-1,df2))/2,mean(rg)+log2(qf(0.95,df2-1,df2))/2,'p=0.05',pos=2,col=6)
text(mean(rg),mean(rg),'p=0.5')

legend('topleft','constant model is better',bty='n',text.col=6)
legend('bottomright','accelerating model is better',bty='n',text.col=3)


#### with inhibitor
### individual series
df2 = min(apply(minus7_4,2,function(x){sum(as.numeric(!is.na(x)))-1}));

# residual sum square for constant model
conresisq = colSums((apply(minus7_4,2,function(x){x[!is.na(x)]})/100-sapply(withinhibitor_total_individual_series_split,function(x){x$minus7}))^2);

# residual sum square for accelerating model
accresisq = colSums((apply(minus7_4,2,function(x){x[!is.na(x)]})/100-sapply(combined_withinhibitor_nonlinearminus7,function(x){x$minus7}))^2);

rg = range(c(log2(conresisq),log2(accresisq)));

plot(main='with NU7441',log2(conresisq),log2(accresisq),xlim=rg,ylim=rg,pch=16,col=2,cex=2,xlab=bquote('log'[2]*'(sum of resid'^2*'): constant'),ylab=bquote('log'[2]*'(sum of resid'^2*'): accelerating'));

abline(-log2(qf(0.95,df2,df2-1)),1,lwd=2,lty=2,col=3)

abline(-log2(qf(0.5,df2,df2-1)),1,lwd=2,lty=2)
abline(log2(qf(0.5,df2-1,df2)),1,lwd=2,lty=2)
abline(log2(qf(0.95,df2-1,df2)),1,lwd=2,lty=2,col=6)

text(mean(rg)+log2(qf(0.95,df2,df2-1))/2,mean(rg)-log2(qf(0.95,df2,df2-1))/2,'p=0.05',pos=4,col=3)
text(mean(rg)-log2(qf(0.95,df2-1,df2))/2,mean(rg)+log2(qf(0.95,df2-1,df2))/2,'p=0.05',pos=2,col=6)
text(mean(rg),mean(rg),'p=0.5')

legend('topleft','constant model is better',bty='n',text.col=6)
legend('bottomright','accelerating model is better',bty='n',text.col=3)

```

<h2>Compare combinated mutation model and individual mutation model</h2>
<p>split into without and with NU7441</p>
<p>Compare common values for hlc, hlp, hlm and peakBro</p>

```{r combined model vs individual indel model}

####without inhibitor
# hlc
beeswarm(main='w/o NU7441',list(log(2)/sapply(noinhibitor_total_individual_series,function(x){x$hlc}),log(2)/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlc})),pch=c(16,16),cex=1.5,col=c(6,3),labels = c("fitting comb.mut", "fitting indv. mut"),ylab=expression('k'['c']*'max'*' (h'^-1*')'))

legend('topleft',legend=bquote(rho==.(round(cor(log(2)/sapply(noinhibitor_total_individual_series,function(x){x$hlc}),log(2)/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlc}),method='spearman'),2))),bty='n')

# hlp
beeswarm(main='w/o NU7441',list(log(2)/(sapply(noinhibitor_total_individual_series,function(x){x$hlm})/sapply(noinhibitor_total_individual_series,function(x){x$perfectF})),log(2)/(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlm})/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$perfectF}))),pch=c(16,16),cex=1.5,col=c(6,3),labels = c("fitting comb.mut", "fitting indv. mut"),ylab=expression('k'['p']*' (h'^-1*')'))

legend('topleft',legend=bquote(rho==.(round(cor(log(2)/(sapply(noinhibitor_total_individual_series,function(x){x$hlm})/sapply(noinhibitor_total_individual_series,function(x){x$perfectF})),log(2)/(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlm})/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$perfectF})),method='spearman'),2))),bty='n')


# hlm
beeswarm(main='w/o NU7441',list(log(2)/sapply(noinhibitor_total_individual_series,function(x){x$hlm}),log(2)/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlm})),pch=c(16,16),cex=1.5,col=c(6,3),labels = c("fitting comb.mut", "fitting indv. mut"),ylab=expression('k'['m']*' (h'^-1*')'))

legend('topleft',legend=bquote(rho==.(round(cor(log(2)/sapply(noinhibitor_total_individual_series,function(x){x$hlm}),log(2)/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlm}),method='spearman'),2))),bty='n')

# peakBro
beeswarm(main='w/o NU7441',list(sapply(noinhibitor_total_individual_series,function(x){x$peakBro}),sapply(combined_noinhibitor_nonlinearminus7,function(x){x$peakBro})),pch=c(16,16),cex=1.5,col=c(6,3),labels = c("fitting comb.mut", "fitting indv. mut"),ylab=expression(tau *' (h)'))

legend('topleft',legend=bquote(rho==.(round(cor(sapply(noinhibitor_total_individual_series,function(x){x$peakBro}),sapply(combined_noinhibitor_nonlinearminus7,function(x){x$peakBro}),method='spearman'),2))),bty='n')


####without inhibitor
# hlc
beeswarm(main='with NU7441',list(log(2)/sapply(withinhibitor_total_individual_series,function(x){x$hlc}),log(2)/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlc})),pch=c(16,16),cex=1.5,col=c(6,3),labels = c("fitting comb.mut", "fitting indv. mut"),ylab=expression('k'['c']*'max'*' (h'^-1*')'))

legend('topleft',legend=bquote(rho==.(round(cor(log(2)/sapply(withinhibitor_total_individual_series,function(x){x$hlc}),log(2)/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlc}),method='spearman'),2))),bty='n')

# hlp
beeswarm(main='with NU7441',list(log(2)/(sapply(withinhibitor_total_individual_series,function(x){x$hlm})/sapply(withinhibitor_total_individual_series,function(x){x$perfectF})),log(2)/(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlm})/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$perfectF}))),pch=c(16,16),cex=1.5,col=c(6,3),labels = c("fitting comb.mut", "fitting indv. mut"),ylab=expression('k'['p']*' (h'^-1*')'))

legend('topleft',legend=bquote(rho==.(round(cor(log(2)/(sapply(withinhibitor_total_individual_series,function(x){x$hlm})/sapply(withinhibitor_total_individual_series,function(x){x$perfectF})),log(2)/(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlm})/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$perfectF})),method='spearman'),2))),bty='n')


# hlm
beeswarm(main='with NU7441',list(log(2)/sapply(withinhibitor_total_individual_series,function(x){x$hlm}),log(2)/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlm})),pch=c(16,16),cex=1.5,col=c(6,3),labels = c("fitting comb.mut", "fitting indv. mut"),ylab=expression('k'['m']*' (h'^-1*')'))

legend('topleft',legend=bquote(rho==.(round(cor(log(2)/sapply(withinhibitor_total_individual_series,function(x){x$hlm}),log(2)/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlm}),method='spearman'),2))),bty='n')

# peakBro
beeswarm(main='with NU7441',list(sapply(withinhibitor_total_individual_series,function(x){x$peakBro}),sapply(combined_withinhibitor_nonlinearminus7,function(x){x$peakBro})),pch=c(16,16),cex=1.5,col=c(6,3),labels = c("fitting comb.mut", "fitting indv. mut"),ylab=expression(tau *' (h)'))

legend('topleft',legend=bquote(rho==.(round(cor(sapply(withinhibitor_total_individual_series,function(x){x$peakBro}),sapply(combined_withinhibitor_nonlinearminus7,function(x){x$peakBro}),method='spearman'),2))),bty='n')
```

<h2>Collect individual data series and represent parameters, +1 and -7a, -7b, accelerating model (combined model)</h2>
  
```{r rates accelerating model}

library(beeswarm);
# hlc
beeswarm(list(log(2)/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlc}),log(2)/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlc})),pch=16,cex=1.5,col=c(4,2),labels = c("w/o NU7441", "with NU7441"),ylab=expression('k'['c']*'max'*' (h'^-1*')'))

lgd = legend('topright',c(paste(round(mean(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlc})),1),'',round(sd(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlc})),1)),paste(round(mean(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlc})),1),'+/-',round(sd(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlc})),1))),text.col=c(0,0),bty='n');

d1 = log(2)/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlc});
d2 = log(2)/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlc});

text(lgd$text$x[1],lgd$text$y[1],bquote('('*.(round(mean(d1)/10^(floor(log10(mean(d1)))),1)) *''* .(round(sd(d1)/10^(floor(log10(mean(d1)))),1))*') x 10' ^ .(floor(log10(mean(d1))))),col=4)

text(lgd$text$x[2],lgd$text$y[2],bquote('('*.(round(mean(d2)/10^(floor(log10(mean(d2)))),1)) *''* .(round(sd(d2)/10^(floor(log10(mean(d2)))),1))*') x 10' ^ .(floor(log10(mean(d2))))),col=2)

text(lgd$text$x[2]+(lgd$text$x[2]-lgd$text$x[1]),lgd$text$y[2]
     +(lgd$text$y[2]-lgd$text$y[1]),paste('p =',round(wilcox.test(d1,d2)$p.value,2)))


# hlp
beeswarm(list(log(2)/(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlm})/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$perfectF})),log(2)/(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlm})/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$perfectF}))),pch=16,cex=1.5,col=c(4,2),labels = c("w/o NU7441", "with NU7441"),ylab=expression('k'['p']*' (h'^-1*')'));

lgd = legend('bottomright',c(paste(round(mean(log(2)/(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlm})/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$perfectF}))),2),'+/-',round(sd(log(2)/(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlm})/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$perfectF}))),2)),paste(round(mean(log(2)/(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlm})/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$perfectF}))),2),'+/-',round(sd(log(2)/(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlm})/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$perfectF}))),2))),text.col=c(0,0),bty='n')

d1 = (log(2)/(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlm})/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$perfectF})));
d2 = (log(2)/(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlm})/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$perfectF})));

text(lgd$text$x[1]-(lgd$text$x[2]-lgd$text$x[1]),lgd$text$y[1]-(lgd$text$y[2]-lgd$text$y[1]),bquote('('*.(round(mean(d1)/10^(floor(log10(mean(d1)))),1)) *''* .(round(sd(d1)/10^(floor(log10(mean(d1)))),1))*') x 10' ^ .(floor(log10(mean(d1))))),col=4)

text(lgd$text$x[1],lgd$text$y[1],bquote('('*.(round(mean(d2)/10^(floor(log10(mean(d2)))),1)) *''* .(round(sd(d2)/10^(floor(log10(mean(d2)))),1))*') x 10' ^ .(floor(log10(mean(d2))))),col=2)

text(lgd$text$x[2],lgd$text$y[2],paste('p =',round(wilcox.test(d1,d2)$p.value,2)))

# hlm
beeswarm(list(log(2)/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlm}),log(2)/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlm})),pch=16,cex=1.5,col=c(4,2),labels = c("w/o NU7441", "with NU7441"),ylab=expression('k'['m']*' (h'^-1*')'))

lgd = legend('topright',c(paste(round(mean(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlm})),1),'',round(sd(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlm})),1)),paste(round(mean(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlm})),1),'+/-',round(sd(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlm})),1))),text.col=c(0,0),bty='n');

d1 = log(2)/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlm});
d2 = log(2)/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlm});

text(lgd$text$x[1],lgd$text$y[1],bquote('('*.(round(mean(d1)/10^(floor(log10(mean(d1)))),1)) *''* .(round(sd(d1)/10^(floor(log10(mean(d1)))),1))*') x 10' ^ .(floor(log10(mean(d1))))),col=4)

text(lgd$text$x[2],lgd$text$y[2],bquote('('*.(round(mean(d2)/10^(floor(log10(mean(d2)))),1)) *''* .(round(sd(d2)/10^(floor(log10(mean(d2)))),1))*') x 10' ^ .(floor(log10(mean(d2))))),col=2)

text(lgd$text$x[2]+(lgd$text$x[2]-lgd$text$x[1]),lgd$text$y[2]
     +(lgd$text$y[2]-lgd$text$y[1]),paste('p =',round(wilcox.test(d1,d2)$p.value,2)))

# hlpl1
beeswarm(list(log(2)/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlpl1}),log(2)/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlpl1})),pch=16,cex=1.5,col=c(4,2),labels = c("w/o NU7441", "with NU7441"),ylab=expression('k'['+1']*' (h'^-1*')'))

lgd = legend('topright',c(paste(round(mean(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlpl1})),1),'',round(sd(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlpl1})),1)),paste(round(mean(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlpl1})),1),'+/-',round(sd(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlpl1})),1))),text.col=c(0,0),bty='n');

d1 = log(2)/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlpl1});
d2 = log(2)/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlpl1});

text(lgd$text$x[1],lgd$text$y[1],bquote('('*.(round(mean(d1)/10^(floor(log10(mean(d1)))),1)) *''* .(round(sd(d1)/10^(floor(log10(mean(d1)))),1))*') x 10' ^ .(floor(log10(mean(d1))))),col=4)

text(lgd$text$x[2],lgd$text$y[2],bquote('('*.(round(mean(d2)/10^(floor(log10(mean(d2)))),1)) *''* .(round(sd(d2)/10^(floor(log10(mean(d2)))),1))*') x 10' ^ .(floor(log10(mean(d2))))),col=2)

text(lgd$text$x[2]+(lgd$text$x[2]-lgd$text$x[1]),lgd$text$y[2]
     +(lgd$text$y[2]-lgd$text$y[1]),paste('p =',round(wilcox.test(d1,d2)$p.value,2)))

# hlmn7 a
beeswarm(list(log(2)/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlmn7a}),log(2)/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlmn7a})),pch=16,cex=1.5,col=c(4,2),labels = c("w/o NU7441", "with NU7441"),ylab=expression('k'['-7,t=0h']*' (h'^-1*')'))

lgd = legend('bottomright',c(paste(round(mean(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlmn7b})),1),'',round(sd(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlmn7b})),1)),paste(round(mean(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlmn7b})),1),'',round(sd(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlmn7b})),1))),text.col=c(0,0),bty='n');

d1 = log(2)/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlmn7a});
d2 = log(2)/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlmn7a});

text(lgd$text$x[1]-(lgd$text$x[2]-lgd$text$x[1]),lgd$text$y[1]-(lgd$text$y[2]-lgd$text$y[1]),bquote('('*.(round(mean(d1)/10^(floor(log10(mean(d1)))),1)) *''* .(round(sd(d1)/10^(floor(log10(mean(d1)))),1))*') x 10' ^ .(floor(log10(mean(d1))))),col=4)

text(lgd$text$x[1],lgd$text$y[1],bquote('('*.(round(mean(d2)/10^(floor(log10(mean(d2)))),1)) *''* .(round(sd(d2)/10^(floor(log10(mean(d2)))),1))*') x 10' ^ .(floor(log10(mean(d2))))),col=2)

text(lgd$text$x[2],lgd$text$y[2],paste('p =',round(wilcox.test(d1,d2)$p.value,2)))

# hlmn7 b
beeswarm(list(log(2)/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlmn7b}),log(2)/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlmn7b})),pch=16,cex=1.5,col=c(4,2),labels = c("w/o NU7441", "with NU7441"),ylab=expression('k'['-7,t=60h']*' (h'^-1*')'))

lgd = legend('topright',c(paste(round(mean(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlmn7b})),1),'',round(sd(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlmn7b})),1)),paste(round(mean(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlmn7b})),1),'',round(sd(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlmn7b})),1))),text.col=c(0,0),bty='n');

d1 = log(2)/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlmn7b});
d2 = log(2)/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlmn7b});

text(lgd$text$x[1],lgd$text$y[1],bquote('('*.(round(mean(d1)/10^(floor(log10(mean(d1)))),1)) *''* .(round(sd(d1)/10^(floor(log10(mean(d1)))),1))*') x 10' ^ .(floor(log10(mean(d1))))),col=4)

text(lgd$text$x[2],lgd$text$y[2],bquote('('*.(round(mean(d2)/10^(floor(log10(mean(d2)))),1)) *''* .(round(sd(d2)/10^(floor(log10(mean(d2)))),1))*') x 10' ^ .(floor(log10(mean(d2))))),col=2)

text(lgd$text$x[2]+(lgd$text$x[2]-lgd$text$x[1]),lgd$text$y[2]
     +(lgd$text$y[2]-lgd$text$y[1]),paste('p =',round(wilcox.test(d1,d2)$p.value,2)))

# activity zero

beeswarm(list(100*sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlmn7b})/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlmn7a}),100*sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlmn7b})/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlmn7a})),pch=16,cex=1.5,col=c(4,2),labels = c("w/o NU7441", "with NU7441"),ylab=bquote('a'[0]*' (%)'))

d1 = 100*sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlmn7b})/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlmn7a});
d2 = 100*sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlmn7b})/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlmn7a});

lgd = legend('bottomright',c(paste(round(mean(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlmn7b})),1),'',round(sd(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlmn7b})),1)),paste(round(mean(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlmn7b})),1),'',round(sd(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlmn7b})),1))),text.col=c(0,0),bty='n');

text(lgd$text$x[1]-(lgd$text$x[2]-lgd$text$x[1]),lgd$text$y[1]-(lgd$text$y[2]-lgd$text$y[1]),bquote('('*.(round(mean(d1)/10^(floor(log10(mean(d1)))),1)) *''* .(round(sd(d1)/10^(floor(log10(mean(d1)))),1))*') x 10' ^ .(floor(log10(mean(d1))))),col=4)

text(lgd$text$x[1],lgd$text$y[1],bquote('('*.(round(mean(d2)/10^(floor(log10(mean(d2)))),1)) *''* .(round(sd(d2)/10^(floor(log10(mean(d2)))),1))*') x 10' ^ .(floor(log10(mean(d2))))),col=2)

text(lgd$text$x[2],lgd$text$y[2],paste('p =',round(wilcox.test(d1,d2)$p.value,2)))


# peakBro
beeswarm(list(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$peakBro}),sapply(combined_withinhibitor_nonlinearminus7,function(x){x$peakBro})),pch=16,cex=1.5,col=c(4,2),labels = c("w/o NU7441", "with NU7441"),ylab=bquote(tau * ' (h)' ))

d1 = sapply(combined_noinhibitor_nonlinearminus7,function(x){x$peakBro})
d2 = sapply(combined_withinhibitor_nonlinearminus7,function(x){x$peakBro})

lgd = legend('bottomright',c(paste(round(mean(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$peakBro})),1),'',round(sd(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$peakBro})),1)),paste(round(mean(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$peakBro})),1),'',round(sd(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$peakBro})),1))),text.col=c(0,0),bty='n');

text(lgd$text$x[1]-(lgd$text$x[2]-lgd$text$x[1]),lgd$text$y[1]-(lgd$text$y[2]-lgd$text$y[1]),paste(round(mean(d1),1),'',round(sd(d1),1)),col=4)

text(lgd$text$x[1],lgd$text$y[1],paste(round(mean(d2),1),'',round(sd(d2),1)),col=2)

text(lgd$text$x[2],lgd$text$y[2],paste('p =',round(wilcox.test(d1,d2)$p.value,2)))

```

<h2>Accumulating all the rates together, accelerating model (combined model)</h2>
  <p>real rates</p>
  <p>arbitrary units for relative effects</p>
  
```{r overview rates accelerating model}

library(beeswarm);
rates_AM = rep(list(NULL),6*2);
# hlc
rates_AM[[1]] = log(2)/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlc});
rates_AM[[2]] = log(2)/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlc});

# hlp
rates_AM[[3]] = (log(2)/(sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlm})/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$perfectF})));
rates_AM[[4]] = (log(2)/(sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlm})/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$perfectF})));

# hlm
rates_AM[[5]] = log(2)/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlm});
rates_AM[[6]] = log(2)/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlm});

# hlpl1
rates_AM[[7]] = log(2)/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlpl1});
rates_AM[[8]] = log(2)/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlpl1});


# hlmn7 a
rates_AM[[9]] = log(2)/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlmn7a});
rates_AM[[10]] = log(2)/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlmn7a});

# hlmn7 b
rates_AM[[11]] = log(2)/sapply(combined_noinhibitor_nonlinearminus7,function(x){x$hlmn7b});
rates_AM[[12]] = log(2)/sapply(combined_withinhibitor_nonlinearminus7,function(x){x$hlmn7b});

bm=beeswarm(rates_AM,pch=16,cex=1,col=c(4,2),las=2,labels='',ylab=expression('h'^-1),corral='wrap')

axis(1,at=seq(1.5,11.5,2),labels=c(expression('k'['c']*'max'),expression('k'['p']),expression('k'['m']),expression('k'['+1']),expression('k'['-7,t=0h']),expression('k'['-7,t=60h'])))

legend("topright", 
       legend = c("w/o NU7441", "with NU7441"), 
       text.col = c(4, 2),bty='n')

```

<h2>SessionInfo</h2>

```{r sessioninfo}

sessionInfo()

```
